{
    "sourceFile": "Servidor/routes/auth.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 41,
            "patches": [
                {
                    "date": 1752269446397,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752349193520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,5 +124,35 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+// Verifica o token do usuário e mantem na mesma página\r\n+const { protect } = require('../middleware/authMiddleware'); // Certifique-se que o protect está importado\r\n+const Company = require('../models/Company');\r\n+const User = require('../models/User');\r\n+\r\n+// NOVA ROTA: GET /api/auth/me - Para verificar o token e obter os dados do usuário\r\n+router.get('/me', protect, async (req, res) => {\r\n+    try {\r\n+        // Se chegou até aqui, o middleware 'protect' já validou o token.\r\n+        // O payload do token está em req.user.\r\n+        if (req.user.role === 'SuperAdmin') {\r\n+            // Se for o SuperAdmin, retornamos um objeto simples\r\n+            return res.status(200).json({ user: { role: 'SuperAdmin' } });\r\n+        }\r\n+        \r\n+        // Se for um usuário normal, buscamos seus dados completos\r\n+        const user = await User.findById(req.user.id).select('-password');\r\n+        const company = await Company.findById(req.user.companyId).select('-senhaEmpresa');\r\n+\r\n+        if (!user || !company) {\r\n+            return res.status(404).json({ message: 'Usuário ou empresa não encontrados.' });\r\n+        }\r\n+\r\n+        res.status(200).json({ user, company });\r\n+\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao verificar a sessão.' });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752349499272,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,23 +125,21 @@\n     }\r\n });\r\n \r\n // Verifica o token do usuário e mantem na mesma página\r\n-const { protect } = require('../middleware/authMiddleware'); // Certifique-se que o protect está importado\r\n+const { protect } = require('../middleware/authMiddleware');\r\n const Company = require('../models/Company');\r\n const User = require('../models/User');\r\n \r\n // NOVA ROTA: GET /api/auth/me - Para verificar o token e obter os dados do usuário\r\n router.get('/me', protect, async (req, res) => {\r\n     try {\r\n-        // Se chegou até aqui, o middleware 'protect' já validou o token.\r\n-        // O payload do token está em req.user.\r\n+        // O middleware 'protect' já validou o token e colocou os dados em req.user.\r\n         if (req.user.role === 'SuperAdmin') {\r\n-            // Se for o SuperAdmin, retornamos um objeto simples\r\n             return res.status(200).json({ user: { role: 'SuperAdmin' } });\r\n         }\r\n         \r\n-        // Se for um usuário normal, buscamos seus dados completos\r\n+        // Para usuários normais, buscamos os dados mais recentes\r\n         const user = await User.findById(req.user.id).select('-password');\r\n         const company = await Company.findById(req.user.companyId).select('-senhaEmpresa');\r\n \r\n         if (!user || !company) {\r\n"
                },
                {
                    "date": 1752350382334,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,16 +1,15 @@\n const express = require('express');\r\n const router = express.Router();\r\n const bcrypt = require('bcryptjs');\r\n const jwt = require('jsonwebtoken');\r\n+const { protect } = require('../middleware/authMiddleware');\r\n \r\n-// MUDANÇA: Importamos os modelos Company e o novo modelo User\r\n+// Modelos importados uma única vez, no topo\r\n const Company = require('../models/Company');\r\n-const User = require('../models/User'); \r\n+const User = require('../models/User');\r\n \r\n // Rota: POST /api/auth/login/company\r\n-// Esta rota continua praticamente igual, pois serve apenas para validar a empresa\r\n-// antes de mostrar a tela de login de usuário.\r\n router.post('/login/company', async (req, res) => {\r\n     try {\r\n         const { cnpj, password } = req.body;\r\n         if (!cnpj || !password) {\r\n@@ -24,10 +23,8 @@\n         if (!isMatch) {\r\n             return res.status(401).json({ message: 'CNPJ ou Senha da Empresa incorretos.' });\r\n         }\r\n         const token = jwt.sign({ id: company._id, cnpj: company.cnpj }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n-        \r\n-        // MUDANÇA: A resposta agora é mais limpa, não precisamos de enviar a lista de usuários.\r\n         res.status(200).json({\r\n             message: 'Login bem-sucedido!',\r\n             token: token,\r\n             company: { _id: company._id, nomeEmpresa: company.nomeEmpresa, cnpj: company.cnpj }\r\n@@ -37,9 +34,8 @@\n     }\r\n });\r\n \r\n // Rota: POST /api/auth/login/admin\r\n-// Nenhuma mudança necessária aqui. A lógica do admin é independente.\r\n router.post('/login/admin', async (req, res) => {\r\n     try {\r\n         const { username, password } = req.body;\r\n         if (username === process.env.ADMIN_USERNAME && password === process.env.ADMIN_PASSWORD) {\r\n@@ -52,69 +48,50 @@\n         res.status(500).json({ message: 'Erro interno do servidor' });\r\n     }\r\n });\r\n \r\n-\r\n // Rota: POST /api/auth/register/user\r\n-// GRANDE MUDANÇA AQUI\r\n-router.post('/register/user', async (req, res) => {\r\n+router.post('/register/user', protect, async (req, res) => {\r\n     try {\r\n         const { username, password, companyId } = req.body;\r\n         if (!username || !password || !companyId) {\r\n             return res.status(400).json({ message: 'Dados insuficientes para registrar o usuário.' });\r\n         }\r\n-\r\n-        // ANTES: Procurávamos a empresa para adicionar um usuário à sua lista interna.\r\n-        // AGORA: Verificamos se o usuário já existe na coleção 'User', filtrando por empresa.\r\n         const userExists = await User.findOne({ username, company: companyId });\r\n         if (userExists) {\r\n             return res.status(400).json({ message: 'Este nome de usuário já existe nesta empresa.' });\r\n         }\r\n-\r\n         const salt = await bcrypt.genSalt(10);\r\n         const hashedPassword = await bcrypt.hash(password, salt);\r\n-        \r\n-        // ANTES: company.usuarios.push(...)\r\n-        // AGORA: Criamos um documento totalmente novo na coleção 'User'.\r\n         await User.create({\r\n             username,\r\n             password: hashedPassword,\r\n-            role: 'Funcionário', // Por padrão, usuários registados são funcionários\r\n-            company: companyId // A ligação à empresa\r\n+            role: 'Funcionário',\r\n+            company: companyId\r\n         });\r\n-\r\n         res.status(201).json({ message: `Usuário '${username}' registrado com sucesso!` });\r\n     } catch (error) {\r\n         console.error(\"Erro ao registrar usuário:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-\r\n // Rota: POST /api/auth/login/user\r\n-// GRANDE MUDANÇA AQUI\r\n router.post('/login/user', async (req, res) => {\r\n     try {\r\n         const { username, password, companyId } = req.body;\r\n         if (!username || !password || !companyId) {\r\n             return res.status(400).json({ message: 'Dados insuficientes para o login.' });\r\n         }\r\n-\r\n-        // ANTES: Procurávamos a empresa e depois o usuário dentro dela.\r\n-        // AGORA: Procuramos o usuário diretamente na coleção 'User', garantindo que pertence à empresa certa.\r\n         const user = await User.findOne({ username, company: companyId });\r\n         if (!user) {\r\n             return res.status(401).json({ message: 'Usuário ou senha incorretos.' });\r\n         }\r\n-\r\n         const isMatch = await bcrypt.compare(password, user.password);\r\n         if (!isMatch) {\r\n             return res.status(401).json({ message: 'Usuário ou senha incorretos.' });\r\n         }\r\n-        \r\n-        // A geração do token continua igual, usando os dados do usuário encontrado.\r\n         const token = jwt.sign({ id: user._id, companyId: user.company, role: user.role }, process.env.JWT_SECRET, { expiresIn: '8h' });\r\n-        \r\n         res.status(200).json({\r\n             message: 'Login de usuário bem-sucedido!',\r\n             token,\r\n             user: { id: user._id, username: user.username, role: user.role }\r\n@@ -124,22 +101,15 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// Verifica o token do usuário e mantem na mesma página\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const Company = require('../models/Company');\r\n-const User = require('../models/User');\r\n-\r\n-// NOVA ROTA: GET /api/auth/me - Para verificar o token e obter os dados do usuário\r\n+// Rota: GET /api/auth/me - Para verificar o token e obter os dados do usuário\r\n router.get('/me', protect, async (req, res) => {\r\n     try {\r\n-        // O middleware 'protect' já validou o token e colocou os dados em req.user.\r\n         if (req.user.role === 'SuperAdmin') {\r\n             return res.status(200).json({ user: { role: 'SuperAdmin' } });\r\n         }\r\n         \r\n-        // Para usuários normais, buscamos os dados mais recentes\r\n         const user = await User.findById(req.user.id).select('-password');\r\n         const company = await Company.findById(req.user.companyId).select('-senhaEmpresa');\r\n \r\n         if (!user || !company) {\r\n"
                },
                {
                    "date": 1752505849745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,5 +122,47 @@\n         res.status(500).json({ message: 'Erro ao verificar a sessão.' });\r\n     }\r\n });\r\n \r\n+// NOVA ROTA: POST /api/auth/login/direct - Para login unificado de usuário\r\n+router.post('/login/direct', async (req, res) => {\r\n+    try {\r\n+        const { cnpj, username, password } = req.body;\r\n+\r\n+        if (!cnpj || !username || !password) {\r\n+            return res.status(400).json({ message: 'Todos os campos (CNPJ, Usuário e Senha) são obrigatórios.' });\r\n+        }\r\n+\r\n+        // 1. Encontra a empresa pelo CNPJ\r\n+        const company = await Company.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n+        if (!company) {\r\n+            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n+        }\r\n+\r\n+        // 2. Encontra o usuário DENTRO da empresa encontrada\r\n+        const user = await User.findOne({ username: username, company: company._id });\r\n+        if (!user) {\r\n+            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n+        }\r\n+\r\n+        // 3. Compara a senha do usuário\r\n+        const isMatch = await bcrypt.compare(password, user.password);\r\n+        if (!isMatch) {\r\n+            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n+        }\r\n+        \r\n+        // 4. Se tudo estiver correto, gera o token de acesso final\r\n+        const token = jwt.sign({ id: user._id, companyId: user.company, role: user.role }, process.env.JWT_SECRET, { expiresIn: '8h' });\r\n+        \r\n+        res.status(200).json({\r\n+            message: 'Login bem-sucedido!',\r\n+            token, // Envia o token diretamente\r\n+            user: { id: user._id, username: user.username, role: user.role }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no login direto:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752680163266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,31 @@\n         res.status(500).json({ message: 'Erro interno do servidor' });\r\n     }\r\n });\r\n \r\n+router.post('/find-company-by-cnpj', async (req, res) => {\r\n+    try {\r\n+        const { cnpj } = req.body;\r\n+        if (!cnpj) {\r\n+            return res.status(400).json({ message: 'Por favor, forneça um CNPJ.' });\r\n+        }\r\n+        \r\n+        const company = await Company.findOne({ cnpj: cnpj.replace(/\\D/g, '') }).select('nomeEmpresa');\r\n+        \r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Nenhuma empresa encontrada com este CNPJ.' });\r\n+        }\r\n+\r\n+        // Retorna apenas os dados públicos da empresa, SEM TOKEN.\r\n+        res.status(200).json({\r\n+            message: 'Empresa encontrada!',\r\n+            company: company\r\n+        });\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno no servidor' });\r\n+    }\r\n+});\r\n+\r\n // Rota: POST /api/auth/register/user\r\n router.post('/register/user', protect, async (req, res) => {\r\n     try {\r\n         const { username, password, companyId } = req.body;\r\n"
                },
                {
                    "date": 1752931643145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,12 +2,12 @@\n const router = express.Router();\r\n const bcrypt = require('bcryptjs');\r\n const jwt = require('jsonwebtoken');\r\n const { protect } = require('../middleware/authMiddleware');\r\n-\r\n-// Modelos importados uma única vez, no topo\r\n const Company = require('../models/Company');\r\n const User = require('../models/User');\r\n+const crypto = require('crypto');\r\n+const { sendPasswordResetEmail } = require('../services/emailService');\r\n \r\n // Rota: POST /api/auth/login/company\r\n router.post('/login/company', async (req, res) => {\r\n     try {\r\n@@ -187,5 +187,73 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+router.post('/forgot-password', async (req, res) => {\r\n+    try {\r\n+        const { email } = req.body;\r\n+        // MUDANÇA: Usamos o modelo Company para encontrar a empresa pelo e-mail\r\n+        const company = await Company.findOne({ email });\r\n+        if (!company) {\r\n+            // Nota: Enviamos uma mensagem de sucesso mesmo que o e-mail não exista\r\n+            // para não dar pistas a possíveis atacantes.\r\n+            return res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n+        }\r\n+\r\n+        // Encontramos o usuário Proprietário desta empresa\r\n+        const owner = await User.findOne({ company: company._id, role: 'Proprietário' });\r\n+        if (!owner) {\r\n+            return res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n+        }\r\n+\r\n+        // Gera um token aleatório e seguro\r\n+        const resetToken = crypto.randomBytes(20).toString('hex');\r\n+\r\n+        // Define o token e a sua data de expiração (1 hora) no utilizador\r\n+        owner.resetPasswordToken = resetToken;\r\n+        owner.resetPasswordExpires = Date.now() + 3600000; // 1 hora em milissegundos\r\n+        await owner.save();\r\n+\r\n+        // Envia o e-mail com o link de recuperação\r\n+        await sendPasswordResetEmail(company.email, resetToken);\r\n+\r\n+        res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro em forgot-password:\", error);\r\n+        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para definir a nova senha (Passo 2 do fluxo)\r\n+router.post('/reset-password/:token', async (req, res) => {\r\n+    try {\r\n+        const { token } = req.params;\r\n+        const { password } = req.body;\r\n+\r\n+        // Encontra o utilizador pelo token e verifica se o token ainda é válido\r\n+        const user = await User.findOne({\r\n+            resetPasswordToken: token,\r\n+            resetPasswordExpires: { $gt: Date.now() } // $gt = greater than (maior que)\r\n+        });\r\n+\r\n+        if (!user) {\r\n+            return res.status(400).json({ message: 'O link de recuperação de senha é inválido ou expirou.' });\r\n+        }\r\n+\r\n+        // Se o token for válido, atualizamos a senha\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        user.password = await bcrypt.hash(password, salt);\r\n+        // Limpamos os campos de recuperação\r\n+        user.resetPasswordToken = undefined;\r\n+        user.resetPasswordExpires = undefined;\r\n+        await user.save();\r\n+\r\n+        res.status(200).json({ message: 'Senha atualizada com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro em reset-password:\", error);\r\n+        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753137181237,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,28 @@\n const Company = require('../models/Company');\r\n const User = require('../models/User');\r\n const crypto = require('crypto');\r\n const { sendPasswordResetEmail } = require('../services/emailService');\r\n+const { body, validationResult } = require('express-validator');\r\n \r\n+const loginDirectValidationRules = [\r\n+    // 1. Regras para o campo 'cnpj'\r\n+    body('cnpj', 'O CNPJ é obrigatório e deve estar no formato correto.')\r\n+        .trim() // Remove espaços em branco no início e no fim\r\n+        .notEmpty() // Garante que não está vazio\r\n+        .isLength({ min: 18, max: 18 }), // Verifica o tamanho do CNPJ formatado\r\n+\r\n+    // 2. Regras para o campo 'username'\r\n+    body('username', 'O nome de usuário é obrigatório.')\r\n+        .trim()\r\n+        .notEmpty()\r\n+        .escape(), // Converte caracteres especiais (<, >, &, etc.) em entidades HTML para prevenir XSS\r\n+\r\n+    // 3. Regras para o campo 'password'\r\n+    body('password', 'A senha deve ter no mínimo 6 caracteres.')\r\n+        .isLength({ min: 6 })\r\n+];\r\n+\r\n // Rota: POST /api/auth/login/company\r\n router.post('/login/company', async (req, res) => {\r\n     try {\r\n         const { cnpj, password } = req.body;\r\n@@ -146,16 +165,25 @@\n     }\r\n });\r\n \r\n // NOVA ROTA: POST /api/auth/login/direct - Para login unificado de usuário\r\n-router.post('/login/direct', async (req, res) => {\r\n+router.post('/login/direct', \r\n+    // NOVO: Aplica as regras de validação à rota\r\n+    loginDirectValidationRules, \r\n+    async (req, res) => {\r\n+        \r\n+    // NOVO: Verifica o resultado da validação\r\n+    const errors = validationResult(req);\r\n+    if (!errors.isEmpty()) {\r\n+        // Se houver erros, retorna um status 400 com a lista de erros\r\n+        return res.status(400).json({ errors: errors.array() });\r\n+    }\r\n+\r\n+    // A lógica de login original só é executada se a validação passar\r\n     try {\r\n+        // O `req.body` agora contém os dados sanitizados\r\n         const { cnpj, username, password } = req.body;\r\n \r\n-        if (!cnpj || !username || !password) {\r\n-            return res.status(400).json({ message: 'Todos os campos (CNPJ, Usuário e Senha) são obrigatórios.' });\r\n-        }\r\n-\r\n         // 1. Encontra a empresa pelo CNPJ\r\n         const company = await Company.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n         if (!company) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n@@ -177,9 +205,9 @@\n         const token = jwt.sign({ id: user._id, companyId: user.company, role: user.role }, process.env.JWT_SECRET, { expiresIn: '8h' });\r\n         \r\n         res.status(200).json({\r\n             message: 'Login bem-sucedido!',\r\n-            token, // Envia o token diretamente\r\n+            token,\r\n             user: { id: user._id, username: user.username, role: user.role }\r\n         });\r\n \r\n     } catch (error) {\r\n"
                },
                {
                    "date": 1753533203338,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,287 +1,147 @@\n+// D:\\SCripts\\SiteLobos\\Servidor\\routes\\auth.js\r\n+\r\n const express = require('express');\r\n const router = express.Router();\r\n const bcrypt = require('bcryptjs');\r\n const jwt = require('jsonwebtoken');\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const Company = require('../models/Company');\r\n-const User = require('../models/User');\r\n-const crypto = require('crypto');\r\n-const { sendPasswordResetEmail } = require('../services/emailService');\r\n const { body, validationResult } = require('express-validator');\r\n \r\n-const loginDirectValidationRules = [\r\n-    // 1. Regras para o campo 'cnpj'\r\n-    body('cnpj', 'O CNPJ é obrigatório e deve estar no formato correto.')\r\n-        .trim() // Remove espaços em branco no início e no fim\r\n-        .notEmpty() // Garante que não está vazio\r\n-        .isLength({ min: 18, max: 18 }), // Verifica o tamanho do CNPJ formatado\r\n+// Importamos os modelos do banco MESTRE\r\n+const MasterCompany = require('../models/MasterCompany');\r\n+const MasterUser = require('../models/MasterUser');\r\n \r\n-    // 2. Regras para o campo 'username'\r\n-    body('username', 'O nome de usuário é obrigatório.')\r\n-        .trim()\r\n-        .notEmpty()\r\n-        .escape(), // Converte caracteres especiais (<, >, &, etc.) em entidades HTML para prevenir XSS\r\n+// O serviço de e-mail continua o mesmo\r\n+const { sendPasswordResetEmail } = require('../services/emailService');\r\n \r\n-    // 3. Regras para o campo 'password'\r\n-    body('password', 'A senha deve ter no mínimo 6 caracteres.')\r\n-        .isLength({ min: 6 })\r\n-];\r\n \r\n-// Rota: POST /api/auth/login/company\r\n-router.post('/login/company', async (req, res) => {\r\n-    try {\r\n-        const { cnpj, password } = req.body;\r\n-        if (!cnpj || !password) {\r\n-            return res.status(400).json({ message: 'Por favor, forneça CNPJ e senha.' });\r\n-        }\r\n-        const company = await Company.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n-        if (!company) {\r\n-            return res.status(401).json({ message: 'CNPJ ou Senha da Empresa incorretos.' });\r\n-        }\r\n-        const isMatch = await bcrypt.compare(password, company.senhaEmpresa);\r\n-        if (!isMatch) {\r\n-            return res.status(401).json({ message: 'CNPJ ou Senha da Empresa incorretos.' });\r\n-        }\r\n-        const token = jwt.sign({ id: company._id, cnpj: company.cnpj }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n-        res.status(200).json({\r\n-            message: 'Login bem-sucedido!',\r\n-            token: token,\r\n-            company: { _id: company._id, nomeEmpresa: company.nomeEmpresa, cnpj: company.cnpj }\r\n-        });\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno no servidor' });\r\n-    }\r\n-});\r\n-\r\n-// Rota: POST /api/auth/login/admin\r\n-router.post('/login/admin', async (req, res) => {\r\n-    try {\r\n-        const { username, password } = req.body;\r\n-        if (username === process.env.ADMIN_USERNAME && password === process.env.ADMIN_PASSWORD) {\r\n-            const token = jwt.sign({ id: 'ADMIN_ID', role: 'SuperAdmin' }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n-            res.status(200).json({ message: 'Login de admin bem-sucedido!', token });\r\n-        } else {\r\n-            res.status(401).json({ message: 'Credenciais de administrador inválidas.' });\r\n-        }\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor' });\r\n-    }\r\n-});\r\n-\r\n-router.post('/find-company-by-cnpj', async (req, res) => {\r\n-    try {\r\n-        const { cnpj } = req.body;\r\n-        if (!cnpj) {\r\n-            return res.status(400).json({ message: 'Por favor, forneça um CNPJ.' });\r\n-        }\r\n-        \r\n-        const company = await Company.findOne({ cnpj: cnpj.replace(/\\D/g, '') }).select('nomeEmpresa');\r\n-        \r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Nenhuma empresa encontrada com este CNPJ.' });\r\n-        }\r\n-\r\n-        // Retorna apenas os dados públicos da empresa, SEM TOKEN.\r\n-        res.status(200).json({\r\n-            message: 'Empresa encontrada!',\r\n-            company: company\r\n-        });\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno no servidor' });\r\n-    }\r\n-});\r\n-\r\n-// Rota: POST /api/auth/register/user\r\n-router.post('/register/user', protect, async (req, res) => {\r\n-    try {\r\n-        const { username, password, companyId } = req.body;\r\n-        if (!username || !password || !companyId) {\r\n-            return res.status(400).json({ message: 'Dados insuficientes para registrar o usuário.' });\r\n-        }\r\n-        const userExists = await User.findOne({ username, company: companyId });\r\n-        if (userExists) {\r\n-            return res.status(400).json({ message: 'Este nome de usuário já existe nesta empresa.' });\r\n-        }\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedPassword = await bcrypt.hash(password, salt);\r\n-        await User.create({\r\n-            username,\r\n-            password: hashedPassword,\r\n-            role: 'Funcionário',\r\n-            company: companyId\r\n-        });\r\n-        res.status(201).json({ message: `Usuário '${username}' registrado com sucesso!` });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao registrar usuário:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota: POST /api/auth/login/user\r\n-router.post('/login/user', async (req, res) => {\r\n-    try {\r\n-        const { username, password, companyId } = req.body;\r\n-        if (!username || !password || !companyId) {\r\n-            return res.status(400).json({ message: 'Dados insuficientes para o login.' });\r\n-        }\r\n-        const user = await User.findOne({ username, company: companyId });\r\n-        if (!user) {\r\n-            return res.status(401).json({ message: 'Usuário ou senha incorretos.' });\r\n-        }\r\n-        const isMatch = await bcrypt.compare(password, user.password);\r\n-        if (!isMatch) {\r\n-            return res.status(401).json({ message: 'Usuário ou senha incorretos.' });\r\n-        }\r\n-        const token = jwt.sign({ id: user._id, companyId: user.company, role: user.role }, process.env.JWT_SECRET, { expiresIn: '8h' });\r\n-        res.status(200).json({\r\n-            message: 'Login de usuário bem-sucedido!',\r\n-            token,\r\n-            user: { id: user._id, username: user.username, role: user.role }\r\n-        });\r\n-    } catch (error) {\r\n-        console.error(\"Erro no login do usuário:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota: GET /api/auth/me - Para verificar o token e obter os dados do usuário\r\n-router.get('/me', protect, async (req, res) => {\r\n-    try {\r\n-        if (req.user.role === 'SuperAdmin') {\r\n-            return res.status(200).json({ user: { role: 'SuperAdmin' } });\r\n-        }\r\n-        \r\n-        const user = await User.findById(req.user.id).select('-password');\r\n-        const company = await Company.findById(req.user.companyId).select('-senhaEmpresa');\r\n-\r\n-        if (!user || !company) {\r\n-            return res.status(404).json({ message: 'Usuário ou empresa não encontrados.' });\r\n-        }\r\n-\r\n-        res.status(200).json({ user, company });\r\n-\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao verificar a sessão.' });\r\n-    }\r\n-});\r\n-\r\n-// NOVA ROTA: POST /api/auth/login/direct - Para login unificado de usuário\r\n-router.post('/login/direct', \r\n-    // NOVO: Aplica as regras de validação à rota\r\n-    loginDirectValidationRules, \r\n-    async (req, res) => {\r\n-        \r\n-    // NOVO: Verifica o resultado da validação\r\n+// Rota principal de login, agora usando o banco de dados MESTRE\r\n+router.post('/login/direct', [\r\n+    body('cnpj', 'O CNPJ é obrigatório.').notEmpty(),\r\n+    body('username', 'O nome de usuário é obrigatório.').notEmpty(),\r\n+    body('password', 'A senha é obrigatória.').notEmpty()\r\n+], async (req, res) => {\r\n     const errors = validationResult(req);\r\n     if (!errors.isEmpty()) {\r\n-        // Se houver erros, retorna um status 400 com a lista de erros\r\n         return res.status(400).json({ errors: errors.array() });\r\n     }\r\n \r\n-    // A lógica de login original só é executada se a validação passar\r\n     try {\r\n-        // O `req.body` agora contém os dados sanitizados\r\n         const { cnpj, username, password } = req.body;\r\n+        \r\n+        // A conexão com o banco MESTRE é injetada pelo middleware que criamos no server.js\r\n+        const masterDb = req.masterDb;\r\n \r\n-        // 1. Encontra a empresa pelo CNPJ\r\n-        const company = await Company.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n+        // 1. Encontra a empresa no banco MESTRE pelo CNPJ\r\n+        const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n         if (!company) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        // 2. Encontra o usuário DENTRO da empresa encontrada\r\n-        const user = await User.findOne({ username: username, company: company._id });\r\n+        // 2. Encontra o usuário no banco MESTRE, garantindo que ele pertence à empresa encontrada\r\n+        const user = await MasterUser.findOne({ username: username, company: company._id });\r\n         if (!user) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        // 3. Compara a senha do usuário\r\n+        // 3. Compara a senha\r\n         const isMatch = await bcrypt.compare(password, user.password);\r\n         if (!isMatch) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n         \r\n-        // 4. Se tudo estiver correto, gera o token de acesso final\r\n-        const token = jwt.sign({ id: user._id, companyId: user.company, role: user.role }, process.env.JWT_SECRET, { expiresIn: '8h' });\r\n+        // 4. Gera o token JWT. A informação mais importante aqui é o 'companyId' do banco MESTRE.\r\n+        // O nosso 'tenantMiddleware' usará este ID para encontrar o 'dbName' e conectar ao banco correto.\r\n+        const token = jwt.sign(\r\n+            { \r\n+                id: user._id, \r\n+                companyId: user.company // ID da MasterCompany\r\n+            }, \r\n+            process.env.JWT_SECRET, \r\n+            { expiresIn: '8h' }\r\n+        );\r\n         \r\n         res.status(200).json({\r\n             message: 'Login bem-sucedido!',\r\n             token,\r\n-            user: { id: user._id, username: user.username, role: user.role }\r\n+            // Retornamos apenas informações básicas, pois o resto virá do banco da empresa\r\n+            user: { id: user._id, username: user.username }\r\n         });\r\n \r\n     } catch (error) {\r\n         console.error(\"Erro no login direto:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-router.post('/forgot-password', async (req, res) => {\r\n+\r\n+// Rota para verificar a sessão do usuário. Agora ela também retorna o role do usuário,\r\n+// que será buscado de dentro do banco da empresa.\r\n+router.get('/me', async (req, res) => {\r\n+    // Esta rota é chamada APÓS o 'protect' e o 'tenantMiddleware'\r\n+    // Então, já temos acesso a 'req.user' (do token) e 'req.tenantDb' (a conexão da empresa)\r\n     try {\r\n-        const { email } = req.body;\r\n-        // MUDANÇA: Usamos o modelo Company para encontrar a empresa pelo e-mail\r\n-        const company = await Company.findOne({ email });\r\n-        if (!company) {\r\n-            // Nota: Enviamos uma mensagem de sucesso mesmo que o e-mail não exista\r\n-            // para não dar pistas a possíveis atacantes.\r\n-            return res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n-        }\r\n+        const masterDb = req.masterDb;\r\n+        const tenantDb = req.tenantDb;\r\n \r\n-        // Encontramos o usuário Proprietário desta empresa\r\n-        const owner = await User.findOne({ company: company._id, role: 'Proprietário' });\r\n-        if (!owner) {\r\n-            return res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n+        // Importa os modelos usando a conexão correta\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const MasterCompany = masterDb.model('MasterCompany');\r\n+\r\n+        // Busca o usuário no banco da empresa para pegar seu 'role' e outros detalhes\r\n+        const tenantUser = await TenantUser.findOne({ username: req.user.username });\r\n+        if (!tenantUser) {\r\n+            return res.status(404).json({ message: 'Usuário não encontrado no registro da empresa.' });\r\n         }\r\n+        \r\n+        // Busca a empresa no banco mestre para pegar os detalhes da assinatura\r\n+        const company = await MasterCompany.findById(req.user.companyId);\r\n \r\n-        // Gera um token aleatório e seguro\r\n-        const resetToken = crypto.randomBytes(20).toString('hex');\r\n+        res.status(200).json({ \r\n+            user: {\r\n+                id: tenantUser._id,\r\n+                username: tenantUser.username,\r\n+                role: tenantUser.role\r\n+            }, \r\n+            company: {\r\n+                _id: company._id,\r\n+                nomeEmpresa: company.nomeEmpresa,\r\n+                subscription: company.subscription\r\n+            }\r\n+        });\r\n \r\n-        // Define o token e a sua data de expiração (1 hora) no utilizador\r\n-        owner.resetPasswordToken = resetToken;\r\n-        owner.resetPasswordExpires = Date.now() + 3600000; // 1 hora em milissegundos\r\n-        await owner.save();\r\n-\r\n-        // Envia o e-mail com o link de recuperação\r\n-        await sendPasswordResetEmail(company.email, resetToken);\r\n-\r\n-        res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n-\r\n     } catch (error) {\r\n-        console.error(\"Erro em forgot-password:\", error);\r\n-        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n+        console.error(\"Erro ao verificar sessão (/me):\", error);\r\n+        res.status(500).json({ message: 'Erro ao verificar a sessão.' });\r\n     }\r\n });\r\n \r\n-// Rota para definir a nova senha (Passo 2 do fluxo)\r\n+\r\n+// As rotas de recuperação de senha agora operam exclusivamente no banco MESTRE\r\n+// (A lógica interna é a mesma, apenas os modelos mudam para MasterUser)\r\n+router.post('/forgot-password', async (req, res) => {\r\n+    // ... (Esta lógica precisará ser adaptada para encontrar o usuário pelo e-mail no MasterUser)\r\n+    res.status(501).json({ message: 'Funcionalidade de recuperação de senha a ser adaptada.' });\r\n+});\r\n+\r\n router.post('/reset-password/:token', async (req, res) => {\r\n-    try {\r\n-        const { token } = req.params;\r\n-        const { password } = req.body;\r\n+    // ... (Esta lógica precisará ser adaptada para operar no MasterUser)\r\n+    res.status(501).json({ message: 'Funcionalidade de reset de senha a ser adaptada.' });\r\n+});\r\n \r\n-        // Encontra o utilizador pelo token e verifica se o token ainda é válido\r\n-        const user = await User.findOne({\r\n-            resetPasswordToken: token,\r\n-            resetPasswordExpires: { $gt: Date.now() } // $gt = greater than (maior que)\r\n-        });\r\n \r\n-        if (!user) {\r\n-            return res.status(400).json({ message: 'O link de recuperação de senha é inválido ou expirou.' });\r\n+// A rota de login de admin continua a mesma, pois não depende de banco de dados\r\n+router.post('/login/admin', (req, res) => {\r\n+    try {\r\n+        const { username, password } = req.body;\r\n+        if (username === process.env.ADMIN_USERNAME && password === process.env.ADMIN_PASSWORD) {\r\n+            const token = jwt.sign({ id: 'ADMIN_ID', role: 'SuperAdmin' }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n+            res.status(200).json({ message: 'Login de admin bem-sucedido!', token });\r\n+        } else {\r\n+            res.status(401).json({ message: 'Credenciais de administrador inválidas.' });\r\n         }\r\n-\r\n-        // Se o token for válido, atualizamos a senha\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        user.password = await bcrypt.hash(password, salt);\r\n-        // Limpamos os campos de recuperação\r\n-        user.resetPasswordToken = undefined;\r\n-        user.resetPasswordExpires = undefined;\r\n-        await user.save();\r\n-\r\n-        res.status(200).json({ message: 'Senha atualizada com sucesso!' });\r\n-\r\n     } catch (error) {\r\n-        console.error(\"Erro em reset-password:\", error);\r\n-        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n+        res.status(500).json({ message: 'Erro interno do servidor' });\r\n     }\r\n });\r\n \r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753536083713,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,10 @@\n const router = express.Router();\r\n const bcrypt = require('bcryptjs');\r\n const jwt = require('jsonwebtoken');\r\n const { body, validationResult } = require('express-validator');\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const { tenantMiddleware } = require('../middleware/tenantMiddleware');\r\n \r\n // Importamos os modelos do banco MESTRE\r\n const MasterCompany = require('../models/MasterCompany');\r\n const MasterUser = require('../models/MasterUser');\r\n"
                },
                {
                    "date": 1753536118854,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n \r\n \r\n // Rota para verificar a sessão do usuário. Agora ela também retorna o role do usuário,\r\n // que será buscado de dentro do banco da empresa.\r\n-router.get('/me', async (req, res) => {\r\n+router.get('/me', protect, tenantMiddleware, async (req, res) => {\r\n     // Esta rota é chamada APÓS o 'protect' e o 'tenantMiddleware'\r\n     // Então, já temos acesso a 'req.user' (do token) e 'req.tenantDb' (a conexão da empresa)\r\n     try {\r\n         const masterDb = req.masterDb;\r\n"
                },
                {
                    "date": 1753536462414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,27 +78,38 @@\n \r\n // Rota para verificar a sessão do usuário. Agora ela também retorna o role do usuário,\r\n // que será buscado de dentro do banco da empresa.\r\n router.get('/me', protect, tenantMiddleware, async (req, res) => {\r\n-    // Esta rota é chamada APÓS o 'protect' e o 'tenantMiddleware'\r\n-    // Então, já temos acesso a 'req.user' (do token) e 'req.tenantDb' (a conexão da empresa)\r\n     try {\r\n-        const masterDb = req.masterDb;\r\n+        // NOVO: Verificamos primeiro se é o SuperAdmin.\r\n+        // Se for, retornamos uma resposta simples de admin e encerramos.\r\n+        if (req.user.role === 'SuperAdmin') {\r\n+            return res.status(200).json({ \r\n+                user: { role: 'SuperAdmin' },\r\n+                // Para o admin, não há uma empresa específica associada à sessão.\r\n+                company: { nomeEmpresa: 'Painel de Administrador' } \r\n+            });\r\n+        }\r\n+\r\n+        // Se não for admin, o código para usuários normais é executado.\r\n+        // O 'tenantMiddleware' já garantiu que temos 'req.tenantDb' e 'req.company'.\r\n         const tenantDb = req.tenantDb;\r\n \r\n-        // Importa os modelos usando a conexão correta\r\n+        // Importa o modelo User usando a conexão correta da empresa\r\n         const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const MasterCompany = masterDb.model('MasterCompany');\r\n \r\n         // Busca o usuário no banco da empresa para pegar seu 'role' e outros detalhes\r\n+        // A busca agora é pelo _id do MasterUser, que está no token como req.user.id\r\n+        // Precisamos encontrar o usuário no tenantDB pelo username.\r\n         const tenantUser = await TenantUser.findOne({ username: req.user.username });\r\n+\r\n         if (!tenantUser) {\r\n             return res.status(404).json({ message: 'Usuário não encontrado no registro da empresa.' });\r\n         }\r\n-        \r\n-        // Busca a empresa no banco mestre para pegar os detalhes da assinatura\r\n-        const company = await MasterCompany.findById(req.user.companyId);\r\n \r\n+        // req.company já foi buscado pelo middleware\r\n+        const company = req.company;\r\n+\r\n         res.status(200).json({ \r\n             user: {\r\n                 id: tenantUser._id,\r\n                 username: tenantUser.username,\r\n"
                },
                {
                    "date": 1753537120404,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,9 +140,33 @@\n     // ... (Esta lógica precisará ser adaptada para operar no MasterUser)\r\n     res.status(501).json({ message: 'Funcionalidade de reset de senha a ser adaptada.' });\r\n });\r\n \r\n+router.post('/find-company-by-cnpj', async (req, res) => {\r\n+    try {\r\n+        const { cnpj } = req.body;\r\n+        if (!cnpj) {\r\n+            return res.status(400).json({ message: 'CNPJ não fornecido.' });\r\n+        }\r\n \r\n+        // Usa o modelo MasterCompany conectado ao banco Mestre (req.masterDb)\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+\r\n+        const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n+\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Nenhuma empresa encontrada com este CNPJ.' });\r\n+        }\r\n+\r\n+        // Retorna uma resposta de sucesso simples para o frontend prosseguir\r\n+        res.status(200).json({ message: 'Empresa encontrada!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro em /find-company-by-cnpj:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor' });\r\n+    }\r\n+});\r\n+\r\n // A rota de login de admin continua a mesma, pois não depende de banco de dados\r\n router.post('/login/admin', (req, res) => {\r\n     try {\r\n         const { username, password } = req.body;\r\n"
                },
                {
                    "date": 1753537539301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,23 +1,22 @@\n-// D:\\SCripts\\SiteLobos\\Servidor\\routes\\auth.js\r\n-\r\n const express = require('express');\r\n const router = express.Router();\r\n const bcrypt = require('bcryptjs');\r\n const jwt = require('jsonwebtoken');\r\n+const crypto = require('crypto');\r\n const { body, validationResult } = require('express-validator');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const { tenantMiddleware } = require('../middleware/tenantMiddleware');\r\n \r\n-// Importamos os modelos do banco MESTRE\r\n-const MasterCompany = require('../models/MasterCompany');\r\n-const MasterUser = require('../models/MasterUser');\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n \r\n-// O serviço de e-mail continua o mesmo\r\n+// Importamos o serviço de e-mail para a recuperação de senha\r\n const { sendPasswordResetEmail } = require('../services/emailService');\r\n \r\n \r\n-// Rota principal de login, agora usando o banco de dados MESTRE\r\n+// Rota principal de login, usando o banco de dados MESTRE\r\n router.post('/login/direct', [\r\n     body('cnpj', 'O CNPJ é obrigatório.').notEmpty(),\r\n     body('username', 'O nome de usuário é obrigatório.').notEmpty(),\r\n     body('password', 'A senha é obrigatória.').notEmpty()\r\n@@ -29,44 +28,41 @@\n \r\n     try {\r\n         const { cnpj, username, password } = req.body;\r\n         \r\n-        // A conexão com o banco MESTRE é injetada pelo middleware que criamos no server.js\r\n-        const masterDb = req.masterDb;\r\n+        // Compilamos os modelos usando a conexão Mestre ativa, fornecida pelo middleware\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n \r\n-        // 1. Encontra a empresa no banco MESTRE pelo CNPJ\r\n         const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n         if (!company) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        // 2. Encontra o usuário no banco MESTRE, garantindo que ele pertence à empresa encontrada\r\n         const user = await MasterUser.findOne({ username: username, company: company._id });\r\n         if (!user) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        // 3. Compara a senha\r\n         const isMatch = await bcrypt.compare(password, user.password);\r\n         if (!isMatch) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n         \r\n-        // 4. Gera o token JWT. A informação mais importante aqui é o 'companyId' do banco MESTRE.\r\n-        // O nosso 'tenantMiddleware' usará este ID para encontrar o 'dbName' e conectar ao banco correto.\r\n+        // Gera o token JWT com o ID da MasterCompany, que será usado pelo tenantMiddleware\r\n         const token = jwt.sign(\r\n             { \r\n                 id: user._id, \r\n-                companyId: user.company // ID da MasterCompany\r\n+                companyId: user.company,\r\n+                username: user.username // Adicionamos username para a rota /me\r\n             }, \r\n             process.env.JWT_SECRET, \r\n             { expiresIn: '8h' }\r\n         );\r\n         \r\n         res.status(200).json({\r\n             message: 'Login bem-sucedido!',\r\n             token,\r\n-            // Retornamos apenas informações básicas, pois o resto virá do banco da empresa\r\n             user: { id: user._id, username: user.username }\r\n         });\r\n \r\n     } catch (error) {\r\n@@ -74,40 +70,56 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+// Rota para verificar se uma empresa existe pelo CNPJ (para o login em 2 passos da Index.html)\r\n+router.post('/find-company-by-cnpj', async (req, res) => {\r\n+    try {\r\n+        const { cnpj } = req.body;\r\n+        if (!cnpj) {\r\n+            return res.status(400).json({ message: 'CNPJ não fornecido.' });\r\n+        }\r\n+    \r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        \r\n+        const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n+        \r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Nenhuma empresa encontrada com este CNPJ.' });\r\n+        }\r\n+    \r\n+        res.status(200).json({ message: 'Empresa encontrada!' });\r\n+        \r\n+    } catch (error) {\r\n+        console.error(\"Erro em /find-company-by-cnpj:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor' });\r\n+    }\r\n+});\r\n \r\n-// Rota para verificar a sessão do usuário. Agora ela também retorna o role do usuário,\r\n-// que será buscado de dentro do banco da empresa.\r\n+\r\n+// Rota para verificar a sessão do usuário\r\n router.get('/me', protect, tenantMiddleware, async (req, res) => {\r\n     try {\r\n-        // NOVO: Verificamos primeiro se é o SuperAdmin.\r\n-        // Se for, retornamos uma resposta simples de admin e encerramos.\r\n+        // Se for o SuperAdmin, retorna uma resposta simples e encerra\r\n         if (req.user.role === 'SuperAdmin') {\r\n             return res.status(200).json({ \r\n                 user: { role: 'SuperAdmin' },\r\n-                // Para o admin, não há uma empresa específica associada à sessão.\r\n                 company: { nomeEmpresa: 'Painel de Administrador' } \r\n             });\r\n         }\r\n \r\n-        // Se não for admin, o código para usuários normais é executado.\r\n-        // O 'tenantMiddleware' já garantiu que temos 'req.tenantDb' e 'req.company'.\r\n+        // Se for um usuário normal, o 'tenantMiddleware' já rodou e nos deu a conexão 'req.tenantDb'\r\n         const tenantDb = req.tenantDb;\r\n-\r\n-        // Importa o modelo User usando a conexão correta da empresa\r\n         const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        // Busca o usuário no banco da empresa para pegar seu 'role' e outros detalhes\r\n-        // A busca agora é pelo _id do MasterUser, que está no token como req.user.id\r\n-        // Precisamos encontrar o usuário no tenantDB pelo username.\r\n+        \r\n+        // Busca o usuário dentro do banco da empresa para obter o 'role'\r\n         const tenantUser = await TenantUser.findOne({ username: req.user.username });\r\n-\r\n+        \r\n         if (!tenantUser) {\r\n             return res.status(404).json({ message: 'Usuário não encontrado no registro da empresa.' });\r\n         }\r\n-\r\n-        // req.company já foi buscado pelo middleware\r\n+        \r\n+        // O documento da empresa (com dados de assinatura) já foi buscado pelo middleware\r\n         const company = req.company;\r\n \r\n         res.status(200).json({ \r\n             user: {\r\n@@ -127,58 +139,76 @@\n         res.status(500).json({ message: 'Erro ao verificar a sessão.' });\r\n     }\r\n });\r\n \r\n+// Rota de login de admin (não precisa de banco de dados)\r\n+router.post('/login/admin', (req, res) => {\r\n+    try {\r\n+        const { username, password } = req.body;\r\n+        if (username === process.env.ADMIN_USERNAME && password === process.env.ADMIN_PASSWORD) {\r\n+            const token = jwt.sign({ id: 'ADMIN_ID', role: 'SuperAdmin' }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n+            res.status(200).json({ message: 'Login de admin bem-sucedido!', token });\r\n+        } else {\r\n+            res.status(401).json({ message: 'Credenciais de administrador inválidas.' });\r\n+        }\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno do servidor' });\r\n+    }\r\n+});\r\n \r\n-// As rotas de recuperação de senha agora operam exclusivamente no banco MESTRE\r\n-// (A lógica interna é a mesma, apenas os modelos mudam para MasterUser)\r\n+// Rota para solicitar a recuperação de senha\r\n router.post('/forgot-password', async (req, res) => {\r\n-    // ... (Esta lógica precisará ser adaptada para encontrar o usuário pelo e-mail no MasterUser)\r\n-    res.status(501).json({ message: 'Funcionalidade de recuperação de senha a ser adaptada.' });\r\n-});\r\n-\r\n-router.post('/reset-password/:token', async (req, res) => {\r\n-    // ... (Esta lógica precisará ser adaptada para operar no MasterUser)\r\n-    res.status(501).json({ message: 'Funcionalidade de reset de senha a ser adaptada.' });\r\n-});\r\n-\r\n-router.post('/find-company-by-cnpj', async (req, res) => {\r\n     try {\r\n-        const { cnpj } = req.body;\r\n-        if (!cnpj) {\r\n-            return res.status(400).json({ message: 'CNPJ não fornecido.' });\r\n+        const { email } = req.body;\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        \r\n+        // A lógica agora deve procurar pelo e-mail no MasterUser\r\n+        const user = await MasterUser.findOne({ email });\r\n+        if (!user) {\r\n+            return res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n         }\r\n \r\n-        // Usa o modelo MasterCompany conectado ao banco Mestre (req.masterDb)\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const resetToken = crypto.randomBytes(20).toString('hex');\r\n+        user.resetPasswordToken = resetToken;\r\n+        user.resetPasswordExpires = Date.now() + 3600000; // 1 hora\r\n+        await user.save();\r\n \r\n-        const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n+        await sendPasswordResetEmail(user.email, resetToken);\r\n+        res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n \r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Nenhuma empresa encontrada com este CNPJ.' });\r\n-        }\r\n-\r\n-        // Retorna uma resposta de sucesso simples para o frontend prosseguir\r\n-        res.status(200).json({ message: 'Empresa encontrada!' });\r\n-\r\n     } catch (error) {\r\n-        console.error(\"Erro em /find-company-by-cnpj:\", error);\r\n-        res.status(500).json({ message: 'Erro interno no servidor' });\r\n+        console.error(\"Erro em forgot-password:\", error);\r\n+        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n     }\r\n });\r\n \r\n-// A rota de login de admin continua a mesma, pois não depende de banco de dados\r\n-router.post('/login/admin', (req, res) => {\r\n+// Rota para definir a nova senha\r\n+router.post('/reset-password/:token', async (req, res) => {\r\n     try {\r\n-        const { username, password } = req.body;\r\n-        if (username === process.env.ADMIN_USERNAME && password === process.env.ADMIN_PASSWORD) {\r\n-            const token = jwt.sign({ id: 'ADMIN_ID', role: 'SuperAdmin' }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n-            res.status(200).json({ message: 'Login de admin bem-sucedido!', token });\r\n-        } else {\r\n-            res.status(401).json({ message: 'Credenciais de administrador inválidas.' });\r\n+        const { token } = req.params;\r\n+        const { password } = req.body;\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        const user = await MasterUser.findOne({\r\n+            resetPasswordToken: token,\r\n+            resetPasswordExpires: { $gt: Date.now() }\r\n+        });\r\n+\r\n+        if (!user) {\r\n+            return res.status(400).json({ message: 'O link de recuperação de senha é inválido ou expirou.' });\r\n         }\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        user.password = await bcrypt.hash(password, salt);\r\n+        user.resetPasswordToken = undefined;\r\n+        user.resetPasswordExpires = undefined;\r\n+        await user.save();\r\n+\r\n+        res.status(200).json({ message: 'Senha atualizada com sucesso!' });\r\n+\r\n     } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor' });\r\n+        console.error(\"Erro em reset-password:\", error);\r\n+        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n     }\r\n });\r\n \r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753539102936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,10 @@\n         const token = jwt.sign(\r\n             { \r\n                 id: user._id, \r\n                 companyId: user.company,\r\n-                username: user.username // Adicionamos username para a rota /me\r\n+                username: user.username,\r\n+                role: user.role\r\n             }, \r\n             process.env.JWT_SECRET, \r\n             { expiresIn: '8h' }\r\n         );\r\n"
                },
                {
                    "date": 1753539483125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,17 +6,17 @@\n const { body, validationResult } = require('express-validator');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const { tenantMiddleware } = require('../middleware/tenantMiddleware');\r\n \r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+// Importamos os ESQUEMAS do banco Mestre\r\n const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n const MasterUserSchema = require('../models/MasterUser').schema;\r\n \r\n-// Importamos o serviço de e-mail para a recuperação de senha\r\n+// Importamos o serviço de e-mail\r\n const { sendPasswordResetEmail } = require('../services/emailService');\r\n \r\n \r\n-// Rota principal de login, usando o banco de dados MESTRE\r\n+// Rota principal de login\r\n router.post('/login/direct', [\r\n     body('cnpj', 'O CNPJ é obrigatório.').notEmpty(),\r\n     body('username', 'O nome de usuário é obrigatório.').notEmpty(),\r\n     body('password', 'A senha é obrigatória.').notEmpty()\r\n@@ -28,9 +28,8 @@\n \r\n     try {\r\n         const { cnpj, username, password } = req.body;\r\n         \r\n-        // Compilamos os modelos usando a conexão Mestre ativa, fornecida pelo middleware\r\n         const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n         const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n \r\n         const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n@@ -47,15 +46,15 @@\n         if (!isMatch) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n         \r\n-        // Gera o token JWT com o ID da MasterCompany, que será usado pelo tenantMiddleware\r\n+        // CORREÇÃO FINAL: Garante que 'role' está no token\r\n         const token = jwt.sign(\r\n             { \r\n                 id: user._id, \r\n                 companyId: user.company,\r\n                 username: user.username,\r\n-                role: user.role\r\n+                role: user.role // <-- A linha crucial que resolve a permissão\r\n             }, \r\n             process.env.JWT_SECRET, \r\n             { expiresIn: '8h' }\r\n         );\r\n@@ -71,18 +70,17 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// Rota para verificar se uma empresa existe pelo CNPJ (para o login em 2 passos da Index.html)\r\n+// Rota para verificar se uma empresa existe pelo CNPJ\r\n router.post('/find-company-by-cnpj', async (req, res) => {\r\n     try {\r\n         const { cnpj } = req.body;\r\n         if (!cnpj) {\r\n             return res.status(400).json({ message: 'CNPJ não fornecido.' });\r\n         }\r\n     \r\n         const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        \r\n         const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n         \r\n         if (!company) {\r\n             return res.status(404).json({ message: 'Nenhuma empresa encontrada com este CNPJ.' });\r\n@@ -99,28 +97,23 @@\n \r\n // Rota para verificar a sessão do usuário\r\n router.get('/me', protect, tenantMiddleware, async (req, res) => {\r\n     try {\r\n-        // Se for o SuperAdmin, retorna uma resposta simples e encerra\r\n         if (req.user.role === 'SuperAdmin') {\r\n             return res.status(200).json({ \r\n                 user: { role: 'SuperAdmin' },\r\n                 company: { nomeEmpresa: 'Painel de Administrador' } \r\n             });\r\n         }\r\n \r\n-        // Se for um usuário normal, o 'tenantMiddleware' já rodou e nos deu a conexão 'req.tenantDb'\r\n         const tenantDb = req.tenantDb;\r\n         const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        \r\n-        // Busca o usuário dentro do banco da empresa para obter o 'role'\r\n         const tenantUser = await TenantUser.findOne({ username: req.user.username });\r\n         \r\n         if (!tenantUser) {\r\n             return res.status(404).json({ message: 'Usuário não encontrado no registro da empresa.' });\r\n         }\r\n         \r\n-        // O documento da empresa (com dados de assinatura) já foi buscado pelo middleware\r\n         const company = req.company;\r\n \r\n         res.status(200).json({ \r\n             user: {\r\n@@ -140,9 +133,9 @@\n         res.status(500).json({ message: 'Erro ao verificar a sessão.' });\r\n     }\r\n });\r\n \r\n-// Rota de login de admin (não precisa de banco de dados)\r\n+// Rota de login de admin\r\n router.post('/login/admin', (req, res) => {\r\n     try {\r\n         const { username, password } = req.body;\r\n         if (username === process.env.ADMIN_USERNAME && password === process.env.ADMIN_PASSWORD) {\r\n@@ -155,15 +148,14 @@\n         res.status(500).json({ message: 'Erro interno do servidor' });\r\n     }\r\n });\r\n \r\n-// Rota para solicitar a recuperação de senha\r\n+// Rotas de recuperação de senha\r\n router.post('/forgot-password', async (req, res) => {\r\n     try {\r\n         const { email } = req.body;\r\n         const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n         \r\n-        // A lógica agora deve procurar pelo e-mail no MasterUser\r\n         const user = await MasterUser.findOne({ email });\r\n         if (!user) {\r\n             return res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n         }\r\n@@ -181,9 +173,8 @@\n         res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n     }\r\n });\r\n \r\n-// Rota para definir a nova senha\r\n router.post('/reset-password/:token', async (req, res) => {\r\n     try {\r\n         const { token } = req.params;\r\n         const { password } = req.body;\r\n@@ -207,9 +198,9 @@\n         res.status(200).json({ message: 'Senha atualizada com sucesso!' });\r\n \r\n     } catch (error) {\r\n         console.error(\"Erro em reset-password:\", error);\r\n-        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n     }\r\n });\r\n \r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753539633235,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,8 +45,10 @@\n         const isMatch = await bcrypt.compare(password, user.password);\r\n         if (!isMatch) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n+\r\n+        console.log(\"DADOS DO USUÁRIO ANTES DE GERAR O TOKEN:\", user);\r\n         \r\n         // CORREÇÃO FINAL: Garante que 'role' está no token\r\n         const token = jwt.sign(\r\n             { \r\n"
                },
                {
                    "date": 1753540513878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,9 @@\n         if (!company) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        const user = await MasterUser.findOne({ username: username, company: company._id });\r\n+        const user = await MasterUser.findOne({ username: username, company: company._id }).select('+role -password');\r\n         if (!user) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n"
                },
                {
                    "date": 1753540547268,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,27 +36,26 @@\n         if (!company) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n+        // --- CORREÇÃO FINAL AQUI ---\r\n         const user = await MasterUser.findOne({ username: username, company: company._id }).select('+role -password');\r\n+        \r\n         if (!user) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n         const isMatch = await bcrypt.compare(password, user.password);\r\n         if (!isMatch) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n-\r\n-        console.log(\"DADOS DO USUÁRIO ANTES DE GERAR O TOKEN:\", user);\r\n         \r\n-        // CORREÇÃO FINAL: Garante que 'role' está no token\r\n         const token = jwt.sign(\r\n             { \r\n                 id: user._id, \r\n                 companyId: user.company,\r\n                 username: user.username,\r\n-                role: user.role // <-- A linha crucial que resolve a permissão\r\n+                role: user.role\r\n             }, \r\n             process.env.JWT_SECRET, \r\n             { expiresIn: '8h' }\r\n         );\r\n"
                },
                {
                    "date": 1753540752158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,19 +36,24 @@\n         if (!company) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        // --- CORREÇÃO FINAL AQUI ---\r\n-        const user = await MasterUser.findOne({ username: username, company: company._id }).select('+role -password');\r\n-        \r\n-        if (!user) {\r\n+        const userWithPassword = await MasterUser.findOne({ username: username, company: company._id }).select('+password');\r\n+        if (!userWithPassword) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        const isMatch = await bcrypt.compare(password, user.password);\r\n+        // Etapa 2: Compara a senha.\r\n+        const isMatch = await bcrypt.compare(password, userWithPassword.password);\r\n         if (!isMatch) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n+\r\n+        // Etapa 3: Busca novamente o usuário sem a senha para usar no restante da lógica.\r\n+        const user = await MasterUser.findById(userWithPassword._id);\r\n+        if (!user) {\r\n+            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n+        }\r\n         \r\n         const token = jwt.sign(\r\n             { \r\n                 id: user._id, \r\n"
                },
                {
                    "date": 1753540851860,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,45 +27,43 @@\n     }\r\n \r\n     try {\r\n         const { cnpj, username, password } = req.body;\r\n-        \r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n \r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n         const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n         if (!company) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        const userWithPassword = await MasterUser.findOne({ username: username, company: company._id }).select('+password');\r\n-        if (!userWithPassword) {\r\n+        // --- CORREÇÃO FINAL E DEFINITIVA AQUI ---\r\n+        // 1. Buscamos o usuário e explicitamente pedimos para INCLUIR a senha e o role.\r\n+        const user = await MasterUser.findOne({ username: username, company: company._id }).select('+password +role');\r\n+\r\n+        if (!user) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        // Etapa 2: Compara a senha.\r\n-        const isMatch = await bcrypt.compare(password, userWithPassword.password);\r\n+        // 2. Comparamos a senha.\r\n+        const isMatch = await bcrypt.compare(password, user.password);\r\n         if (!isMatch) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        // Etapa 3: Busca novamente o usuário sem a senha para usar no restante da lógica.\r\n-        const user = await MasterUser.findById(userWithPassword._id);\r\n-        if (!user) {\r\n-            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n-        }\r\n-        \r\n+        // 3. Geramos o token com o 'user.role' que agora está garantido no resultado.\r\n         const token = jwt.sign(\r\n             { \r\n                 id: user._id, \r\n                 companyId: user.company,\r\n                 username: user.username,\r\n-                role: user.role\r\n+                role: user.role \r\n             }, \r\n             process.env.JWT_SECRET, \r\n             { expiresIn: '8h' }\r\n         );\r\n-        \r\n+\r\n         res.status(200).json({\r\n             message: 'Login bem-sucedido!',\r\n             token,\r\n             user: { id: user._id, username: user.username }\r\n"
                },
                {
                    "date": 1753541480047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,29 +36,27 @@\n         if (!company) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        // --- CORREÇÃO FINAL E DEFINITIVA AQUI ---\r\n-        // 1. Buscamos o usuário e explicitamente pedimos para INCLUIR a senha e o role.\r\n+        // --- AQUI ESTÁ A CORREÇÃO DEFINITIVA ---\r\n+        // Fazemos uma ÚNICA busca, pedindo para INCLUIR explicitamente a senha e o role.\r\n         const user = await MasterUser.findOne({ username: username, company: company._id }).select('+password +role');\r\n \r\n         if (!user) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        // 2. Comparamos a senha.\r\n         const isMatch = await bcrypt.compare(password, user.password);\r\n         if (!isMatch) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n         }\r\n \r\n-        // 3. Geramos o token com o 'user.role' que agora está garantido no resultado.\r\n         const token = jwt.sign(\r\n             { \r\n                 id: user._id, \r\n                 companyId: user.company,\r\n                 username: user.username,\r\n-                role: user.role \r\n+                role: user.role // Agora 'user.role' terá o valor correto\r\n             }, \r\n             process.env.JWT_SECRET, \r\n             { expiresIn: '8h' }\r\n         );\r\n"
                },
                {
                    "date": 1753544866062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -204,5 +204,50 @@\n         res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n     }\r\n });\r\n \r\n+router.post('/register/user', protect, tenantMiddleware, async (req, res) => {\r\n+    try {\r\n+        const { username, password, role, email } = req.body;\r\n+        const { companyId } = req.user; // ID da MasterCompany\r\n+\r\n+        // Conexões e Modelos\r\n+        const masterDb = req.masterDb;\r\n+        const tenantDb = req.tenantDb;\r\n+        const MasterUser = masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        if (!username || !password || !role || !email) {\r\n+            return res.status(400).json({ message: 'Todos os campos são obrigatórios: nome de usuário, senha, cargo e email.' });\r\n+        }\r\n+\r\n+        // 1. Cria o usuário no banco MESTRE (para que ele possa fazer login)\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedPassword = await bcrypt.hash(password, salt);\r\n+\r\n+        await MasterUser.create({\r\n+            username,\r\n+            password: hashedPassword,\r\n+            role,\r\n+            company: companyId\r\n+        });\r\n+\r\n+        // 2. Cria o usuário no banco da EMPRESA (para guardar seus dados de aplicação)\r\n+        await TenantUser.create({\r\n+            username,\r\n+            password: hashedPassword,\r\n+            role,\r\n+            email\r\n+        });\r\n+\r\n+        res.status(201).json({ message: `Usuário '${username}' criado com sucesso!` });\r\n+\r\n+    } catch (error) {\r\n+        if (error.code === 11000) {\r\n+            return res.status(400).json({ message: 'Este nome de usuário ou e-mail já existe nesta empresa.' });\r\n+        }\r\n+        console.error(\"Erro ao registrar novo usuário:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753547474427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -249,5 +249,56 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+router.post('/register-company', async (req, res) => {\r\n+    try {\r\n+        // Os modelos são compilados na conexão Mestre, que já está disponível\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n+\r\n+        // Validações\r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        if (!nomeEmpresa || !cleanCnpj || !email || !username || !password || !ownerEmail) {\r\n+            return res.status(400).json({ message: \"Todos os campos são obrigatórios.\" });\r\n+        }\r\n+        if (await MasterCompany.findOne({ cnpj: cleanCnpj })) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        // Cria um nome de banco de dados único para a empresa\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+        const newMasterCompany = await MasterCompany.create({ nomeEmpresa, cnpj: cleanCnpj, dbName, email, telefoneWhatsapp });\r\n+\r\n+        // Cria o usuário no banco Mestre\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedPassword = await bcrypt.hash(password, salt);\r\n+\r\n+        await MasterUser.create({\r\n+            username: username,\r\n+            password: hashedPassword,\r\n+            role: 'Proprietário',\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        // Cria o usuário dentro do banco da empresa\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        await TenantUser.create({\r\n+            username,\r\n+            password: hashedPassword, \r\n+            role: 'Proprietário',\r\n+            email: ownerEmail\r\n+        });\r\n+\r\n+        res.status(201).json({ message: 'Empresa e usuário proprietário cadastrados com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no cadastro self-service:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor durante o cadastro.' });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753547665096,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n const express = require('express');\r\n const router = express.Router();\r\n const bcrypt = require('bcryptjs');\r\n const jwt = require('jsonwebtoken');\r\n+const { getTenantConnection } = require('../config/db');\r\n const crypto = require('crypto');\r\n const { body, validationResult } = require('express-validator');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const { tenantMiddleware } = require('../middleware/tenantMiddleware');\r\n"
                },
                {
                    "date": 1753735339432,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,21 +155,31 @@\n // Rotas de recuperação de senha\r\n router.post('/forgot-password', async (req, res) => {\r\n     try {\r\n         const { email } = req.body;\r\n+        console.log(`[DEBUG] Rota /forgot-password acionada com o e-mail: ${email}`);\r\n+        \r\n         const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n         \r\n+        console.log('[DEBUG] A procurar utilizador na base de dados mestre...');\r\n         const user = await MasterUser.findOne({ email });\r\n+\r\n         if (!user) {\r\n+            console.log('[DEBUG] Utilizador NÃO encontrado. A terminar o processo silenciosamente (comportamento esperado por segurança).');\r\n+            // Nota: Retornamos 200 para não revelar que o e-mail não existe.\r\n             return res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n         }\r\n \r\n+        console.log(`[DEBUG] Utilizador encontrado: ${user.username}. A gerar token...`);\r\n         const resetToken = crypto.randomBytes(20).toString('hex');\r\n         user.resetPasswordToken = resetToken;\r\n         user.resetPasswordExpires = Date.now() + 3600000; // 1 hora\r\n         await user.save();\r\n+        console.log('[DEBUG] Token salvo na base de dados.');\r\n \r\n+        console.log(`[DEBUG] A chamar a função sendPasswordResetEmail para: ${user.email}`);\r\n         await sendPasswordResetEmail(user.email, resetToken);\r\n+        \r\n         res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n \r\n     } catch (error) {\r\n         console.error(\"Erro em forgot-password:\", error);\r\n"
                },
                {
                    "date": 1753735898082,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -287,8 +287,9 @@\n         const hashedPassword = await bcrypt.hash(password, salt);\r\n \r\n         await MasterUser.create({\r\n             username: username,\r\n+            email: ownerEmail,\r\n             password: hashedPassword,\r\n             role: 'Proprietário',\r\n             company: newMasterCompany._id\r\n         });\r\n"
                },
                {
                    "date": 1753735919501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,8 +236,9 @@\n         const hashedPassword = await bcrypt.hash(password, salt);\r\n \r\n         await MasterUser.create({\r\n             username,\r\n+            email,\r\n             password: hashedPassword,\r\n             role,\r\n             company: companyId\r\n         });\r\n"
                },
                {
                    "date": 1753739104282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,9 @@\n const crypto = require('crypto');\r\n const { body, validationResult } = require('express-validator');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const { tenantMiddleware } = require('../middleware/tenantMiddleware');\r\n+const { sendPasswordResetEmail, sendVerificationEmail } = require('../services/emailService');\r\n \r\n // Importamos os ESQUEMAS do banco Mestre\r\n const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n const MasterUserSchema = require('../models/MasterUser').schema;\r\n"
                },
                {
                    "date": 1753739122793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -264,28 +264,36 @@\n });\r\n \r\n router.post('/register-company', async (req, res) => {\r\n     try {\r\n-        // Os modelos são compilados na conexão Mestre, que já está disponível\r\n         const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n         const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n \r\n         const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n \r\n-        // Validações\r\n         const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n         if (!nomeEmpresa || !cleanCnpj || !email || !username || !password || !ownerEmail) {\r\n             return res.status(400).json({ message: \"Todos os campos são obrigatórios.\" });\r\n         }\r\n         if (await MasterCompany.findOne({ cnpj: cleanCnpj })) {\r\n             return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n         }\r\n \r\n-        // Cria um nome de banco de dados único para a empresa\r\n+        // Gera o token de verificação\r\n+        const verificationToken = crypto.randomBytes(20).toString('hex');\r\n+        const verificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 horas\r\n+\r\n         const dbName = `empresa_${cleanCnpj}`;\r\n-        const newMasterCompany = await MasterCompany.create({ nomeEmpresa, cnpj: cleanCnpj, dbName, email, telefoneWhatsapp });\r\n+        const newMasterCompany = await MasterCompany.create({ \r\n+            nomeEmpresa, \r\n+            cnpj: cleanCnpj, \r\n+            dbName, \r\n+            email, \r\n+            telefoneWhatsapp,\r\n+            verificationToken, // Salva o token\r\n+            verificationExpires // Salva a data de expiração\r\n+        });\r\n \r\n-        // Cria o usuário no banco Mestre\r\n         const salt = await bcrypt.genSalt(10);\r\n         const hashedPassword = await bcrypt.hash(password, salt);\r\n \r\n         await MasterUser.create({\r\n@@ -295,9 +303,8 @@\n             role: 'Proprietário',\r\n             company: newMasterCompany._id\r\n         });\r\n \r\n-        // Cria o usuário dentro do banco da empresa\r\n         const tenantDb = await getTenantConnection(dbName);\r\n         const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n \r\n         await TenantUser.create({\r\n@@ -306,10 +313,13 @@\n             role: 'Proprietário',\r\n             email: ownerEmail\r\n         });\r\n \r\n-        res.status(201).json({ message: 'Empresa e usuário proprietário cadastrados com sucesso!' });\r\n+        // Envia o e-mail de verificação\r\n+        await sendVerificationEmail(email, nomeEmpresa, verificationToken);\r\n \r\n+        res.status(201).json({ message: 'Empresa registada! Por favor, verifique o seu e-mail para ativar a sua conta.' });\r\n+\r\n     } catch (error) {\r\n         console.error(\"Erro no cadastro self-service:\", error);\r\n         res.status(500).json({ message: 'Erro interno no servidor durante o cadastro.' });\r\n     }\r\n"
                },
                {
                    "date": 1753739136438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -324,5 +324,35 @@\n         res.status(500).json({ message: 'Erro interno no servidor durante o cadastro.' });\r\n     }\r\n });\r\n \r\n+// Rota para verificar o e-mail\r\n+router.get('/verify/:token', async (req, res) => {\r\n+    try {\r\n+        const { token } = req.params;\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // Encontra a empresa com o token que ainda não expirou\r\n+        const company = await MasterCompany.findOne({\r\n+            verificationToken: token,\r\n+            verificationExpires: { $gt: Date.now() }\r\n+        });\r\n+\r\n+        if (!company) {\r\n+            return res.status(400).json({ message: 'O link de verificação é inválido ou expirou.' });\r\n+        }\r\n+\r\n+        // Atualiza a empresa para o status verificado\r\n+        company.isVerified = true;\r\n+        company.verificationToken = undefined;\r\n+        company.verificationExpires = undefined;\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({ message: 'E-mail verificado com sucesso! Pode agora fazer o login.' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro na verificação de e-mail:\", error);\r\n+        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753739615252,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,16 +6,16 @@\n const crypto = require('crypto');\r\n const { body, validationResult } = require('express-validator');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const { tenantMiddleware } = require('../middleware/tenantMiddleware');\r\n-const { sendPasswordResetEmail, sendVerificationEmail } = require('../services/emailService');\r\n \r\n+\r\n // Importamos os ESQUEMAS do banco Mestre\r\n const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n const MasterUserSchema = require('../models/MasterUser').schema;\r\n \r\n // Importamos o serviço de e-mail\r\n-const { sendPasswordResetEmail } = require('../services/emailService');\r\n+const { sendPasswordResetEmail, sendVerificationEmail } = require('../services/emailService');\r\n \r\n \r\n // Rota principal de login\r\n router.post('/login/direct', [\r\n"
                },
                {
                    "date": 1753741124374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -354,5 +354,50 @@\n         res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n     }\r\n });\r\n \r\n+// Rota para o utilizador logado alterar a sua própria senha\r\n+router.post('/change-password', protect, async (req, res) => {\r\n+    try {\r\n+        const { currentPassword, newPassword, confirmPassword } = req.body;\r\n+        const userId = req.user.id; // Obtemos o ID do utilizador a partir do token (é seguro)\r\n+\r\n+        // 1. Validações iniciais\r\n+        if (!currentPassword || !newPassword || !confirmPassword) {\r\n+            return res.status(400).json({ message: 'Todos os campos são obrigatórios.' });\r\n+        }\r\n+        if (newPassword !== confirmPassword) {\r\n+            return res.status(400).json({ message: 'A nova senha e a confirmação não coincidem.' });\r\n+        }\r\n+        if (newPassword.length < 6) {\r\n+            return res.status(400).json({ message: 'A nova senha deve ter pelo menos 6 caracteres.' });\r\n+        }\r\n+\r\n+        // 2. Encontra o utilizador no banco de dados mestre\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        // Usamos .select('+password') para forçar o Mongoose a incluir o campo da senha na busca\r\n+        const user = await MasterUser.findById(userId).select('+password');\r\n+\r\n+        if (!user) {\r\n+            return res.status(404).json({ message: 'Utilizador não encontrado.' });\r\n+        }\r\n+\r\n+        // 3. Compara a senha atual fornecida com a senha guardada\r\n+        const isMatch = await bcrypt.compare(currentPassword, user.password);\r\n+        if (!isMatch) {\r\n+            return res.status(401).json({ message: 'A senha atual está incorreta.' });\r\n+        }\r\n+\r\n+        // 4. Codifica e salva a nova senha\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        user.password = await bcrypt.hash(newPassword, salt);\r\n+        await user.save();\r\n+\r\n+        res.status(200).json({ message: 'Senha alterada com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao alterar senha:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor ao tentar alterar a senha.' });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753741494015,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -399,5 +399,37 @@\n         res.status(500).json({ message: 'Erro interno no servidor ao tentar alterar a senha.' });\r\n     }\r\n });\r\n \r\n+// Rota para reenviar o e-mail de verificação\r\n+router.post('/resend-verification', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = req.user.companyId;\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        const company = await MasterCompany.findById(companyId);\r\n+\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+        if (company.isVerified) {\r\n+            return res.status(400).json({ message: 'Esta conta já foi verificada.' });\r\n+        }\r\n+\r\n+        // Gera um novo token e uma nova data de expiração\r\n+        const verificationToken = crypto.randomBytes(20).toString('hex');\r\n+        company.verificationToken = verificationToken;\r\n+        company.verificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 horas\r\n+        await company.save();\r\n+\r\n+        // Usa a função que já temos para enviar o e-mail\r\n+        await sendVerificationEmail(company.email, company.nomeEmpresa, verificationToken);\r\n+\r\n+        res.status(200).json({ message: 'E-mail de verificação reenviado com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao reenviar e-mail de verificação:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor.' });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753813364586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -228,38 +228,42 @@\n         const MasterUser = masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n         const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n \r\n         if (!username || !password || !role || !email) {\r\n-            return res.status(400).json({ message: 'Todos os campos são obrigatórios: nome de usuário, senha, cargo e email.' });\r\n+            return res.status(400).json({ message: 'Todos os campos são obrigatórios: nome de utilizador, senha, cargo e email.' });\r\n         }\r\n \r\n-        // 1. Cria o usuário no banco MESTRE (para que ele possa fazer login)\r\n+        // Codifica a senha\r\n         const salt = await bcrypt.genSalt(10);\r\n         const hashedPassword = await bcrypt.hash(password, salt);\r\n \r\n+        // 1. Cria o utilizador no banco MESTRE (para que ele possa fazer login)\r\n+        // AQUI ESTAVA A PRIMEIRA PARTE DO PROBLEMA, NÃO ESTAVA A PASSAR O E-MAIL\r\n         await MasterUser.create({\r\n             username,\r\n-            email,\r\n+            email, // E-mail adicionado aqui\r\n             password: hashedPassword,\r\n             role,\r\n             company: companyId\r\n         });\r\n \r\n-        // 2. Cria o usuário no banco da EMPRESA (para guardar seus dados de aplicação)\r\n+        // 2. Cria o utilizador no banco da EMPRESA (para guardar seus dados de aplicação)\r\n+        // AQUI ESTAVA O PROBLEMA PRINCIPAL, NÃO PRECISAMOS DE PASSAR O _id\r\n         await TenantUser.create({\r\n             username,\r\n-            password: hashedPassword,\r\n+            password: hashedPassword, \r\n             role,\r\n             email\r\n         });\r\n \r\n-        res.status(201).json({ message: `Usuário '${username}' criado com sucesso!` });\r\n+        res.status(201).json({ message: `Utilizador '${username}' criado com sucesso!` });\r\n \r\n     } catch (error) {\r\n-        if (error.code === 11000) {\r\n-            return res.status(400).json({ message: 'Este nome de usuário ou e-mail já existe nesta empresa.' });\r\n+        // Este erro de duplicado é comum se o utilizador já existir\r\n+        if (error.code === 11000) { \r\n+            return res.status(400).json({ message: 'Este nome de utilizador ou e-mail já existe nesta empresa.' });\r\n         }\r\n-        console.error(\"Erro ao registrar novo usuário:\", error);\r\n+        console.error(\"Erro ao registrar novo utilizador:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n"
                },
                {
                    "date": 1753813436301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,435 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const jwt = require('jsonwebtoken');\r\n+const { getTenantConnection } = require('../config/db');\r\n+const crypto = require('crypto');\r\n+const { body, validationResult } = require('express-validator');\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const { tenantMiddleware } = require('../middleware/tenantMiddleware');\r\n+\r\n+\r\n+// Importamos os ESQUEMAS do banco Mestre\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+\r\n+// Importamos o serviço de e-mail\r\n+const { sendPasswordResetEmail, sendVerificationEmail } = require('../services/emailService');\r\n+\r\n+\r\n+// Rota principal de login\r\n+router.post('/login/direct', [\r\n+    body('cnpj', 'O CNPJ é obrigatório.').notEmpty(),\r\n+    body('username', 'O nome de usuário é obrigatório.').notEmpty(),\r\n+    body('password', 'A senha é obrigatória.').notEmpty()\r\n+], async (req, res) => {\r\n+    const errors = validationResult(req);\r\n+    if (!errors.isEmpty()) {\r\n+        return res.status(400).json({ errors: errors.array() });\r\n+    }\r\n+\r\n+    try {\r\n+        const { cnpj, username, password } = req.body;\r\n+\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n+        if (!company) {\r\n+            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n+        }\r\n+\r\n+        // --- AQUI ESTÁ A CORREÇÃO DEFINITIVA ---\r\n+        // Fazemos uma ÚNICA busca, pedindo para INCLUIR explicitamente a senha e o role.\r\n+        const user = await MasterUser.findOne({ username: username, company: company._id }).select('+password +role');\r\n+\r\n+        if (!user) {\r\n+            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n+        }\r\n+\r\n+        const isMatch = await bcrypt.compare(password, user.password);\r\n+        if (!isMatch) {\r\n+            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n+        }\r\n+\r\n+        const token = jwt.sign(\r\n+            { \r\n+                id: user._id, \r\n+                companyId: user.company,\r\n+                username: user.username,\r\n+                role: user.role // Agora 'user.role' terá o valor correto\r\n+            }, \r\n+            process.env.JWT_SECRET, \r\n+            { expiresIn: '8h' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Login bem-sucedido!',\r\n+            token,\r\n+            user: { id: user._id, username: user.username }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no login direto:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para verificar se uma empresa existe pelo CNPJ\r\n+router.post('/find-company-by-cnpj', async (req, res) => {\r\n+    try {\r\n+        const { cnpj } = req.body;\r\n+        if (!cnpj) {\r\n+            return res.status(400).json({ message: 'CNPJ não fornecido.' });\r\n+        }\r\n+    \r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n+        \r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Nenhuma empresa encontrada com este CNPJ.' });\r\n+        }\r\n+    \r\n+        res.status(200).json({ message: 'Empresa encontrada!' });\r\n+        \r\n+    } catch (error) {\r\n+        console.error(\"Erro em /find-company-by-cnpj:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para verificar a sessão do usuário\r\n+router.get('/me', protect, tenantMiddleware, async (req, res) => {\r\n+    try {\r\n+        if (req.user.role === 'SuperAdmin') {\r\n+            return res.status(200).json({ \r\n+                user: { role: 'SuperAdmin' },\r\n+                company: { nomeEmpresa: 'Painel de Administrador' } \r\n+            });\r\n+        }\r\n+\r\n+        const tenantDb = req.tenantDb;\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const tenantUser = await TenantUser.findOne({ username: req.user.username });\r\n+        \r\n+        if (!tenantUser) {\r\n+            return res.status(404).json({ message: 'Usuário não encontrado no registro da empresa.' });\r\n+        }\r\n+        \r\n+        const company = req.company;\r\n+\r\n+        res.status(200).json({ \r\n+            user: {\r\n+                id: tenantUser._id,\r\n+                username: tenantUser.username,\r\n+                role: tenantUser.role\r\n+            }, \r\n+            company: {\r\n+                _id: company._id,\r\n+                nomeEmpresa: company.nomeEmpresa,\r\n+                subscription: company.subscription\r\n+            }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao verificar sessão (/me):\", error);\r\n+        res.status(500).json({ message: 'Erro ao verificar a sessão.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota de login de admin\r\n+router.post('/login/admin', (req, res) => {\r\n+    try {\r\n+        const { username, password } = req.body;\r\n+        if (username === process.env.ADMIN_USERNAME && password === process.env.ADMIN_PASSWORD) {\r\n+            const token = jwt.sign({ id: 'ADMIN_ID', role: 'SuperAdmin' }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n+            res.status(200).json({ message: 'Login de admin bem-sucedido!', token });\r\n+        } else {\r\n+            res.status(401).json({ message: 'Credenciais de administrador inválidas.' });\r\n+        }\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno do servidor' });\r\n+    }\r\n+});\r\n+\r\n+// Rotas de recuperação de senha\r\n+router.post('/forgot-password', async (req, res) => {\r\n+    try {\r\n+        const { email } = req.body;\r\n+        console.log(`[DEBUG] Rota /forgot-password acionada com o e-mail: ${email}`);\r\n+        \r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        \r\n+        console.log('[DEBUG] A procurar utilizador na base de dados mestre...');\r\n+        const user = await MasterUser.findOne({ email });\r\n+\r\n+        if (!user) {\r\n+            console.log('[DEBUG] Utilizador NÃO encontrado. A terminar o processo silenciosamente (comportamento esperado por segurança).');\r\n+            // Nota: Retornamos 200 para não revelar que o e-mail não existe.\r\n+            return res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n+        }\r\n+\r\n+        console.log(`[DEBUG] Utilizador encontrado: ${user.username}. A gerar token...`);\r\n+        const resetToken = crypto.randomBytes(20).toString('hex');\r\n+        user.resetPasswordToken = resetToken;\r\n+        user.resetPasswordExpires = Date.now() + 3600000; // 1 hora\r\n+        await user.save();\r\n+        console.log('[DEBUG] Token salvo na base de dados.');\r\n+\r\n+        console.log(`[DEBUG] A chamar a função sendPasswordResetEmail para: ${user.email}`);\r\n+        await sendPasswordResetEmail(user.email, resetToken);\r\n+        \r\n+        res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro em forgot-password:\", error);\r\n+        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/reset-password/:token', async (req, res) => {\r\n+    try {\r\n+        const { token } = req.params;\r\n+        const { password } = req.body;\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        const user = await MasterUser.findOne({\r\n+            resetPasswordToken: token,\r\n+            resetPasswordExpires: { $gt: Date.now() }\r\n+        });\r\n+\r\n+        if (!user) {\r\n+            return res.status(400).json({ message: 'O link de recuperação de senha é inválido ou expirou.' });\r\n+        }\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        user.password = await bcrypt.hash(password, salt);\r\n+        user.resetPasswordToken = undefined;\r\n+        user.resetPasswordExpires = undefined;\r\n+        await user.save();\r\n+\r\n+        res.status(200).json({ message: 'Senha atualizada com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro em reset-password:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/register/user', protect, tenantMiddleware, async (req, res) => {\r\n+    try {\r\n+        const { username, password, role, email } = req.body;\r\n+        const { companyId } = req.user; // ID da MasterCompany\r\n+\r\n+        // Conexões e Modelos\r\n+        const masterDb = req.masterDb;\r\n+        const tenantDb = req.tenantDb;\r\n+        const MasterUser = masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        if (!username || !password || !role || !email) {\r\n+            return res.status(400).json({ message: 'Todos os campos são obrigatórios: nome de usuário, senha, cargo e email.' });\r\n+        }\r\n+\r\n+        // 1. Cria o usuário no banco MESTRE (para que ele possa fazer login)\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedPassword = await bcrypt.hash(password, salt);\r\n+\r\n+        await MasterUser.create({\r\n+            username,\r\n+            email,\r\n+            password: hashedPassword,\r\n+            role,\r\n+            company: companyId\r\n+        });\r\n+\r\n+        // 2. Cria o usuário no banco da EMPRESA (para guardar seus dados de aplicação)\r\n+        await TenantUser.create({\r\n+            username,\r\n+            password: hashedPassword,\r\n+            role,\r\n+            email\r\n+        });\r\n+\r\n+        res.status(201).json({ message: `Usuário '${username}' criado com sucesso!` });\r\n+\r\n+    } catch (error) {\r\n+        if (error.code === 11000) {\r\n+            return res.status(400).json({ message: 'Este nome de usuário ou e-mail já existe nesta empresa.' });\r\n+        }\r\n+        console.error(\"Erro ao registrar novo usuário:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+router.post('/register-company', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n+\r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        if (!nomeEmpresa || !cleanCnpj || !email || !username || !password || !ownerEmail) {\r\n+            return res.status(400).json({ message: \"Todos os campos são obrigatórios.\" });\r\n+        }\r\n+        if (await MasterCompany.findOne({ cnpj: cleanCnpj })) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        // Gera o token de verificação\r\n+        const verificationToken = crypto.randomBytes(20).toString('hex');\r\n+        const verificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 horas\r\n+\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+        const newMasterCompany = await MasterCompany.create({ \r\n+            nomeEmpresa, \r\n+            cnpj: cleanCnpj, \r\n+            dbName, \r\n+            email, \r\n+            telefoneWhatsapp,\r\n+            verificationToken, // Salva o token\r\n+            verificationExpires // Salva a data de expiração\r\n+        });\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedPassword = await bcrypt.hash(password, salt);\r\n+\r\n+        await MasterUser.create({\r\n+            username: username,\r\n+            email: ownerEmail,\r\n+            password: hashedPassword,\r\n+            role: 'Proprietário',\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        await TenantUser.create({\r\n+            username,\r\n+            password: hashedPassword, \r\n+            role: 'Proprietário',\r\n+            email: ownerEmail\r\n+        });\r\n+\r\n+        // Envia o e-mail de verificação\r\n+        await sendVerificationEmail(email, nomeEmpresa, verificationToken);\r\n+\r\n+        res.status(201).json({ message: 'Empresa registada! Por favor, verifique o seu e-mail para ativar a sua conta.' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no cadastro self-service:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor durante o cadastro.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para verificar o e-mail\r\n+router.get('/verify/:token', async (req, res) => {\r\n+    try {\r\n+        const { token } = req.params;\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // Encontra a empresa com o token que ainda não expirou\r\n+        const company = await MasterCompany.findOne({\r\n+            verificationToken: token,\r\n+            verificationExpires: { $gt: Date.now() }\r\n+        });\r\n+\r\n+        if (!company) {\r\n+            return res.status(400).json({ message: 'O link de verificação é inválido ou expirou.' });\r\n+        }\r\n+\r\n+        // Atualiza a empresa para o status verificado\r\n+        company.isVerified = true;\r\n+        company.verificationToken = undefined;\r\n+        company.verificationExpires = undefined;\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({ message: 'E-mail verificado com sucesso! Pode agora fazer o login.' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro na verificação de e-mail:\", error);\r\n+        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para o utilizador logado alterar a sua própria senha\r\n+router.post('/change-password', protect, async (req, res) => {\r\n+    try {\r\n+        const { currentPassword, newPassword, confirmPassword } = req.body;\r\n+        const userId = req.user.id; // Obtemos o ID do utilizador a partir do token (é seguro)\r\n+\r\n+        // 1. Validações iniciais\r\n+        if (!currentPassword || !newPassword || !confirmPassword) {\r\n+            return res.status(400).json({ message: 'Todos os campos são obrigatórios.' });\r\n+        }\r\n+        if (newPassword !== confirmPassword) {\r\n+            return res.status(400).json({ message: 'A nova senha e a confirmação não coincidem.' });\r\n+        }\r\n+        if (newPassword.length < 6) {\r\n+            return res.status(400).json({ message: 'A nova senha deve ter pelo menos 6 caracteres.' });\r\n+        }\r\n+\r\n+        // 2. Encontra o utilizador no banco de dados mestre\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        // Usamos .select('+password') para forçar o Mongoose a incluir o campo da senha na busca\r\n+        const user = await MasterUser.findById(userId).select('+password');\r\n+\r\n+        if (!user) {\r\n+            return res.status(404).json({ message: 'Utilizador não encontrado.' });\r\n+        }\r\n+\r\n+        // 3. Compara a senha atual fornecida com a senha guardada\r\n+        const isMatch = await bcrypt.compare(currentPassword, user.password);\r\n+        if (!isMatch) {\r\n+            return res.status(401).json({ message: 'A senha atual está incorreta.' });\r\n+        }\r\n+\r\n+        // 4. Codifica e salva a nova senha\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        user.password = await bcrypt.hash(newPassword, salt);\r\n+        await user.save();\r\n+\r\n+        res.status(200).json({ message: 'Senha alterada com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao alterar senha:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor ao tentar alterar a senha.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para reenviar o e-mail de verificação\r\n+router.post('/resend-verification', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = req.user.companyId;\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        const company = await MasterCompany.findById(companyId);\r\n+\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+        if (company.isVerified) {\r\n+            return res.status(400).json({ message: 'Esta conta já foi verificada.' });\r\n+        }\r\n+\r\n+        // Gera um novo token e uma nova data de expiração\r\n+        const verificationToken = crypto.randomBytes(20).toString('hex');\r\n+        company.verificationToken = verificationToken;\r\n+        company.verificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 horas\r\n+        await company.save();\r\n+\r\n+        // Usa a função que já temos para enviar o e-mail\r\n+        await sendVerificationEmail(company.email, company.nomeEmpresa, verificationToken);\r\n+\r\n+        res.status(200).json({ message: 'E-mail de verificação reenviado com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao reenviar e-mail de verificação:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor.' });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753814571817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -219,486 +219,74 @@\n \r\n router.post('/register/user', protect, tenantMiddleware, async (req, res) => {\r\n     try {\r\n         const { username, password, role, email } = req.body;\r\n-        const { companyId } = req.user; // ID da MasterCompany\r\n+        const requester = req.user; // Quem está a fazer o pedido\r\n \r\n-        // Conexões e Modelos\r\n-        const masterDb = req.masterDb;\r\n-        const tenantDb = req.tenantDb;\r\n-        const MasterUser = masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        // --- INÍCIO DA CORREÇÃO ---\r\n \r\n-        if (!username || !password || !role || !email) {\r\n-            return res.status(400).json({ message: 'Todos os campos são obrigatórios: nome de usuário, senha, cargo e email.' });\r\n-        }\r\n+        let targetCompanyId;\r\n+        let tenantDb;\r\n+        const masterDb = req.masterDb; // A conexão mestre já vem do middleware\r\n \r\n-        // 1. Cria o usuário no banco MESTRE (para que ele possa fazer login)\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedPassword = await bcrypt.hash(password, salt);\r\n-\r\n-        await MasterUser.create({\r\n-            username,\r\n-            email,\r\n-            password: hashedPassword,\r\n-            role,\r\n-            company: companyId\r\n-        });\r\n-\r\n-        // 2. Cria o usuário no banco da EMPRESA (para guardar seus dados de aplicação)\r\n-        await TenantUser.create({\r\n-            username,\r\n-            password: hashedPassword,\r\n-            role,\r\n-            email\r\n-        });\r\n-\r\n-        res.status(201).json({ message: `Usuário '${username}' criado com sucesso!` });\r\n-\r\n-    } catch (error) {\r\n-        if (error.code === 11000) {\r\n-            return res.status(400).json({ message: 'Este nome de usuário ou e-mail já existe nesta empresa.' });\r\n-        }\r\n-        console.error(\"Erro ao registrar novo usuário:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-router.post('/register-company', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-\r\n-        const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n-\r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        if (!nomeEmpresa || !cleanCnpj || !email || !username || !password || !ownerEmail) {\r\n-            return res.status(400).json({ message: \"Todos os campos são obrigatórios.\" });\r\n-        }\r\n-        if (await MasterCompany.findOne({ cnpj: cleanCnpj })) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        // Gera o token de verificação\r\n-        const verificationToken = crypto.randomBytes(20).toString('hex');\r\n-        const verificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 horas\r\n-\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-        const newMasterCompany = await MasterCompany.create({ \r\n-            nomeEmpresa, \r\n-            cnpj: cleanCnpj, \r\n-            dbName, \r\n-            email, \r\n-            telefoneWhatsapp,\r\n-            verificationToken, // Salva o token\r\n-            verificationExpires // Salva a data de expiração\r\n-        });\r\n-\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedPassword = await bcrypt.hash(password, salt);\r\n-\r\n-        await MasterUser.create({\r\n-            username: username,\r\n-            email: ownerEmail,\r\n-            password: hashedPassword,\r\n-            role: 'Proprietário',\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        await TenantUser.create({\r\n-            username,\r\n-            password: hashedPassword, \r\n-            role: 'Proprietário',\r\n-            email: ownerEmail\r\n-        });\r\n-\r\n-        // Envia o e-mail de verificação\r\n-        await sendVerificationEmail(email, nomeEmpresa, verificationToken);\r\n-\r\n-        res.status(201).json({ message: 'Empresa registada! Por favor, verifique o seu e-mail para ativar a sua conta.' });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro no cadastro self-service:\", error);\r\n-        res.status(500).json({ message: 'Erro interno no servidor durante o cadastro.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para verificar o e-mail\r\n-router.get('/verify/:token', async (req, res) => {\r\n-    try {\r\n-        const { token } = req.params;\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // Encontra a empresa com o token que ainda não expirou\r\n-        const company = await MasterCompany.findOne({\r\n-            verificationToken: token,\r\n-            verificationExpires: { $gt: Date.now() }\r\n-        });\r\n-\r\n-        if (!company) {\r\n-            return res.status(400).json({ message: 'O link de verificação é inválido ou expirou.' });\r\n-        }\r\n-\r\n-        // Atualiza a empresa para o status verificado\r\n-        company.isVerified = true;\r\n-        company.verificationToken = undefined;\r\n-        company.verificationExpires = undefined;\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({ message: 'E-mail verificado com sucesso! Pode agora fazer o login.' });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro na verificação de e-mail:\", error);\r\n-        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota para o utilizador logado alterar a sua própria senha\r\n-router.post('/change-password', protect, async (req, res) => {\r\n-    try {\r\n-        const { currentPassword, newPassword, confirmPassword } = req.body;\r\n-        const userId = req.user.id; // Obtemos o ID do utilizador a partir do token (é seguro)\r\n-\r\n-        // 1. Validações iniciais\r\n-        if (!currentPassword || !newPassword || !confirmPassword) {\r\n-            return res.status(400).json({ message: 'Todos os campos são obrigatórios.' });\r\n-        }\r\n-        if (newPassword !== confirmPassword) {\r\n-            return res.status(400).json({ message: 'A nova senha e a confirmação não coincidem.' });\r\n-        }\r\n-        if (newPassword.length < 6) {\r\n-            return res.status(400).json({ message: 'A nova senha deve ter pelo menos 6 caracteres.' });\r\n-        }\r\n-\r\n-        // 2. Encontra o utilizador no banco de dados mestre\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        // Usamos .select('+password') para forçar o Mongoose a incluir o campo da senha na busca\r\n-        const user = await MasterUser.findById(userId).select('+password');\r\n-\r\n-        if (!user) {\r\n-            return res.status(404).json({ message: 'Utilizador não encontrado.' });\r\n-        }\r\n-\r\n-        // 3. Compara a senha atual fornecida com a senha guardada\r\n-        const isMatch = await bcrypt.compare(currentPassword, user.password);\r\n-        if (!isMatch) {\r\n-            return res.status(401).json({ message: 'A senha atual está incorreta.' });\r\n-        }\r\n-\r\n-        // 4. Codifica e salva a nova senha\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        user.password = await bcrypt.hash(newPassword, salt);\r\n-        await user.save();\r\n-\r\n-        res.status(200).json({ message: 'Senha alterada com sucesso!' });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao alterar senha:\", error);\r\n-        res.status(500).json({ message: 'Erro interno no servidor ao tentar alterar a senha.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para reenviar o e-mail de verificação\r\n-router.post('/resend-verification', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = req.user.companyId;\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        const company = await MasterCompany.findById(companyId);\r\n-\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-        if (company.isVerified) {\r\n-            return res.status(400).json({ message: 'Esta conta já foi verificada.' });\r\n-        }\r\n-\r\n-        // Gera um novo token e uma nova data de expiração\r\n-        const verificationToken = crypto.randomBytes(20).toString('hex');\r\n-        company.verificationToken = verificationToken;\r\n-        company.verificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 horas\r\n-        await company.save();\r\n-\r\n-        // Usa a função que já temos para enviar o e-mail\r\n-        await sendVerificationEmail(company.email, company.nomeEmpresa, verificationToken);\r\n-\r\n-        res.status(200).json({ message: 'E-mail de verificação reenviado com sucesso!' });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao reenviar e-mail de verificação:\", error);\r\n-        res.status(500).json({ message: 'Erro interno no servidor.' });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const jwt = require('jsonwebtoken');\r\n-const { getTenantConnection } = require('../config/db');\r\n-const crypto = require('crypto');\r\n-const { body, validationResult } = require('express-validator');\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const { tenantMiddleware } = require('../middleware/tenantMiddleware');\r\n-\r\n-\r\n-// Importamos os ESQUEMAS do banco Mestre\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-\r\n-// Importamos o serviço de e-mail\r\n-const { sendPasswordResetEmail, sendVerificationEmail } = require('../services/emailService');\r\n-\r\n-\r\n-// Rota principal de login\r\n-router.post('/login/direct', [\r\n-    body('cnpj', 'O CNPJ é obrigatório.').notEmpty(),\r\n-    body('username', 'O nome de usuário é obrigatório.').notEmpty(),\r\n-    body('password', 'A senha é obrigatória.').notEmpty()\r\n-], async (req, res) => {\r\n-    const errors = validationResult(req);\r\n-    if (!errors.isEmpty()) {\r\n-        return res.status(400).json({ errors: errors.array() });\r\n-    }\r\n-\r\n-    try {\r\n-        const { cnpj, username, password } = req.body;\r\n-\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-\r\n-        const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n-        if (!company) {\r\n-            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n-        }\r\n-\r\n-        // --- AQUI ESTÁ A CORREÇÃO DEFINITIVA ---\r\n-        // Fazemos uma ÚNICA busca, pedindo para INCLUIR explicitamente a senha e o role.\r\n-        const user = await MasterUser.findOne({ username: username, company: company._id }).select('+password +role');\r\n-\r\n-        if (!user) {\r\n-            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n-        }\r\n-\r\n-        const isMatch = await bcrypt.compare(password, user.password);\r\n-        if (!isMatch) {\r\n-            return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n-        }\r\n-\r\n-        const token = jwt.sign(\r\n-            { \r\n-                id: user._id, \r\n-                companyId: user.company,\r\n-                username: user.username,\r\n-                role: user.role // Agora 'user.role' terá o valor correto\r\n-            }, \r\n-            process.env.JWT_SECRET, \r\n-            { expiresIn: '8h' }\r\n-        );\r\n-\r\n-        res.status(200).json({\r\n-            message: 'Login bem-sucedido!',\r\n-            token,\r\n-            user: { id: user._id, username: user.username }\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro no login direto:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para verificar se uma empresa existe pelo CNPJ\r\n-router.post('/find-company-by-cnpj', async (req, res) => {\r\n-    try {\r\n-        const { cnpj } = req.body;\r\n-        if (!cnpj) {\r\n-            return res.status(400).json({ message: 'CNPJ não fornecido.' });\r\n-        }\r\n-    \r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n-        \r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Nenhuma empresa encontrada com este CNPJ.' });\r\n-        }\r\n-    \r\n-        res.status(200).json({ message: 'Empresa encontrada!' });\r\n-        \r\n-    } catch (error) {\r\n-        console.error(\"Erro em /find-company-by-cnpj:\", error);\r\n-        res.status(500).json({ message: 'Erro interno no servidor' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para verificar a sessão do usuário\r\n-router.get('/me', protect, tenantMiddleware, async (req, res) => {\r\n-    try {\r\n-        if (req.user.role === 'SuperAdmin') {\r\n-            return res.status(200).json({ \r\n-                user: { role: 'SuperAdmin' },\r\n-                company: { nomeEmpresa: 'Painel de Administrador' } \r\n-            });\r\n-        }\r\n-\r\n-        const tenantDb = req.tenantDb;\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const tenantUser = await TenantUser.findOne({ username: req.user.username });\r\n-        \r\n-        if (!tenantUser) {\r\n-            return res.status(404).json({ message: 'Usuário não encontrado no registro da empresa.' });\r\n-        }\r\n-        \r\n-        const company = req.company;\r\n-\r\n-        res.status(200).json({ \r\n-            user: {\r\n-                id: tenantUser._id,\r\n-                username: tenantUser.username,\r\n-                role: tenantUser.role\r\n-            }, \r\n-            company: {\r\n-                _id: company._id,\r\n-                nomeEmpresa: company.nomeEmpresa,\r\n-                subscription: company.subscription\r\n+        if (requester.role === 'SuperAdmin') {\r\n+            // Se for o Admin, o ID da empresa-alvo vem do corpo do pedido\r\n+            targetCompanyId = req.body.companyId;\r\n+            if (!targetCompanyId) {\r\n+                return res.status(400).json({ message: 'O ID da empresa é obrigatório para o SuperAdmin.' });\r\n             }\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao verificar sessão (/me):\", error);\r\n-        res.status(500).json({ message: 'Erro ao verificar a sessão.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota de login de admin\r\n-router.post('/login/admin', (req, res) => {\r\n-    try {\r\n-        const { username, password } = req.body;\r\n-        if (username === process.env.ADMIN_USERNAME && password === process.env.ADMIN_PASSWORD) {\r\n-            const token = jwt.sign({ id: 'ADMIN_ID', role: 'SuperAdmin' }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n-            res.status(200).json({ message: 'Login de admin bem-sucedido!', token });\r\n+            // Estabelecemos a conexão com o tenant manualmente\r\n+            const MasterCompany = masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+            const company = await MasterCompany.findById(targetCompanyId);\r\n+            if (!company) {\r\n+                return res.status(404).json({ message: 'Empresa-alvo não encontrada.' });\r\n+            }\r\n+            tenantDb = await getTenantConnection(company.dbName);\r\n         } else {\r\n-            res.status(401).json({ message: 'Credenciais de administrador inválidas.' });\r\n+            // Se for um utilizador normal (Proprietário), usamos os dados do middleware\r\n+            targetCompanyId = requester.companyId;\r\n+            tenantDb = req.tenantDb; // O tenantDb já foi definido pelo tenantMiddleware\r\n         }\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor' });\r\n-    }\r\n-});\r\n \r\n-// Rotas de recuperação de senha\r\n-router.post('/forgot-password', async (req, res) => {\r\n-    try {\r\n-        const { email } = req.body;\r\n-        console.log(`[DEBUG] Rota /forgot-password acionada com o e-mail: ${email}`);\r\n-        \r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        \r\n-        console.log('[DEBUG] A procurar utilizador na base de dados mestre...');\r\n-        const user = await MasterUser.findOne({ email });\r\n+        // --- FIM DA CORREÇÃO ---\r\n \r\n-        if (!user) {\r\n-            console.log('[DEBUG] Utilizador NÃO encontrado. A terminar o processo silenciosamente (comportamento esperado por segurança).');\r\n-            // Nota: Retornamos 200 para não revelar que o e-mail não existe.\r\n-            return res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n-        }\r\n-\r\n-        console.log(`[DEBUG] Utilizador encontrado: ${user.username}. A gerar token...`);\r\n-        const resetToken = crypto.randomBytes(20).toString('hex');\r\n-        user.resetPasswordToken = resetToken;\r\n-        user.resetPasswordExpires = Date.now() + 3600000; // 1 hora\r\n-        await user.save();\r\n-        console.log('[DEBUG] Token salvo na base de dados.');\r\n-\r\n-        console.log(`[DEBUG] A chamar a função sendPasswordResetEmail para: ${user.email}`);\r\n-        await sendPasswordResetEmail(user.email, resetToken);\r\n-        \r\n-        res.status(200).json({ message: 'Se um e-mail correspondente for encontrado, um link de recuperação será enviado.' });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro em forgot-password:\", error);\r\n-        res.status(500).json({ message: \"Erro interno no servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/reset-password/:token', async (req, res) => {\r\n-    try {\r\n-        const { token } = req.params;\r\n-        const { password } = req.body;\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        const user = await MasterUser.findOne({\r\n-            resetPasswordToken: token,\r\n-            resetPasswordExpires: { $gt: Date.now() }\r\n-        });\r\n-\r\n-        if (!user) {\r\n-            return res.status(400).json({ message: 'O link de recuperação de senha é inválido ou expirou.' });\r\n-        }\r\n-\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        user.password = await bcrypt.hash(password, salt);\r\n-        user.resetPasswordToken = undefined;\r\n-        user.resetPasswordExpires = undefined;\r\n-        await user.save();\r\n-\r\n-        res.status(200).json({ message: 'Senha atualizada com sucesso!' });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro em reset-password:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/register/user', protect, tenantMiddleware, async (req, res) => {\r\n-    try {\r\n-        const { username, password, role, email } = req.body;\r\n-        const { companyId } = req.user; // ID da MasterCompany\r\n-\r\n-        // Conexões e Modelos\r\n-        const masterDb = req.masterDb;\r\n-        const tenantDb = req.tenantDb;\r\n+        // Modelos\r\n         const MasterUser = masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema); // Agora tenantDb está sempre definido\r\n \r\n         if (!username || !password || !role || !email) {\r\n-            return res.status(400).json({ message: 'Todos os campos são obrigatórios: nome de utilizador, senha, cargo e email.' });\r\n+            return res.status(400).json({ message: 'Todos os campos são obrigatórios: nome de usuário, senha, cargo e email.' });\r\n         }\r\n \r\n-        // Codifica a senha\r\n+        // 1. Cria o usuário no banco MESTRE\r\n         const salt = await bcrypt.genSalt(10);\r\n         const hashedPassword = await bcrypt.hash(password, salt);\r\n \r\n-        // 1. Cria o utilizador no banco MESTRE (para que ele possa fazer login)\r\n-        // AQUI ESTAVA A PRIMEIRA PARTE DO PROBLEMA, NÃO ESTAVA A PASSAR O E-MAIL\r\n         await MasterUser.create({\r\n             username,\r\n-            email, // E-mail adicionado aqui\r\n+            email,\r\n             password: hashedPassword,\r\n             role,\r\n-            company: companyId\r\n+            company: targetCompanyId // Usamos o ID da empresa-alvo\r\n         });\r\n \r\n-        // 2. Cria o utilizador no banco da EMPRESA (para guardar seus dados de aplicação)\r\n-        // AQUI ESTAVA O PROBLEMA PRINCIPAL, NÃO PRECISAMOS DE PASSAR O _id\r\n+        // 2. Cria o usuário no banco da EMPRESA\r\n         await TenantUser.create({\r\n             username,\r\n-            password: hashedPassword, \r\n+            password: hashedPassword,\r\n             role,\r\n             email\r\n         });\r\n \r\n-        res.status(201).json({ message: `Utilizador '${username}' criado com sucesso!` });\r\n+        res.status(201).json({ message: `Usuário '${username}' criado com sucesso!` });\r\n \r\n     } catch (error) {\r\n-        // Este erro de duplicado é comum se o utilizador já existir\r\n-        if (error.code === 11000) { \r\n-            return res.status(400).json({ message: 'Este nome de utilizador ou e-mail já existe nesta empresa.' });\r\n+        if (error.code === 11000) {\r\n+            // Mensagem de erro mais específica\r\n+            const field = Object.keys(error.keyPattern)[0];\r\n+            return res.status(400).json({ message: `O campo '${field}' já está em uso.` });\r\n         }\r\n-        console.error(\"Erro ao registrar novo utilizador:\", error);\r\n+        console.error(\"Erro ao registrar novo usuário:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n"
                },
                {
                    "date": 1754327994477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -341,9 +341,9 @@\n             email: ownerEmail\r\n         });\r\n \r\n         // Envia o e-mail de verificação\r\n-        await sendVerificationEmail(email, nomeEmpresa, verificationToken);\r\n+        await sendVerificationEmail(req.masterDb, email, nomeEmpresa, verificationToken);\r\n \r\n         res.status(201).json({ message: 'Empresa registada! Por favor, verifique o seu e-mail para ativar a sua conta.' });\r\n \r\n     } catch (error) {\r\n"
                },
                {
                    "date": 1754410090151,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,10 +30,10 @@\n \r\n     try {\r\n         const { cnpj, username, password } = req.body;\r\n \r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany');\r\n+        const MasterUser = req.masterDb.model('MasterUser');\r\n \r\n         const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n         if (!company) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n"
                },
                {
                    "date": 1754410104088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -291,10 +291,10 @@\n });\r\n \r\n router.post('/register-company', async (req, res) => {\r\n     try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany');\r\n+        const MasterUser = req.masterDb.model('MasterUser');\r\n \r\n         const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n \r\n         const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n"
                },
                {
                    "date": 1754410151177,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,10 +30,10 @@\n \r\n     try {\r\n         const { cnpj, username, password } = req.body;\r\n \r\n-        const MasterCompany = req.masterDb.model('MasterCompany');\r\n-        const MasterUser = req.masterDb.model('MasterUser');\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n \r\n         const company = await MasterCompany.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n         if (!company) {\r\n             return res.status(401).json({ message: 'Credenciais inválidas.' });\r\n@@ -291,10 +291,10 @@\n });\r\n \r\n router.post('/register-company', async (req, res) => {\r\n     try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany');\r\n-        const MasterUser = req.masterDb.model('MasterUser');\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n \r\n         const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n \r\n         const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n"
                },
                {
                    "date": 1754505792856,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,10 +9,10 @@\n const { tenantMiddleware } = require('../middleware/tenantMiddleware');\r\n \r\n \r\n // Importamos os ESQUEMAS do banco Mestre\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { schema: MasterCompanySchema } = require('../models/MasterCompany');\r\n+const { schema: MasterUserSchema } = require('../models/MasterUser');\r\n \r\n // Importamos o serviço de e-mail\r\n const { sendPasswordResetEmail, sendVerificationEmail } = require('../services/emailService');\r\n \r\n"
                }
            ],
            "date": 1752269446397,
            "name": "Commit-0",
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst bcrypt = require('bcryptjs');\r\nconst jwt = require('jsonwebtoken');\r\n\r\n// MUDANÇA: Importamos os modelos Company e o novo modelo User\r\nconst Company = require('../models/Company');\r\nconst User = require('../models/User'); \r\n\r\n// Rota: POST /api/auth/login/company\r\n// Esta rota continua praticamente igual, pois serve apenas para validar a empresa\r\n// antes de mostrar a tela de login de usuário.\r\nrouter.post('/login/company', async (req, res) => {\r\n    try {\r\n        const { cnpj, password } = req.body;\r\n        if (!cnpj || !password) {\r\n            return res.status(400).json({ message: 'Por favor, forneça CNPJ e senha.' });\r\n        }\r\n        const company = await Company.findOne({ cnpj: cnpj.replace(/\\D/g, '') });\r\n        if (!company) {\r\n            return res.status(401).json({ message: 'CNPJ ou Senha da Empresa incorretos.' });\r\n        }\r\n        const isMatch = await bcrypt.compare(password, company.senhaEmpresa);\r\n        if (!isMatch) {\r\n            return res.status(401).json({ message: 'CNPJ ou Senha da Empresa incorretos.' });\r\n        }\r\n        const token = jwt.sign({ id: company._id, cnpj: company.cnpj }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n        \r\n        // MUDANÇA: A resposta agora é mais limpa, não precisamos de enviar a lista de usuários.\r\n        res.status(200).json({\r\n            message: 'Login bem-sucedido!',\r\n            token: token,\r\n            company: { _id: company._id, nomeEmpresa: company.nomeEmpresa, cnpj: company.cnpj }\r\n        });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro interno no servidor' });\r\n    }\r\n});\r\n\r\n// Rota: POST /api/auth/login/admin\r\n// Nenhuma mudança necessária aqui. A lógica do admin é independente.\r\nrouter.post('/login/admin', async (req, res) => {\r\n    try {\r\n        const { username, password } = req.body;\r\n        if (username === process.env.ADMIN_USERNAME && password === process.env.ADMIN_PASSWORD) {\r\n            const token = jwt.sign({ id: 'ADMIN_ID', role: 'SuperAdmin' }, process.env.JWT_SECRET, { expiresIn: '1h' });\r\n            res.status(200).json({ message: 'Login de admin bem-sucedido!', token });\r\n        } else {\r\n            res.status(401).json({ message: 'Credenciais de administrador inválidas.' });\r\n        }\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro interno do servidor' });\r\n    }\r\n});\r\n\r\n\r\n// Rota: POST /api/auth/register/user\r\n// GRANDE MUDANÇA AQUI\r\nrouter.post('/register/user', async (req, res) => {\r\n    try {\r\n        const { username, password, companyId } = req.body;\r\n        if (!username || !password || !companyId) {\r\n            return res.status(400).json({ message: 'Dados insuficientes para registrar o usuário.' });\r\n        }\r\n\r\n        // ANTES: Procurávamos a empresa para adicionar um usuário à sua lista interna.\r\n        // AGORA: Verificamos se o usuário já existe na coleção 'User', filtrando por empresa.\r\n        const userExists = await User.findOne({ username, company: companyId });\r\n        if (userExists) {\r\n            return res.status(400).json({ message: 'Este nome de usuário já existe nesta empresa.' });\r\n        }\r\n\r\n        const salt = await bcrypt.genSalt(10);\r\n        const hashedPassword = await bcrypt.hash(password, salt);\r\n        \r\n        // ANTES: company.usuarios.push(...)\r\n        // AGORA: Criamos um documento totalmente novo na coleção 'User'.\r\n        await User.create({\r\n            username,\r\n            password: hashedPassword,\r\n            role: 'Funcionário', // Por padrão, usuários registados são funcionários\r\n            company: companyId // A ligação à empresa\r\n        });\r\n\r\n        res.status(201).json({ message: `Usuário '${username}' registrado com sucesso!` });\r\n    } catch (error) {\r\n        console.error(\"Erro ao registrar usuário:\", error);\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\n\r\n// Rota: POST /api/auth/login/user\r\n// GRANDE MUDANÇA AQUI\r\nrouter.post('/login/user', async (req, res) => {\r\n    try {\r\n        const { username, password, companyId } = req.body;\r\n        if (!username || !password || !companyId) {\r\n            return res.status(400).json({ message: 'Dados insuficientes para o login.' });\r\n        }\r\n\r\n        // ANTES: Procurávamos a empresa e depois o usuário dentro dela.\r\n        // AGORA: Procuramos o usuário diretamente na coleção 'User', garantindo que pertence à empresa certa.\r\n        const user = await User.findOne({ username, company: companyId });\r\n        if (!user) {\r\n            return res.status(401).json({ message: 'Usuário ou senha incorretos.' });\r\n        }\r\n\r\n        const isMatch = await bcrypt.compare(password, user.password);\r\n        if (!isMatch) {\r\n            return res.status(401).json({ message: 'Usuário ou senha incorretos.' });\r\n        }\r\n        \r\n        // A geração do token continua igual, usando os dados do usuário encontrado.\r\n        const token = jwt.sign({ id: user._id, companyId: user.company, role: user.role }, process.env.JWT_SECRET, { expiresIn: '8h' });\r\n        \r\n        res.status(200).json({\r\n            message: 'Login de usuário bem-sucedido!',\r\n            token,\r\n            user: { id: user._id, username: user.username, role: user.role }\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Erro no login do usuário:\", error);\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\nmodule.exports = router;"
        }
    ]
}