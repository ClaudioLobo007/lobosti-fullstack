{
    "sourceFile": "Servidor/routes/export.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1753363476139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753364739236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,34 +55,37 @@\n         const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n         const dateRange = getDateRange(req.query);\r\n         const data = await getReportData(companyId, dateRange);\r\n \r\n-        // Define o nome do ficheiro para download\r\n-        res.setHeader('Content-Disposition', 'attachment; filename=\"relatorio-despesas.csv\"');\r\n-        res.setHeader('Content-Type', 'text/csv; charset=utf-8');\r\n+        // Prepara os dados para o CSV\r\n+        const records = data.map(item => ({\r\n+            ...item,\r\n+            Valor: item.Valor.toFixed(2).replace('.', ',') // Formato de moeda para Excel PT\r\n+        }));\r\n \r\n+        // Cria o writer sem o 'path', para que ele trabalhe em memória\r\n         const csvWriter = createObjectCsvWriter({\r\n-            path: res, // Escreve diretamente na resposta do servidor\r\n             header: [\r\n                 { id: 'Data', title: 'DATA' },\r\n                 { id: 'Nome', title: 'NOME' },\r\n                 { id: 'Parcela', title: 'PARCELA' },\r\n                 { id: 'Categoria', title: 'CATEGORIA' },\r\n                 { id: 'Valor', title: 'VALOR' },\r\n                 { id: 'Status', title: 'STATUS' }\r\n             ],\r\n-            fieldDelimiter: ';', // Usa ponto e vírgula para compatibilidade com Excel em português\r\n+            fieldDelimiter: ';',\r\n         });\r\n \r\n-        // Formata os dados para o CSV\r\n-        const records = data.map(item => ({\r\n-            ...item,\r\n-            Valor: item.Valor.toFixed(2).replace('.', ',') // Formato de moeda para Excel PT\r\n-        }));\r\n+        // Converte os registos para uma string CSV\r\n+        const csvString = csvWriter.getHeaderString() + csvWriter.stringifyRecords(records);\r\n \r\n-        await csvWriter.writeRecords(records);\r\n-        res.end();\r\n+        // Define os cabeçalhos para o download\r\n+        res.setHeader('Content-Disposition', 'attachment; filename=\"relatorio-despesas.csv\"');\r\n+        res.setHeader('Content-Type', 'text/csv; charset=utf-8');\r\n \r\n+        // Envia a string completa de uma só vez\r\n+        res.status(200).send(csvString);\r\n+\r\n     } catch (error) {\r\n         console.error(\"Erro ao gerar CSV:\", error);\r\n         res.status(500).send(\"Erro ao gerar o relatório em CSV.\");\r\n     }\r\n"
                },
                {
                    "date": 1753364919903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,15 +55,19 @@\n         const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n         const dateRange = getDateRange(req.query);\r\n         const data = await getReportData(companyId, dateRange);\r\n \r\n-        // Prepara os dados para o CSV\r\n+        // Prepara os dados para o CSV com mais segurança\r\n         const records = data.map(item => ({\r\n-            ...item,\r\n-            Valor: item.Valor.toFixed(2).replace('.', ',') // Formato de moeda para Excel PT\r\n+            Data: item.Data || '',\r\n+            Nome: item.Nome || 'N/A',\r\n+            Parcela: item.Parcela || '',\r\n+            Categoria: item.Categoria || 'N/A',\r\n+            // CORREÇÃO PRINCIPAL AQUI: Se o valor for nulo ou indefinido, trata como 0.\r\n+            Valor: (item.Valor || 0).toFixed(2).replace('.', ','),\r\n+            Status: item.Status || 'N/A'\r\n         }));\r\n \r\n-        // Cria o writer sem o 'path', para que ele trabalhe em memória\r\n         const csvWriter = createObjectCsvWriter({\r\n             header: [\r\n                 { id: 'Data', title: 'DATA' },\r\n                 { id: 'Nome', title: 'NOME' },\r\n@@ -74,16 +78,13 @@\n             ],\r\n             fieldDelimiter: ';',\r\n         });\r\n \r\n-        // Converte os registos para uma string CSV\r\n         const csvString = csvWriter.getHeaderString() + csvWriter.stringifyRecords(records);\r\n \r\n-        // Define os cabeçalhos para o download\r\n         res.setHeader('Content-Disposition', 'attachment; filename=\"relatorio-despesas.csv\"');\r\n         res.setHeader('Content-Type', 'text/csv; charset=utf-8');\r\n \r\n-        // Envia a string completa de uma só vez\r\n         res.status(200).send(csvString);\r\n \r\n     } catch (error) {\r\n         console.error(\"Erro ao gerar CSV:\", error);\r\n"
                },
                {
                    "date": 1753365136642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,16 @@\n-// Crie este novo ficheiro: Servidor/routes/export.js\r\n+// Substituir o conteúdo completo de Servidor/routes/export.js\r\n \r\n const express = require('express');\r\n const router = express.Router();\r\n const mongoose = require('mongoose');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const Boleto = require('../models/Boleto');\r\n-const { createObjectCsvWriter } = require('csv-writer');\r\n+// CORREÇÃO: Importamos a função correta para gerar strings\r\n+const { createObjectCsvStringifier } = require('csv-writer');\r\n const PDFDocument = require('pdfkit');\r\n \r\n-// Função de ajuda para obter o período de tempo (semelhante à de reports.js)\r\n+// Função de ajuda para obter o período de tempo (sem alterações)\r\n function getDateRange(query) {\r\n     const { startDate, endDate } = query;\r\n     if (startDate && endDate) {\r\n         return {\r\n@@ -25,9 +26,9 @@\n         end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n     };\r\n }\r\n \r\n-// Função de ajuda para buscar os dados do relatório\r\n+// Função de ajuda para buscar os dados do relatório (sem alterações)\r\n async function getReportData(companyId, dateRange) {\r\n     return await Boleto.aggregate([\r\n         { $match: { company: companyId } },\r\n         { $unwind: '$parcels' },\r\n@@ -48,27 +49,26 @@\n         }\r\n     ]);\r\n }\r\n \r\n-// Rota: GET /api/export/csv\r\n+// Rota: GET /api/export/csv (VERSÃO FINAL E CORRIGIDA)\r\n router.get('/csv', protect, async (req, res) => {\r\n     try {\r\n         const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n         const dateRange = getDateRange(req.query);\r\n         const data = await getReportData(companyId, dateRange);\r\n \r\n-        // Prepara os dados para o CSV com mais segurança\r\n         const records = data.map(item => ({\r\n             Data: item.Data || '',\r\n             Nome: item.Nome || 'N/A',\r\n             Parcela: item.Parcela || '',\r\n             Categoria: item.Categoria || 'N/A',\r\n-            // CORREÇÃO PRINCIPAL AQUI: Se o valor for nulo ou indefinido, trata como 0.\r\n             Valor: (item.Valor || 0).toFixed(2).replace('.', ','),\r\n             Status: item.Status || 'N/A'\r\n         }));\r\n \r\n-        const csvWriter = createObjectCsvWriter({\r\n+        // CORREÇÃO: Usamos a função correta 'createObjectCsvStringifier'\r\n+        const csvStringifier = createObjectCsvStringifier({\r\n             header: [\r\n                 { id: 'Data', title: 'DATA' },\r\n                 { id: 'Nome', title: 'NOME' },\r\n                 { id: 'Parcela', title: 'PARCELA' },\r\n@@ -78,9 +78,10 @@\n             ],\r\n             fieldDelimiter: ';',\r\n         });\r\n \r\n-        const csvString = csvWriter.getHeaderString() + csvWriter.stringifyRecords(records);\r\n+        // Agora estes métodos existem e vão funcionar\r\n+        const csvString = csvStringifier.getHeaderString() + csvStringifier.stringifyRecords(records);\r\n \r\n         res.setHeader('Content-Disposition', 'attachment; filename=\"relatorio-despesas.csv\"');\r\n         res.setHeader('Content-Type', 'text/csv; charset=utf-8');\r\n \r\n@@ -91,57 +92,10 @@\n         res.status(500).send(\"Erro ao gerar o relatório em CSV.\");\r\n     }\r\n });\r\n \r\n-// Rota: GET /api/export/pdf\r\n+// A rota do PDF permanece igual\r\n router.get('/pdf', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        const dateRange = getDateRange(req.query);\r\n-        const data = await getReportData(companyId, dateRange);\r\n-\r\n-        // Define o nome do ficheiro para download\r\n-        res.setHeader('Content-Disposition', 'attachment; filename=\"relatorio-despesas.pdf\"');\r\n-        res.setHeader('Content-Type', 'application/pdf');\r\n-\r\n-        const doc = new PDFDocument({ margin: 30, size: 'A4' });\r\n-        doc.pipe(res);\r\n-\r\n-        // Cabeçalho do Documento\r\n-        doc.fontSize(18).text('Relatório de Despesas', { align: 'center' });\r\n-        const dateOptions = { day: '2-digit', month: '2-digit', year: 'numeric' };\r\n-        const periodStr = `${dateRange.start.toLocaleDateString('pt-BR', dateOptions)} a ${dateRange.end.toLocaleDateString('pt-BR', dateOptions)}`;\r\n-        doc.fontSize(10).text(`Período: ${periodStr}`, { align: 'center' });\r\n-        doc.moveDown(2);\r\n-\r\n-        // Cabeçalho da Tabela\r\n-        const tableTop = doc.y;\r\n-        const colPositions = [30, 90, 240, 340, 420, 500];\r\n-        const headers = ['Data', 'Nome', 'Parcela', 'Categoria', 'Valor', 'Status'];\r\n-        headers.forEach((header, i) => {\r\n-            doc.fontSize(10).font('Helvetica-Bold').text(header, colPositions[i], tableTop);\r\n-        });\r\n-        doc.moveTo(30, doc.y + 5).lineTo(565, doc.y + 5).stroke();\r\n-        doc.moveDown();\r\n-\r\n-        // Linhas da Tabela\r\n-        data.forEach(item => {\r\n-            const rowY = doc.y;\r\n-            doc.fontSize(9).font('Helvetica').text(item.Data, colPositions[0], rowY);\r\n-            doc.text(item.Nome, colPositions[1], rowY, { width: 140, ellipsis: true });\r\n-            doc.text(String(item.Parcela), colPositions[2], rowY);\r\n-            doc.text(item.Categoria, colPositions[3], rowY);\r\n-            doc.text(item.Valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }), colPositions[4], rowY, { align: 'right' });\r\n-            doc.text(item.Status, colPositions[5], rowY);\r\n-            doc.moveDown();\r\n-        });\r\n-\r\n-        doc.end();\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar PDF:\", error);\r\n-        res.status(500).send(\"Erro ao gerar o relatório em PDF.\");\r\n-    }\r\n+    // ... (código do PDF sem alterações)\r\n });\r\n \r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753365173742,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-// Substituir o conteúdo completo de Servidor/routes/export.js\r\n-\r\n const express = require('express');\r\n const router = express.Router();\r\n const mongoose = require('mongoose');\r\n const { protect } = require('../middleware/authMiddleware');\r\n@@ -92,10 +90,57 @@\n         res.status(500).send(\"Erro ao gerar o relatório em CSV.\");\r\n     }\r\n });\r\n \r\n-// A rota do PDF permanece igual\r\n+// Rota: GET /api/export/pdf\r\n router.get('/pdf', protect, async (req, res) => {\r\n-    // ... (código do PDF sem alterações)\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const dateRange = getDateRange(req.query);\r\n+        const data = await getReportData(companyId, dateRange);\r\n+\r\n+        // Define o nome do ficheiro para download\r\n+        res.setHeader('Content-Disposition', 'attachment; filename=\"relatorio-despesas.pdf\"');\r\n+        res.setHeader('Content-Type', 'application/pdf');\r\n+\r\n+        const doc = new PDFDocument({ margin: 30, size: 'A4' });\r\n+        doc.pipe(res);\r\n+\r\n+        // Cabeçalho do Documento\r\n+        doc.fontSize(18).text('Relatório de Despesas', { align: 'center' });\r\n+        const dateOptions = { day: '2-digit', month: '2-digit', year: 'numeric' };\r\n+        const periodStr = `${dateRange.start.toLocaleDateString('pt-BR', dateOptions)} a ${dateRange.end.toLocaleDateString('pt-BR', dateOptions)}`;\r\n+        doc.fontSize(10).text(`Período: ${periodStr}`, { align: 'center' });\r\n+        doc.moveDown(2);\r\n+\r\n+        // Cabeçalho da Tabela\r\n+        const tableTop = doc.y;\r\n+        const colPositions = [30, 90, 240, 340, 420, 500];\r\n+        const headers = ['Data', 'Nome', 'Parcela', 'Categoria', 'Valor', 'Status'];\r\n+        headers.forEach((header, i) => {\r\n+            doc.fontSize(10).font('Helvetica-Bold').text(header, colPositions[i], tableTop);\r\n+        });\r\n+        doc.moveTo(30, doc.y + 5).lineTo(565, doc.y + 5).stroke();\r\n+        doc.moveDown();\r\n+\r\n+        // Linhas da Tabela\r\n+        data.forEach(item => {\r\n+            const rowY = doc.y;\r\n+            doc.fontSize(9).font('Helvetica').text(item.Data, colPositions[0], rowY);\r\n+            doc.text(item.Nome, colPositions[1], rowY, { width: 140, ellipsis: true });\r\n+            doc.text(String(item.Parcela), colPositions[2], rowY);\r\n+            doc.text(item.Categoria, colPositions[3], rowY);\r\n+            doc.text(item.Valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }), colPositions[4], rowY, { align: 'right' });\r\n+            doc.text(item.Status, colPositions[5], rowY);\r\n+            doc.moveDown();\r\n+        });\r\n+\r\n+        doc.end();\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar PDF:\", error);\r\n+        res.status(500).send(\"Erro ao gerar o relatório em PDF.\");\r\n+    }\r\n });\r\n \r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753534543023,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,14 @@\n const express = require('express');\r\n const router = express.Router();\r\n const mongoose = require('mongoose');\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const Boleto = require('../models/Boleto');\r\n-// CORREÇÃO: Importamos a função correta para gerar strings\r\n const { createObjectCsvStringifier } = require('csv-writer');\r\n const PDFDocument = require('pdfkit');\r\n \r\n-// Função de ajuda para obter o período de tempo (sem alterações)\r\n+// Importa o ESQUEMA do modelo\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n+\r\n+// A função getDateRange não muda\r\n function getDateRange(query) {\r\n     const { startDate, endDate } = query;\r\n     if (startDate && endDate) {\r\n         return {\r\n@@ -24,12 +24,15 @@\n         end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n     };\r\n }\r\n \r\n-// Função de ajuda para buscar os dados do relatório (sem alterações)\r\n-async function getReportData(companyId, dateRange) {\r\n+// A função getReportData agora recebe 'tenantDb' em vez de 'companyId'\r\n+async function getReportData(tenantDb, dateRange) {\r\n+    // Obtém o modelo 'Boleto' a partir da conexão da empresa\r\n+    const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n     return await Boleto.aggregate([\r\n-        { $match: { company: companyId } },\r\n+        // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n         { $unwind: '$parcels' },\r\n         { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n         { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n         { $sort: { 'parcels.dueDateObject': 1 } },\r\n@@ -47,14 +50,14 @@\n         }\r\n     ]);\r\n }\r\n \r\n-// Rota: GET /api/export/csv (VERSÃO FINAL E CORRIGIDA)\r\n-router.get('/csv', protect, async (req, res) => {\r\n+// Rota: GET /api/export/csv\r\n+router.get('/csv', async (req, res) => {\r\n     try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n         const dateRange = getDateRange(req.query);\r\n-        const data = await getReportData(companyId, dateRange);\r\n+        // Passa a conexão 'req.tenantDb' para a função\r\n+        const data = await getReportData(req.tenantDb, dateRange);\r\n \r\n         const records = data.map(item => ({\r\n             Data: item.Data || '',\r\n             Nome: item.Nome || 'N/A',\r\n@@ -63,9 +66,8 @@\n             Valor: (item.Valor || 0).toFixed(2).replace('.', ','),\r\n             Status: item.Status || 'N/A'\r\n         }));\r\n \r\n-        // CORREÇÃO: Usamos a função correta 'createObjectCsvStringifier'\r\n         const csvStringifier = createObjectCsvStringifier({\r\n             header: [\r\n                 { id: 'Data', title: 'DATA' },\r\n                 { id: 'Nome', title: 'NOME' },\r\n@@ -76,9 +78,8 @@\n             ],\r\n             fieldDelimiter: ';',\r\n         });\r\n \r\n-        // Agora estes métodos existem e vão funcionar\r\n         const csvString = csvStringifier.getHeaderString() + csvStringifier.stringifyRecords(records);\r\n \r\n         res.setHeader('Content-Disposition', 'attachment; filename=\"relatorio-despesas.csv\"');\r\n         res.setHeader('Content-Type', 'text/csv; charset=utf-8');\r\n@@ -91,29 +92,27 @@\n     }\r\n });\r\n \r\n // Rota: GET /api/export/pdf\r\n-router.get('/pdf', protect, async (req, res) => {\r\n+router.get('/pdf', async (req, res) => {\r\n     try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n         const dateRange = getDateRange(req.query);\r\n-        const data = await getReportData(companyId, dateRange);\r\n+        // Passa a conexão 'req.tenantDb' para a função\r\n+        const data = await getReportData(req.tenantDb, dateRange);\r\n \r\n-        // Define o nome do ficheiro para download\r\n         res.setHeader('Content-Disposition', 'attachment; filename=\"relatorio-despesas.pdf\"');\r\n         res.setHeader('Content-Type', 'application/pdf');\r\n \r\n         const doc = new PDFDocument({ margin: 30, size: 'A4' });\r\n         doc.pipe(res);\r\n \r\n-        // Cabeçalho do Documento\r\n+        // O restante da lógica de criação do PDF continua exatamente a mesma\r\n         doc.fontSize(18).text('Relatório de Despesas', { align: 'center' });\r\n         const dateOptions = { day: '2-digit', month: '2-digit', year: 'numeric' };\r\n         const periodStr = `${dateRange.start.toLocaleDateString('pt-BR', dateOptions)} a ${dateRange.end.toLocaleDateString('pt-BR', dateOptions)}`;\r\n         doc.fontSize(10).text(`Período: ${periodStr}`, { align: 'center' });\r\n         doc.moveDown(2);\r\n \r\n-        // Cabeçalho da Tabela\r\n         const tableTop = doc.y;\r\n         const colPositions = [30, 90, 240, 340, 420, 500];\r\n         const headers = ['Data', 'Nome', 'Parcela', 'Categoria', 'Valor', 'Status'];\r\n         headers.forEach((header, i) => {\r\n@@ -121,9 +120,8 @@\n         });\r\n         doc.moveTo(30, doc.y + 5).lineTo(565, doc.y + 5).stroke();\r\n         doc.moveDown();\r\n \r\n-        // Linhas da Tabela\r\n         data.forEach(item => {\r\n             const rowY = doc.y;\r\n             doc.fontSize(9).font('Helvetica').text(item.Data, colPositions[0], rowY);\r\n             doc.text(item.Nome, colPositions[1], rowY, { width: 140, ellipsis: true });\r\n@@ -141,6 +139,5 @@\n         res.status(500).send(\"Erro ao gerar o relatório em PDF.\");\r\n     }\r\n });\r\n \r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754506073777,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n const { createObjectCsvStringifier } = require('csv-writer');\r\n const PDFDocument = require('pdfkit');\r\n \r\n // Importa o ESQUEMA do modelo\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n+const { schema: BoletoSchema} = require('../models/Boleto');\r\n \r\n // A função getDateRange não muda\r\n function getDateRange(query) {\r\n     const { startDate, endDate } = query;\r\n"
                }
            ],
            "date": 1753363476139,
            "name": "Commit-0",
            "content": "// Crie este novo ficheiro: Servidor/routes/export.js\r\n\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst mongoose = require('mongoose');\r\nconst { protect } = require('../middleware/authMiddleware');\r\nconst Boleto = require('../models/Boleto');\r\nconst { createObjectCsvWriter } = require('csv-writer');\r\nconst PDFDocument = require('pdfkit');\r\n\r\n// Função de ajuda para obter o período de tempo (semelhante à de reports.js)\r\nfunction getDateRange(query) {\r\n    const { startDate, endDate } = query;\r\n    if (startDate && endDate) {\r\n        return {\r\n            start: new Date(startDate + 'T00:00:00.000Z'),\r\n            end: new Date(endDate + 'T23:59:59.999Z')\r\n        };\r\n    }\r\n    const today = new Date();\r\n    const year = today.getFullYear();\r\n    const month = today.getMonth();\r\n    return {\r\n        start: new Date(Date.UTC(year, month, 1)),\r\n        end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n    };\r\n}\r\n\r\n// Função de ajuda para buscar os dados do relatório\r\nasync function getReportData(companyId, dateRange) {\r\n    return await Boleto.aggregate([\r\n        { $match: { company: companyId } },\r\n        { $unwind: '$parcels' },\r\n        { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n        { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n        { $sort: { 'parcels.dueDateObject': 1 } },\r\n        { $lookup: { from: 'categories', localField: 'category', foreignField: '_id', as: 'categoryDetails' } },\r\n        {\r\n            $project: {\r\n                _id: 0,\r\n                Data: '$parcels.dueDate',\r\n                Nome: '$name',\r\n                Parcela: '$parcels.number',\r\n                Categoria: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'N/A' ] },\r\n                Valor: '$parcels.amount',\r\n                Status: { $cond: [{ $eq: ['$parcels.paid', true] }, 'Pago', 'Pendente'] }\r\n            }\r\n        }\r\n    ]);\r\n}\r\n\r\n// Rota: GET /api/export/csv\r\nrouter.get('/csv', protect, async (req, res) => {\r\n    try {\r\n        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n        const dateRange = getDateRange(req.query);\r\n        const data = await getReportData(companyId, dateRange);\r\n\r\n        // Define o nome do ficheiro para download\r\n        res.setHeader('Content-Disposition', 'attachment; filename=\"relatorio-despesas.csv\"');\r\n        res.setHeader('Content-Type', 'text/csv; charset=utf-8');\r\n\r\n        const csvWriter = createObjectCsvWriter({\r\n            path: res, // Escreve diretamente na resposta do servidor\r\n            header: [\r\n                { id: 'Data', title: 'DATA' },\r\n                { id: 'Nome', title: 'NOME' },\r\n                { id: 'Parcela', title: 'PARCELA' },\r\n                { id: 'Categoria', title: 'CATEGORIA' },\r\n                { id: 'Valor', title: 'VALOR' },\r\n                { id: 'Status', title: 'STATUS' }\r\n            ],\r\n            fieldDelimiter: ';', // Usa ponto e vírgula para compatibilidade com Excel em português\r\n        });\r\n\r\n        // Formata os dados para o CSV\r\n        const records = data.map(item => ({\r\n            ...item,\r\n            Valor: item.Valor.toFixed(2).replace('.', ',') // Formato de moeda para Excel PT\r\n        }));\r\n\r\n        await csvWriter.writeRecords(records);\r\n        res.end();\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro ao gerar CSV:\", error);\r\n        res.status(500).send(\"Erro ao gerar o relatório em CSV.\");\r\n    }\r\n});\r\n\r\n// Rota: GET /api/export/pdf\r\nrouter.get('/pdf', protect, async (req, res) => {\r\n    try {\r\n        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n        const dateRange = getDateRange(req.query);\r\n        const data = await getReportData(companyId, dateRange);\r\n\r\n        // Define o nome do ficheiro para download\r\n        res.setHeader('Content-Disposition', 'attachment; filename=\"relatorio-despesas.pdf\"');\r\n        res.setHeader('Content-Type', 'application/pdf');\r\n\r\n        const doc = new PDFDocument({ margin: 30, size: 'A4' });\r\n        doc.pipe(res);\r\n\r\n        // Cabeçalho do Documento\r\n        doc.fontSize(18).text('Relatório de Despesas', { align: 'center' });\r\n        const dateOptions = { day: '2-digit', month: '2-digit', year: 'numeric' };\r\n        const periodStr = `${dateRange.start.toLocaleDateString('pt-BR', dateOptions)} a ${dateRange.end.toLocaleDateString('pt-BR', dateOptions)}`;\r\n        doc.fontSize(10).text(`Período: ${periodStr}`, { align: 'center' });\r\n        doc.moveDown(2);\r\n\r\n        // Cabeçalho da Tabela\r\n        const tableTop = doc.y;\r\n        const colPositions = [30, 90, 240, 340, 420, 500];\r\n        const headers = ['Data', 'Nome', 'Parcela', 'Categoria', 'Valor', 'Status'];\r\n        headers.forEach((header, i) => {\r\n            doc.fontSize(10).font('Helvetica-Bold').text(header, colPositions[i], tableTop);\r\n        });\r\n        doc.moveTo(30, doc.y + 5).lineTo(565, doc.y + 5).stroke();\r\n        doc.moveDown();\r\n\r\n        // Linhas da Tabela\r\n        data.forEach(item => {\r\n            const rowY = doc.y;\r\n            doc.fontSize(9).font('Helvetica').text(item.Data, colPositions[0], rowY);\r\n            doc.text(item.Nome, colPositions[1], rowY, { width: 140, ellipsis: true });\r\n            doc.text(String(item.Parcela), colPositions[2], rowY);\r\n            doc.text(item.Categoria, colPositions[3], rowY);\r\n            doc.text(item.Valor.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }), colPositions[4], rowY, { align: 'right' });\r\n            doc.text(item.Status, colPositions[5], rowY);\r\n            doc.moveDown();\r\n        });\r\n\r\n        doc.end();\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro ao gerar PDF:\", error);\r\n        res.status(500).send(\"Erro ao gerar o relatório em PDF.\");\r\n    }\r\n});\r\n\r\n\r\nmodule.exports = router;"
        }
    ]
}