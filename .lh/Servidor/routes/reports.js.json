{
    "sourceFile": "Servidor/routes/reports.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1753280820026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753287659181,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,5 +50,44 @@\n         res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n     }\r\n });\r\n \r\n+// Retorna o total de despesas pagas nos últimos 6 meses.\r\n+router.get('/monthly-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+\r\n+        // Define a data de início (6 meses atrás)\r\n+        const sixMonthsAgo = new Date();\r\n+        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);\r\n+\r\n+        const summary = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            // Converte a string de data para um objeto de data do MongoDB\r\n+            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n+            // Filtra apenas as parcelas dos últimos 6 meses\r\n+            { $match: { convertedDate: { $gte: sixMonthsAgo } } },\r\n+            // Agrupa por ano e mês para somar os totais\r\n+            {\r\n+                $group: {\r\n+                    _id: {\r\n+                        year: { $year: '$convertedDate' },\r\n+                        month: { $month: '$convertedDate' }\r\n+                    },\r\n+                    totalAmount: { $sum: '$parcels.amount' }\r\n+                }\r\n+            },\r\n+            // Ordena o resultado por data\r\n+            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(summary);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753307961021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,146 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const Boleto = require('../models/Boleto');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// Rota: GET /api/reports/expenses-by-category\r\n+// Retorna o valor total pago para cada categoria da empresa do usuário.\r\n+router.get('/expenses-by-category', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+\r\n+        const report = await Boleto.aggregate([\r\n+            // 1. Encontra todos os boletos da empresa do usuário\r\n+            { $match: { company: companyId } },\r\n+            // 2. \"Desmonta\" o array de parcelas para processar cada uma individualmente\r\n+            { $unwind: '$parcels' },\r\n+            // 3. Filtra para pegar apenas as parcelas que foram pagas\r\n+            { $match: { 'parcels.paid': true } },\r\n+            // 4. Agrupa os resultados por categoria e soma os valores\r\n+            {\r\n+                $group: {\r\n+                    _id: '$category',\r\n+                    totalAmount: { $sum: '$parcels.amount' }\r\n+                }\r\n+            },\r\n+            // 5. Junta (\"lookup\") com a coleção de categorias para obter o nome\r\n+            {\r\n+                $lookup: {\r\n+                    from: 'categories',\r\n+                    localField: '_id',\r\n+                    foreignField: '_id',\r\n+                    as: 'categoryDetails'\r\n+                }\r\n+            },\r\n+            // 6. Formata a saída para ser mais amigável\r\n+            {\r\n+                $project: {\r\n+                    _id: 0,\r\n+                    categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] },\r\n+                    totalAmount: '$totalAmount'\r\n+                }\r\n+            }\r\n+        ]);\r\n+\r\n+        res.status(200).json(report);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n+    }\r\n+});\r\n+\r\n+// Retorna o total de despesas pagas nos últimos 6 meses.\r\n+router.get('/monthly-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+\r\n+        // Define a data de início (6 meses atrás)\r\n+        const sixMonthsAgo = new Date();\r\n+        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);\r\n+\r\n+        const summary = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            // Converte a string de data para um objeto de data do MongoDB\r\n+            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n+            // Filtra apenas as parcelas dos últimos 6 meses\r\n+            { $match: { convertedDate: { $gte: sixMonthsAgo } } },\r\n+            // Agrupa por ano e mês para somar os totais\r\n+            {\r\n+                $group: {\r\n+                    _id: {\r\n+                        year: { $year: '$convertedDate' },\r\n+                        month: { $month: '$convertedDate' }\r\n+                    },\r\n+                    totalAmount: { $sum: '$parcels.amount' }\r\n+                }\r\n+            },\r\n+            // Ordena o resultado por data\r\n+            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(summary);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota: GET /api/reports/kpi-summary\r\n+// Retorna um resumo dos principais KPIs para o dashboard.\r\n+router.get('/kpi-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const today = new Date();\r\n+        const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);\r\n+        const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59);\r\n+\r\n+        const result = await Boleto.aggregate([\r\n+            // 1. Encontra todos os boletos da empresa do utilizador\r\n+            { $match: { company: companyId } },\r\n+            \r\n+            // 2. \"Desmonta\" o array de parcelas para processar cada uma\r\n+            { $unwind: '$parcels' },\r\n+            \r\n+            // 3. Converte a data de vencimento de string para o tipo Date do MongoDB\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+\r\n+            // 4. Usa $facet para executar múltiplos cálculos de uma só vez\r\n+            {\r\n+                $facet: {\r\n+                    // Pipeline para \"Total a Pagar no Mês\"\r\n+                    totalMes: [\r\n+                        { $match: { 'parcels.dueDateObject': { $gte: startOfMonth, $lte: endOfMonth } } },\r\n+                        { $group: { _id: null, total: { $sum: '$parcels.amount' } } }\r\n+                    ],\r\n+                    // Pipeline para \"Total Pago no Mês\"\r\n+                    pagoMes: [\r\n+                        { $match: { \r\n+                            'parcels.paid': true,\r\n+                            'parcels.dueDateObject': { $gte: startOfMonth, $lte: endOfMonth }\r\n+                        }},\r\n+                        { $group: { _id: null, total: { $sum: '$parcels.amount' } } }\r\n+                    ]\r\n+                }\r\n+            }\r\n+        ]);\r\n+\r\n+        // 5. Formata o resultado para enviar ao frontend\r\n+        const kpis = {\r\n+            totalMes: result[0].totalMes[0]?.total || 0,\r\n+            pagoMes: result[0].pagoMes[0]?.total || 0,\r\n+        };\r\n+\r\n+        res.status(200).json(kpis);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753314081212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,141 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const Boleto = require('../models/Boleto');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// Rota: GET /api/reports/expenses-by-category\r\n+// Retorna o valor total pago para cada categoria da empresa do usuário.\r\n+router.get('/expenses-by-category', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+\r\n+        const report = await Boleto.aggregate([\r\n+            // 1. Encontra todos os boletos da empresa do usuário\r\n+            { $match: { company: companyId } },\r\n+            // 2. \"Desmonta\" o array de parcelas para processar cada uma individualmente\r\n+            { $unwind: '$parcels' },\r\n+            // 3. Filtra para pegar apenas as parcelas que foram pagas\r\n+            { $match: { 'parcels.paid': true } },\r\n+            // 4. Agrupa os resultados por categoria e soma os valores\r\n+            {\r\n+                $group: {\r\n+                    _id: '$category',\r\n+                    totalAmount: { $sum: '$parcels.amount' }\r\n+                }\r\n+            },\r\n+            // 5. Junta (\"lookup\") com a coleção de categorias para obter o nome\r\n+            {\r\n+                $lookup: {\r\n+                    from: 'categories',\r\n+                    localField: '_id',\r\n+                    foreignField: '_id',\r\n+                    as: 'categoryDetails'\r\n+                }\r\n+            },\r\n+            // 6. Formata a saída para ser mais amigável\r\n+            {\r\n+                $project: {\r\n+                    _id: 0,\r\n+                    categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] },\r\n+                    totalAmount: '$totalAmount'\r\n+                }\r\n+            }\r\n+        ]);\r\n+\r\n+        res.status(200).json(report);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n+    }\r\n+});\r\n+\r\n+// Retorna o total de despesas pagas nos últimos 6 meses.\r\n+router.get('/monthly-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+\r\n+        // Define a data de início (6 meses atrás)\r\n+        const sixMonthsAgo = new Date();\r\n+        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);\r\n+\r\n+        const summary = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            // Converte a string de data para um objeto de data do MongoDB\r\n+            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n+            // Filtra apenas as parcelas dos últimos 6 meses\r\n+            { $match: { convertedDate: { $gte: sixMonthsAgo } } },\r\n+            // Agrupa por ano e mês para somar os totais\r\n+            {\r\n+                $group: {\r\n+                    _id: {\r\n+                        year: { $year: '$convertedDate' },\r\n+                        month: { $month: '$convertedDate' }\r\n+                    },\r\n+                    totalAmount: { $sum: '$parcels.amount' }\r\n+                }\r\n+            },\r\n+            // Ordena o resultado por data\r\n+            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(summary);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota: GET /api/reports/kpi-summary\r\n+// Retorna um resumo dos principais KPIs para o dashboard.\r\n+router.get('/kpi-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const today = new Date();\r\n+        const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);\r\n+        const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59);\r\n+\r\n+        // Pipeline otimizado para calcular os totais do mês\r\n+        const monthTotals = await Boleto.aggregate([\r\n+            // 1. Filtra os boletos da empresa\r\n+            { $match: { company: companyId } },\r\n+            // 2. \"Desmonta\" o array de parcelas para processar cada uma individualmente\r\n+            { $unwind: '$parcels' },\r\n+            // 3. Adiciona um campo de data real para filtragem\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            // 4. Filtra apenas as parcelas que vencem NO MÊS ATUAL\r\n+            { $match: { 'parcels.dueDateObject': { $gte: startOfMonth, $lte: endOfMonth } } },\r\n+            // 5. Agrupa os resultados e calcula TUDO de uma só vez\r\n+            {\r\n+                $group: {\r\n+                    _id: null, // Agrupa todos os resultados num só documento\r\n+                    totalMes: { $sum: '$parcels.amount' }, // Soma o valor de todas as parcelas encontradas\r\n+                    pagoMes: {\r\n+                        // Soma o valor apenas se 'parcels.paid' for true\r\n+                        $sum: {\r\n+                            $cond: [{ $eq: ['$parcels.paid', true] }, '$parcels.amount', 0]\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        ]);\r\n+\r\n+        // Formata o resultado para enviar ao frontend\r\n+        const kpis = {\r\n+            totalMes: monthTotals[0]?.totalMes || 0,\r\n+            pagoMes: monthTotals[0]?.pagoMes || 0,\r\n+        };\r\n+\r\n+        res.status(200).json(kpis);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753314412810,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,38 +94,37 @@\n // Retorna um resumo dos principais KPIs para o dashboard.\r\n router.get('/kpi-summary', protect, async (req, res) => {\r\n     try {\r\n         const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        \r\n+        // --- LÓGICA DE DATAS CORRIGIDA ---\r\n         const today = new Date();\r\n-        const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);\r\n-        const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59);\r\n+        const year = today.getFullYear();\r\n+        const month = today.getMonth(); // 0 para Janeiro, 6 para Julho, etc.\r\n \r\n-        // Pipeline otimizado para calcular os totais do mês\r\n+        // Cria as datas de início e fim diretamente em UTC para evitar problemas de fuso horário.\r\n+        const startOfMonth = new Date(Date.UTC(year, month, 1));\r\n+        const endOfMonth = new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999));\r\n+        // ------------------------------------\r\n+\r\n         const monthTotals = await Boleto.aggregate([\r\n-            // 1. Filtra os boletos da empresa\r\n             { $match: { company: companyId } },\r\n-            // 2. \"Desmonta\" o array de parcelas para processar cada uma individualmente\r\n             { $unwind: '$parcels' },\r\n-            // 3. Adiciona um campo de data real para filtragem\r\n             { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            // 4. Filtra apenas as parcelas que vencem NO MÊS ATUAL\r\n             { $match: { 'parcels.dueDateObject': { $gte: startOfMonth, $lte: endOfMonth } } },\r\n-            // 5. Agrupa os resultados e calcula TUDO de uma só vez\r\n             {\r\n                 $group: {\r\n-                    _id: null, // Agrupa todos os resultados num só documento\r\n-                    totalMes: { $sum: '$parcels.amount' }, // Soma o valor de todas as parcelas encontradas\r\n+                    _id: null,\r\n+                    totalMes: { $sum: '$parcels.amount' },\r\n                     pagoMes: {\r\n-                        // Soma o valor apenas se 'parcels.paid' for true\r\n                         $sum: {\r\n                             $cond: [{ $eq: ['$parcels.paid', true] }, '$parcels.amount', 0]\r\n                         }\r\n                     }\r\n                 }\r\n             }\r\n         ]);\r\n \r\n-        // Formata o resultado para enviar ao frontend\r\n         const kpis = {\r\n             totalMes: monthTotals[0]?.totalMes || 0,\r\n             pagoMes: monthTotals[0]?.pagoMes || 0,\r\n         };\r\n@@ -137,244 +136,5 @@\n         res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n     }\r\n });\r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const Boleto = require('../models/Boleto');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// Rota: GET /api/reports/expenses-by-category\r\n-// Retorna o valor total pago para cada categoria da empresa do usuário.\r\n-router.get('/expenses-by-category', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-\r\n-        const report = await Boleto.aggregate([\r\n-            // 1. Encontra todos os boletos da empresa do usuário\r\n-            { $match: { company: companyId } },\r\n-            // 2. \"Desmonta\" o array de parcelas para processar cada uma individualmente\r\n-            { $unwind: '$parcels' },\r\n-            // 3. Filtra para pegar apenas as parcelas que foram pagas\r\n-            { $match: { 'parcels.paid': true } },\r\n-            // 4. Agrupa os resultados por categoria e soma os valores\r\n-            {\r\n-                $group: {\r\n-                    _id: '$category',\r\n-                    totalAmount: { $sum: '$parcels.amount' }\r\n-                }\r\n-            },\r\n-            // 5. Junta (\"lookup\") com a coleção de categorias para obter o nome\r\n-            {\r\n-                $lookup: {\r\n-                    from: 'categories',\r\n-                    localField: '_id',\r\n-                    foreignField: '_id',\r\n-                    as: 'categoryDetails'\r\n-                }\r\n-            },\r\n-            // 6. Formata a saída para ser mais amigável\r\n-            {\r\n-                $project: {\r\n-                    _id: 0,\r\n-                    categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] },\r\n-                    totalAmount: '$totalAmount'\r\n-                }\r\n-            }\r\n-        ]);\r\n-\r\n-        res.status(200).json(report);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n-    }\r\n-});\r\n-\r\n-// Retorna o total de despesas pagas nos últimos 6 meses.\r\n-router.get('/monthly-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-\r\n-        // Define a data de início (6 meses atrás)\r\n-        const sixMonthsAgo = new Date();\r\n-        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);\r\n-\r\n-        const summary = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n-            // Converte a string de data para um objeto de data do MongoDB\r\n-            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n-            // Filtra apenas as parcelas dos últimos 6 meses\r\n-            { $match: { convertedDate: { $gte: sixMonthsAgo } } },\r\n-            // Agrupa por ano e mês para somar os totais\r\n-            {\r\n-                $group: {\r\n-                    _id: {\r\n-                        year: { $year: '$convertedDate' },\r\n-                        month: { $month: '$convertedDate' }\r\n-                    },\r\n-                    totalAmount: { $sum: '$parcels.amount' }\r\n-                }\r\n-            },\r\n-            // Ordena o resultado por data\r\n-            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n-        ]);\r\n-\r\n-        res.status(200).json(summary);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota: GET /api/reports/kpi-summary\r\n-// Retorna um resumo dos principais KPIs para o dashboard.\r\n-router.get('/kpi-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        const today = new Date();\r\n-        const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);\r\n-        const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59);\r\n-\r\n-        const result = await Boleto.aggregate([\r\n-            // 1. Encontra todos os boletos da empresa do utilizador\r\n-            { $match: { company: companyId } },\r\n-            \r\n-            // 2. \"Desmonta\" o array de parcelas para processar cada uma\r\n-            { $unwind: '$parcels' },\r\n-            \r\n-            // 3. Converte a data de vencimento de string para o tipo Date do MongoDB\r\n-            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-\r\n-            // 4. Usa $facet para executar múltiplos cálculos de uma só vez\r\n-            {\r\n-                $facet: {\r\n-                    // Pipeline para \"Total a Pagar no Mês\"\r\n-                    totalMes: [\r\n-                        { $match: { 'parcels.dueDateObject': { $gte: startOfMonth, $lte: endOfMonth } } },\r\n-                        { $group: { _id: null, total: { $sum: '$parcels.amount' } } }\r\n-                    ],\r\n-                    // Pipeline para \"Total Pago no Mês\"\r\n-                    pagoMes: [\r\n-                        { $match: { \r\n-                            'parcels.paid': true,\r\n-                            'parcels.dueDateObject': { $gte: startOfMonth, $lte: endOfMonth }\r\n-                        }},\r\n-                        { $group: { _id: null, total: { $sum: '$parcels.amount' } } }\r\n-                    ]\r\n-                }\r\n-            }\r\n-        ]);\r\n-\r\n-        // 5. Formata o resultado para enviar ao frontend\r\n-        const kpis = {\r\n-            totalMes: result[0].totalMes[0]?.total || 0,\r\n-            pagoMes: result[0].pagoMes[0]?.total || 0,\r\n-        };\r\n-\r\n-        res.status(200).json(kpis);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const Boleto = require('../models/Boleto');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// Rota: GET /api/reports/expenses-by-category\r\n-// Retorna o valor total pago para cada categoria da empresa do usuário.\r\n-router.get('/expenses-by-category', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-\r\n-        const report = await Boleto.aggregate([\r\n-            // 1. Encontra todos os boletos da empresa do usuário\r\n-            { $match: { company: companyId } },\r\n-            // 2. \"Desmonta\" o array de parcelas para processar cada uma individualmente\r\n-            { $unwind: '$parcels' },\r\n-            // 3. Filtra para pegar apenas as parcelas que foram pagas\r\n-            { $match: { 'parcels.paid': true } },\r\n-            // 4. Agrupa os resultados por categoria e soma os valores\r\n-            {\r\n-                $group: {\r\n-                    _id: '$category',\r\n-                    totalAmount: { $sum: '$parcels.amount' }\r\n-                }\r\n-            },\r\n-            // 5. Junta (\"lookup\") com a coleção de categorias para obter o nome\r\n-            {\r\n-                $lookup: {\r\n-                    from: 'categories',\r\n-                    localField: '_id',\r\n-                    foreignField: '_id',\r\n-                    as: 'categoryDetails'\r\n-                }\r\n-            },\r\n-            // 6. Formata a saída para ser mais amigável\r\n-            {\r\n-                $project: {\r\n-                    _id: 0,\r\n-                    categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] },\r\n-                    totalAmount: '$totalAmount'\r\n-                }\r\n-            }\r\n-        ]);\r\n-\r\n-        res.status(200).json(report);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n-    }\r\n-});\r\n-\r\n-// Retorna o total de despesas pagas nos últimos 6 meses.\r\n-router.get('/monthly-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-\r\n-        // Define a data de início (6 meses atrás)\r\n-        const sixMonthsAgo = new Date();\r\n-        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);\r\n-\r\n-        const summary = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n-            // Converte a string de data para um objeto de data do MongoDB\r\n-            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n-            // Filtra apenas as parcelas dos últimos 6 meses\r\n-            { $match: { convertedDate: { $gte: sixMonthsAgo } } },\r\n-            // Agrupa por ano e mês para somar os totais\r\n-            {\r\n-                $group: {\r\n-                    _id: {\r\n-                        year: { $year: '$convertedDate' },\r\n-                        month: { $month: '$convertedDate' }\r\n-                    },\r\n-                    totalAmount: { $sum: '$parcels.amount' }\r\n-                }\r\n-            },\r\n-            // Ordena o resultado por data\r\n-            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n-        ]);\r\n-\r\n-        res.status(200).json(summary);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n-    }\r\n-});\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753314733289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,116 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const Boleto = require('../models/Boleto');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO\r\n+// Esta função centraliza a lógica para determinar o intervalo de datas\r\n+function getDateRange(query) {\r\n+    const { startDate, endDate } = query;\r\n+    if (startDate && endDate) {\r\n+        return {\r\n+            start: new Date(Date.UTC.parse(startDate + 'T00:00:00.000Z')),\r\n+            end: new Date(Date.UTC.parse(endDate + 'T23:59:59.999Z'))\r\n+        };\r\n+    }\r\n+    // Se não forem fornecidas datas, o padrão é o mês corrente\r\n+    const today = new Date();\r\n+    const year = today.getFullYear();\r\n+    const month = today.getMonth();\r\n+    return {\r\n+        start: new Date(Date.UTC(year, month, 1)),\r\n+        end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n+    };\r\n+}\r\n+\r\n+\r\n+// Rota: GET /api/reports/expenses-by-category\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/expenses-by-category', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        const report = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            // ETAPA ADICIONADA: Filtra as parcelas pelo período de tempo\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            // O resto da consulta continua igual\r\n+            { $group: { _id: '$category', totalAmount: { $sum: '$parcels.amount' } } },\r\n+            { $lookup: { from: 'categories', localField: '_id', foreignField: '_id', as: 'categoryDetails' } },\r\n+            { $project: { _id: 0, categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] }, totalAmount: '$totalAmount' } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(report);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota: GET /api/reports/monthly-summary\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/monthly-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        // MODIFICADO: A data de início já não é fixa em \"6 meses atrás\"\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        const summary = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n+            // ETAPA MODIFICADA: Filtra as parcelas pelo período fornecido\r\n+            { $match: { convertedDate: { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            { $group: { _id: { year: { $year: '$convertedDate' }, month: { $month: '$convertedDate' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n+            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(summary);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota: GET /api/reports/kpi-summary\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/kpi-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        // ETAPA MODIFICADA: Usamos a nossa função de ajuda\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        const monthTotals = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            // ETAPA MODIFICADA: O filtro agora usa o nosso intervalo de datas dinâmico\r\n+            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            {\r\n+                $group: {\r\n+                    _id: null,\r\n+                    totalMes: { $sum: '$parcels.amount' },\r\n+                    pagoMes: { $sum: { $cond: [{ $eq: ['$parcels.paid', true] }, '$parcels.amount', 0] } }\r\n+                }\r\n+            }\r\n+        ]);\r\n+\r\n+        const kpis = {\r\n+            totalMes: monthTotals[0]?.totalMes || 0,\r\n+            pagoMes: monthTotals[0]?.pagoMes || 0,\r\n+        };\r\n+\r\n+        res.status(200).json(kpis);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753315099170,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,117 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const Boleto = require('../models/Boleto');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO\r\n+// Esta função centraliza a lógica para determinar o intervalo de datas\r\n+function getDateRange(query) {\r\n+    const { startDate, endDate } = query;\r\n+    if (startDate && endDate) {\r\n+        // CORREÇÃO: Usamos o formato ISO 8601 com 'Z' para criar a data diretamente em UTC.\r\n+        return {\r\n+            start: new Date(startDate + 'T00:00:00.000Z'),\r\n+            end: new Date(endDate + 'T23:59:59.999Z')\r\n+        };\r\n+    }\r\n+    // O padrão para o mês corrente continua igual e já estava correto.\r\n+    const today = new Date();\r\n+    const year = today.getFullYear();\r\n+    const month = today.getMonth();\r\n+    return {\r\n+        start: new Date(Date.UTC(year, month, 1)),\r\n+        end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n+    };\r\n+}\r\n+\r\n+\r\n+// Rota: GET /api/reports/expenses-by-category\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/expenses-by-category', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        const report = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            // ETAPA ADICIONADA: Filtra as parcelas pelo período de tempo\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            // O resto da consulta continua igual\r\n+            { $group: { _id: '$category', totalAmount: { $sum: '$parcels.amount' } } },\r\n+            { $lookup: { from: 'categories', localField: '_id', foreignField: '_id', as: 'categoryDetails' } },\r\n+            { $project: { _id: 0, categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] }, totalAmount: '$totalAmount' } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(report);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota: GET /api/reports/monthly-summary\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/monthly-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        // MODIFICADO: A data de início já não é fixa em \"6 meses atrás\"\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        const summary = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n+            // ETAPA MODIFICADA: Filtra as parcelas pelo período fornecido\r\n+            { $match: { convertedDate: { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            { $group: { _id: { year: { $year: '$convertedDate' }, month: { $month: '$convertedDate' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n+            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(summary);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota: GET /api/reports/kpi-summary\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/kpi-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        // ETAPA MODIFICADA: Usamos a nossa função de ajuda\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        const monthTotals = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            // ETAPA MODIFICADA: O filtro agora usa o nosso intervalo de datas dinâmico\r\n+            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            {\r\n+                $group: {\r\n+                    _id: null,\r\n+                    totalMes: { $sum: '$parcels.amount' },\r\n+                    pagoMes: { $sum: { $cond: [{ $eq: ['$parcels.paid', true] }, '$parcels.amount', 0] } }\r\n+                }\r\n+            }\r\n+        ]);\r\n+\r\n+        const kpis = {\r\n+            totalMes: monthTotals[0]?.totalMes || 0,\r\n+            pagoMes: monthTotals[0]?.pagoMes || 0,\r\n+        };\r\n+\r\n+        res.status(200).json(kpis);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753315300784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,131 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const Boleto = require('../models/Boleto');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO\r\n+// Esta função centraliza a lógica para determinar o intervalo de datas\r\n+function getDateRange(query) {\r\n+    const { startDate, endDate } = query;\r\n+    if (startDate && endDate) {\r\n+        // CORREÇÃO: Usamos o formato ISO 8601 com 'Z' para criar a data diretamente em UTC.\r\n+        return {\r\n+            start: new Date(startDate + 'T00:00:00.000Z'),\r\n+            end: new Date(endDate + 'T23:59:59.999Z')\r\n+        };\r\n+    }\r\n+    // O padrão para o mês corrente continua igual e já estava correto.\r\n+    const today = new Date();\r\n+    const year = today.getFullYear();\r\n+    const month = today.getMonth();\r\n+    return {\r\n+        start: new Date(Date.UTC(year, month, 1)),\r\n+        end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n+    };\r\n+}\r\n+\r\n+\r\n+// Rota: GET /api/reports/expenses-by-category\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/expenses-by-category', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        const report = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            // ETAPA ADICIONADA: Filtra as parcelas pelo período de tempo\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            // O resto da consulta continua igual\r\n+            { $group: { _id: '$category', totalAmount: { $sum: '$parcels.amount' } } },\r\n+            { $lookup: { from: 'categories', localField: '_id', foreignField: '_id', as: 'categoryDetails' } },\r\n+            { $project: { _id: 0, categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] }, totalAmount: '$totalAmount' } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(report);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota: GET /api/reports/monthly-summary\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/monthly-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        // MODIFICADO: A data de início já não é fixa em \"6 meses atrás\"\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        const summary = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n+            // ETAPA MODIFICADA: Filtra as parcelas pelo período fornecido\r\n+            { $match: { convertedDate: { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            { $group: { _id: { year: { $year: '$convertedDate' }, month: { $month: '$convertedDate' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n+            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(summary);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota: GET /api/reports/kpi-summary\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/kpi-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        // Query 1: Calcula os totais para o período selecionado\r\n+        const periodTotals = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            {\r\n+                $group: {\r\n+                    _id: null,\r\n+                    totalMes: { $sum: '$parcels.amount' },\r\n+                    pagoMes: { $sum: { $cond: [{ $eq: ['$parcels.paid', true] }, '$parcels.amount', 0] } }\r\n+                }\r\n+            }\r\n+        ]);\r\n+        \r\n+        // Query 2: Calcula o total GERAL de contas vencidas (não depende do período)\r\n+        const overdueTotal = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            { $match: { \r\n+                'parcels.paid': false,\r\n+                'parcels.dueDateObject': { $lt: new Date(Date.now()) } // Data de vencimento é anterior a agora\r\n+            }},\r\n+            { $group: { _id: null, totalVencido: { $sum: '$parcels.amount' } } }\r\n+        ]);\r\n+\r\n+        // Combina os resultados das duas queries\r\n+        const kpis = {\r\n+            totalMes: periodTotals[0]?.totalMes || 0,\r\n+            pagoMes: periodTotals[0]?.pagoMes || 0,\r\n+            totalVencido: overdueTotal[0]?.totalVencido || 0,\r\n+        };\r\n+\r\n+        res.status(200).json(kpis);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753315847814,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,175 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const Boleto = require('../models/Boleto');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO\r\n+// Esta função centraliza a lógica para determinar o intervalo de datas\r\n+function getDateRange(query) {\r\n+    const { startDate, endDate } = query;\r\n+    if (startDate && endDate) {\r\n+        // CORREÇÃO: Usamos o formato ISO 8601 com 'Z' para criar a data diretamente em UTC.\r\n+        return {\r\n+            start: new Date(startDate + 'T00:00:00.000Z'),\r\n+            end: new Date(endDate + 'T23:59:59.999Z')\r\n+        };\r\n+    }\r\n+    // O padrão para o mês corrente continua igual e já estava correto.\r\n+    const today = new Date();\r\n+    const year = today.getFullYear();\r\n+    const month = today.getMonth();\r\n+    return {\r\n+        start: new Date(Date.UTC(year, month, 1)),\r\n+        end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n+    };\r\n+}\r\n+\r\n+\r\n+// Rota: GET /api/reports/expenses-by-category\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/expenses-by-category', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        const report = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            // ETAPA ADICIONADA: Filtra as parcelas pelo período de tempo\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            // O resto da consulta continua igual\r\n+            { $group: { _id: '$category', totalAmount: { $sum: '$parcels.amount' } } },\r\n+            { $lookup: { from: 'categories', localField: '_id', foreignField: '_id', as: 'categoryDetails' } },\r\n+            { $project: { _id: 0, categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] }, totalAmount: '$totalAmount' } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(report);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota: GET /api/reports/monthly-summary\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/monthly-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        // MODIFICADO: A data de início já não é fixa em \"6 meses atrás\"\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        const summary = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': true } },\r\n+            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n+            // ETAPA MODIFICADA: Filtra as parcelas pelo período fornecido\r\n+            { $match: { convertedDate: { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            { $group: { _id: { year: { $year: '$convertedDate' }, month: { $month: '$convertedDate' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n+            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n+        ]);\r\n+\r\n+        res.status(200).json(summary);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota: GET /api/reports/kpi-summary\r\n+// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n+router.get('/kpi-summary', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const dateRange = getDateRange(req.query);\r\n+\r\n+        // Query 1: Calcula os totais para o período selecionado\r\n+        const periodTotals = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+            {\r\n+                $group: {\r\n+                    _id: null,\r\n+                    totalMes: { $sum: '$parcels.amount' },\r\n+                    pagoMes: { $sum: { $cond: [{ $eq: ['$parcels.paid', true] }, '$parcels.amount', 0] } }\r\n+                }\r\n+            }\r\n+        ]);\r\n+        \r\n+        // Query 2: Calcula o total GERAL de contas vencidas (não depende do período)\r\n+        const overdueTotal = await Boleto.aggregate([\r\n+            { $match: { company: companyId } },\r\n+            { $unwind: '$parcels' },\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            { $match: { \r\n+                'parcels.paid': false,\r\n+                'parcels.dueDateObject': { $lt: new Date(Date.now()) } // Data de vencimento é anterior a agora\r\n+            }},\r\n+            { $group: { _id: null, totalVencido: { $sum: '$parcels.amount' } } }\r\n+        ]);\r\n+\r\n+        // Combina os resultados das duas queries\r\n+        const kpis = {\r\n+            totalMes: periodTotals[0]?.totalMes || 0,\r\n+            pagoMes: periodTotals[0]?.pagoMes || 0,\r\n+            totalVencido: overdueTotal[0]?.totalVencido || 0,\r\n+        };\r\n+\r\n+        res.status(200).json(kpis);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n+    }\r\n+});\r\n+\r\n+// Retorna as próximas 5 parcelas não pagas que estão para vencer.\r\n+router.get('/upcoming-payments', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const today = new Date();\r\n+        // Definimos o início de hoje em UTC para garantir a consistência da consulta\r\n+        today.setUTCHours(0, 0, 0, 0);\r\n+\r\n+        const upcoming = await Boleto.aggregate([\r\n+            // 1. Filtra os boletos da empresa\r\n+            { $match: { company: companyId } },\r\n+            // 2. \"Desmonta\" o array de parcelas\r\n+            { $unwind: '$parcels' },\r\n+            // 3. Converte a data para um objeto de data real\r\n+            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+            // 4. Filtra apenas as parcelas NÃO PAGAS e com vencimento A PARTIR DE HOJE\r\n+            { $match: {\r\n+                'parcels.paid': false,\r\n+                'parcels.dueDateObject': { $gte: today }\r\n+            }},\r\n+            // 5. Ordena pela data de vencimento mais próxima\r\n+            { $sort: { 'parcels.dueDateObject': 1 } },\r\n+            // 6. Limita o resultado a apenas 5 parcelas\r\n+            { $limit: 5 },\r\n+            // 7. Formata o resultado para ser mais fácil de usar no frontend\r\n+            {\r\n+                $project: {\r\n+                    _id: 0,\r\n+                    billName: '$name',\r\n+                    parcelNumber: '$parcels.number',\r\n+                    amount: '$parcels.amount',\r\n+                    dueDate: '$parcels.dueDate'\r\n+                }\r\n+            }\r\n+        ]);\r\n+\r\n+        res.status(200).json(upcoming);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar próximos vencimentos:\", error);\r\n+        res.status(500).json({ message: \"Erro interno ao buscar próximos vencimentos.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753475585025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,17 +31,26 @@\n router.get('/expenses-by-category', protect, async (req, res) => {\r\n     try {\r\n         const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n         const dateRange = getDateRange(req.query);\r\n+        const { status } = req.query; // Novo: Pega o status do filtro\r\n \r\n+        // Define o filtro de status (pago/não pago/todos)\r\n+        let paidMatch = {};\r\n+        if (status === 'paid') {\r\n+            paidMatch = { 'parcels.paid': true };\r\n+        } else if (status === 'unpaid') {\r\n+            paidMatch = { 'parcels.paid': false };\r\n+        }\r\n+        // Se 'status' for 'all' ou indefinido, paidMatch continua como {}, sem filtrar.\r\n+\r\n         const report = await Boleto.aggregate([\r\n             { $match: { company: companyId } },\r\n             { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n-            // ETAPA ADICIONADA: Filtra as parcelas pelo período de tempo\r\n+            // A linha abaixo foi MODIFICADA para usar o filtro dinâmico\r\n+            { $match: paidMatch },\r\n             { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n             { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            // O resto da consulta continua igual\r\n             { $group: { _id: '$category', totalAmount: { $sum: '$parcels.amount' } } },\r\n             { $lookup: { from: 'categories', localField: '_id', foreignField: '_id', as: 'categoryDetails' } },\r\n             { $project: { _id: 0, categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] }, totalAmount: '$totalAmount' } }\r\n         ]);\r\n@@ -171,509 +180,5 @@\n         res.status(500).json({ message: \"Erro interno ao buscar próximos vencimentos.\" });\r\n     }\r\n });\r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const Boleto = require('../models/Boleto');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO\r\n-// Esta função centraliza a lógica para determinar o intervalo de datas\r\n-function getDateRange(query) {\r\n-    const { startDate, endDate } = query;\r\n-    if (startDate && endDate) {\r\n-        // CORREÇÃO: Usamos o formato ISO 8601 com 'Z' para criar a data diretamente em UTC.\r\n-        return {\r\n-            start: new Date(startDate + 'T00:00:00.000Z'),\r\n-            end: new Date(endDate + 'T23:59:59.999Z')\r\n-        };\r\n-    }\r\n-    // O padrão para o mês corrente continua igual e já estava correto.\r\n-    const today = new Date();\r\n-    const year = today.getFullYear();\r\n-    const month = today.getMonth();\r\n-    return {\r\n-        start: new Date(Date.UTC(year, month, 1)),\r\n-        end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n-    };\r\n-}\r\n-\r\n-\r\n-// Rota: GET /api/reports/expenses-by-category\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/expenses-by-category', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        const dateRange = getDateRange(req.query);\r\n-\r\n-        const report = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n-            // ETAPA ADICIONADA: Filtra as parcelas pelo período de tempo\r\n-            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            // O resto da consulta continua igual\r\n-            { $group: { _id: '$category', totalAmount: { $sum: '$parcels.amount' } } },\r\n-            { $lookup: { from: 'categories', localField: '_id', foreignField: '_id', as: 'categoryDetails' } },\r\n-            { $project: { _id: 0, categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] }, totalAmount: '$totalAmount' } }\r\n-        ]);\r\n-\r\n-        res.status(200).json(report);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota: GET /api/reports/monthly-summary\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/monthly-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        // MODIFICADO: A data de início já não é fixa em \"6 meses atrás\"\r\n-        const dateRange = getDateRange(req.query);\r\n-\r\n-        const summary = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n-            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n-            // ETAPA MODIFICADA: Filtra as parcelas pelo período fornecido\r\n-            { $match: { convertedDate: { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            { $group: { _id: { year: { $year: '$convertedDate' }, month: { $month: '$convertedDate' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n-            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n-        ]);\r\n-\r\n-        res.status(200).json(summary);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota: GET /api/reports/kpi-summary\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/kpi-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        const dateRange = getDateRange(req.query);\r\n-\r\n-        // Query 1: Calcula os totais para o período selecionado\r\n-        const periodTotals = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            {\r\n-                $group: {\r\n-                    _id: null,\r\n-                    totalMes: { $sum: '$parcels.amount' },\r\n-                    pagoMes: { $sum: { $cond: [{ $eq: ['$parcels.paid', true] }, '$parcels.amount', 0] } }\r\n-                }\r\n-            }\r\n-        ]);\r\n-        \r\n-        // Query 2: Calcula o total GERAL de contas vencidas (não depende do período)\r\n-        const overdueTotal = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            { $match: { \r\n-                'parcels.paid': false,\r\n-                'parcels.dueDateObject': { $lt: new Date(Date.now()) } // Data de vencimento é anterior a agora\r\n-            }},\r\n-            { $group: { _id: null, totalVencido: { $sum: '$parcels.amount' } } }\r\n-        ]);\r\n-\r\n-        // Combina os resultados das duas queries\r\n-        const kpis = {\r\n-            totalMes: periodTotals[0]?.totalMes || 0,\r\n-            pagoMes: periodTotals[0]?.pagoMes || 0,\r\n-            totalVencido: overdueTotal[0]?.totalVencido || 0,\r\n-        };\r\n-\r\n-        res.status(200).json(kpis);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const Boleto = require('../models/Boleto');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO\r\n-// Esta função centraliza a lógica para determinar o intervalo de datas\r\n-function getDateRange(query) {\r\n-    const { startDate, endDate } = query;\r\n-    if (startDate && endDate) {\r\n-        // CORREÇÃO: Usamos o formato ISO 8601 com 'Z' para criar a data diretamente em UTC.\r\n-        return {\r\n-            start: new Date(startDate + 'T00:00:00.000Z'),\r\n-            end: new Date(endDate + 'T23:59:59.999Z')\r\n-        };\r\n-    }\r\n-    // O padrão para o mês corrente continua igual e já estava correto.\r\n-    const today = new Date();\r\n-    const year = today.getFullYear();\r\n-    const month = today.getMonth();\r\n-    return {\r\n-        start: new Date(Date.UTC(year, month, 1)),\r\n-        end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n-    };\r\n-}\r\n-\r\n-\r\n-// Rota: GET /api/reports/expenses-by-category\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/expenses-by-category', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        const dateRange = getDateRange(req.query);\r\n-\r\n-        const report = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n-            // ETAPA ADICIONADA: Filtra as parcelas pelo período de tempo\r\n-            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            // O resto da consulta continua igual\r\n-            { $group: { _id: '$category', totalAmount: { $sum: '$parcels.amount' } } },\r\n-            { $lookup: { from: 'categories', localField: '_id', foreignField: '_id', as: 'categoryDetails' } },\r\n-            { $project: { _id: 0, categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] }, totalAmount: '$totalAmount' } }\r\n-        ]);\r\n-\r\n-        res.status(200).json(report);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota: GET /api/reports/monthly-summary\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/monthly-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        // MODIFICADO: A data de início já não é fixa em \"6 meses atrás\"\r\n-        const dateRange = getDateRange(req.query);\r\n-\r\n-        const summary = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n-            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n-            // ETAPA MODIFICADA: Filtra as parcelas pelo período fornecido\r\n-            { $match: { convertedDate: { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            { $group: { _id: { year: { $year: '$convertedDate' }, month: { $month: '$convertedDate' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n-            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n-        ]);\r\n-\r\n-        res.status(200).json(summary);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota: GET /api/reports/kpi-summary\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/kpi-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        // ETAPA MODIFICADA: Usamos a nossa função de ajuda\r\n-        const dateRange = getDateRange(req.query);\r\n-\r\n-        const monthTotals = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            // ETAPA MODIFICADA: O filtro agora usa o nosso intervalo de datas dinâmico\r\n-            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            {\r\n-                $group: {\r\n-                    _id: null,\r\n-                    totalMes: { $sum: '$parcels.amount' },\r\n-                    pagoMes: { $sum: { $cond: [{ $eq: ['$parcels.paid', true] }, '$parcels.amount', 0] } }\r\n-                }\r\n-            }\r\n-        ]);\r\n-\r\n-        const kpis = {\r\n-            totalMes: monthTotals[0]?.totalMes || 0,\r\n-            pagoMes: monthTotals[0]?.pagoMes || 0,\r\n-        };\r\n-\r\n-        res.status(200).json(kpis);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const Boleto = require('../models/Boleto');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO\r\n-// Esta função centraliza a lógica para determinar o intervalo de datas\r\n-function getDateRange(query) {\r\n-    const { startDate, endDate } = query;\r\n-    if (startDate && endDate) {\r\n-        return {\r\n-            start: new Date(Date.UTC.parse(startDate + 'T00:00:00.000Z')),\r\n-            end: new Date(Date.UTC.parse(endDate + 'T23:59:59.999Z'))\r\n-        };\r\n-    }\r\n-    // Se não forem fornecidas datas, o padrão é o mês corrente\r\n-    const today = new Date();\r\n-    const year = today.getFullYear();\r\n-    const month = today.getMonth();\r\n-    return {\r\n-        start: new Date(Date.UTC(year, month, 1)),\r\n-        end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n-    };\r\n-}\r\n-\r\n-\r\n-// Rota: GET /api/reports/expenses-by-category\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/expenses-by-category', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        const dateRange = getDateRange(req.query);\r\n-\r\n-        const report = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n-            // ETAPA ADICIONADA: Filtra as parcelas pelo período de tempo\r\n-            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            // O resto da consulta continua igual\r\n-            { $group: { _id: '$category', totalAmount: { $sum: '$parcels.amount' } } },\r\n-            { $lookup: { from: 'categories', localField: '_id', foreignField: '_id', as: 'categoryDetails' } },\r\n-            { $project: { _id: 0, categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] }, totalAmount: '$totalAmount' } }\r\n-        ]);\r\n-\r\n-        res.status(200).json(report);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota: GET /api/reports/monthly-summary\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/monthly-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        // MODIFICADO: A data de início já não é fixa em \"6 meses atrás\"\r\n-        const dateRange = getDateRange(req.query);\r\n-\r\n-        const summary = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n-            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n-            // ETAPA MODIFICADA: Filtra as parcelas pelo período fornecido\r\n-            { $match: { convertedDate: { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            { $group: { _id: { year: { $year: '$convertedDate' }, month: { $month: '$convertedDate' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n-            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n-        ]);\r\n-\r\n-        res.status(200).json(summary);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota: GET /api/reports/kpi-summary\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/kpi-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        // ETAPA MODIFICADA: Usamos a nossa função de ajuda\r\n-        const dateRange = getDateRange(req.query);\r\n-\r\n-        const monthTotals = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            // ETAPA MODIFICADA: O filtro agora usa o nosso intervalo de datas dinâmico\r\n-            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            {\r\n-                $group: {\r\n-                    _id: null,\r\n-                    totalMes: { $sum: '$parcels.amount' },\r\n-                    pagoMes: { $sum: { $cond: [{ $eq: ['$parcels.paid', true] }, '$parcels.amount', 0] } }\r\n-                }\r\n-            }\r\n-        ]);\r\n-\r\n-        const kpis = {\r\n-            totalMes: monthTotals[0]?.totalMes || 0,\r\n-            pagoMes: monthTotals[0]?.pagoMes || 0,\r\n-        };\r\n-\r\n-        res.status(200).json(kpis);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const Boleto = require('../models/Boleto');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// Rota: GET /api/reports/expenses-by-category\r\n-// Retorna o valor total pago para cada categoria da empresa do usuário.\r\n-router.get('/expenses-by-category', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-\r\n-        const report = await Boleto.aggregate([\r\n-            // 1. Encontra todos os boletos da empresa do usuário\r\n-            { $match: { company: companyId } },\r\n-            // 2. \"Desmonta\" o array de parcelas para processar cada uma individualmente\r\n-            { $unwind: '$parcels' },\r\n-            // 3. Filtra para pegar apenas as parcelas que foram pagas\r\n-            { $match: { 'parcels.paid': true } },\r\n-            // 4. Agrupa os resultados por categoria e soma os valores\r\n-            {\r\n-                $group: {\r\n-                    _id: '$category',\r\n-                    totalAmount: { $sum: '$parcels.amount' }\r\n-                }\r\n-            },\r\n-            // 5. Junta (\"lookup\") com a coleção de categorias para obter o nome\r\n-            {\r\n-                $lookup: {\r\n-                    from: 'categories',\r\n-                    localField: '_id',\r\n-                    foreignField: '_id',\r\n-                    as: 'categoryDetails'\r\n-                }\r\n-            },\r\n-            // 6. Formata a saída para ser mais amigável\r\n-            {\r\n-                $project: {\r\n-                    _id: 0,\r\n-                    categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] },\r\n-                    totalAmount: '$totalAmount'\r\n-                }\r\n-            }\r\n-        ]);\r\n-\r\n-        res.status(200).json(report);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n-    }\r\n-});\r\n-\r\n-// Retorna o total de despesas pagas nos últimos 6 meses.\r\n-router.get('/monthly-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-\r\n-        // Define a data de início (6 meses atrás)\r\n-        const sixMonthsAgo = new Date();\r\n-        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);\r\n-\r\n-        const summary = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n-            // Converte a string de data para um objeto de data do MongoDB\r\n-            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n-            // Filtra apenas as parcelas dos últimos 6 meses\r\n-            { $match: { convertedDate: { $gte: sixMonthsAgo } } },\r\n-            // Agrupa por ano e mês para somar os totais\r\n-            {\r\n-                $group: {\r\n-                    _id: {\r\n-                        year: { $year: '$convertedDate' },\r\n-                        month: { $month: '$convertedDate' }\r\n-                    },\r\n-                    totalAmount: { $sum: '$parcels.amount' }\r\n-                }\r\n-            },\r\n-            // Ordena o resultado por data\r\n-            { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n-        ]);\r\n-\r\n-        res.status(200).json(summary);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar resumo mensal:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota: GET /api/reports/kpi-summary\r\n-// Retorna um resumo dos principais KPIs para o dashboard.\r\n-router.get('/kpi-summary', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        \r\n-        // --- LÓGICA DE DATAS CORRIGIDA ---\r\n-        const today = new Date();\r\n-        const year = today.getFullYear();\r\n-        const month = today.getMonth(); // 0 para Janeiro, 6 para Julho, etc.\r\n-\r\n-        // Cria as datas de início e fim diretamente em UTC para evitar problemas de fuso horário.\r\n-        const startOfMonth = new Date(Date.UTC(year, month, 1));\r\n-        const endOfMonth = new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999));\r\n-        // ------------------------------------\r\n-\r\n-        const monthTotals = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n-            { $unwind: '$parcels' },\r\n-            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            { $match: { 'parcels.dueDateObject': { $gte: startOfMonth, $lte: endOfMonth } } },\r\n-            {\r\n-                $group: {\r\n-                    _id: null,\r\n-                    totalMes: { $sum: '$parcels.amount' },\r\n-                    pagoMes: {\r\n-                        $sum: {\r\n-                            $cond: [{ $eq: ['$parcels.paid', true] }, '$parcels.amount', 0]\r\n-                        }\r\n-                    }\r\n-                }\r\n-            }\r\n-        ]);\r\n-\r\n-        const kpis = {\r\n-            totalMes: monthTotals[0]?.totalMes || 0,\r\n-            pagoMes: monthTotals[0]?.pagoMes || 0,\r\n-        };\r\n-\r\n-        res.status(200).json(kpis);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar KPIs do dashboard:\", error);\r\n-        res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n-    }\r\n-});\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753475596150,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,17 +66,25 @@\n // MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n router.get('/monthly-summary', protect, async (req, res) => {\r\n     try {\r\n         const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n-        // MODIFICADO: A data de início já não é fixa em \"6 meses atrás\"\r\n         const dateRange = getDateRange(req.query);\r\n+        const { status } = req.query; // Novo: Pega o status do filtro\r\n \r\n+        // Define o filtro de status (pago/não pago/todos)\r\n+        let paidMatch = {};\r\n+        if (status === 'paid') {\r\n+            paidMatch = { 'parcels.paid': true };\r\n+        } else if (status === 'unpaid') {\r\n+            paidMatch = { 'parcels.paid': false };\r\n+        }\r\n+\r\n         const summary = await Boleto.aggregate([\r\n             { $match: { company: companyId } },\r\n             { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': true } },\r\n+            // A linha abaixo foi MODIFICADA para usar o filtro dinâmico\r\n+            { $match: paidMatch },\r\n             { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n-            // ETAPA MODIFICADA: Filtra as parcelas pelo período fornecido\r\n             { $match: { convertedDate: { $gte: dateRange.start, $lte: dateRange.end } } },\r\n             { $group: { _id: { year: { $year: '$convertedDate' }, month: { $month: '$convertedDate' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n             { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n         ]);\r\n"
                },
                {
                    "date": 1753534337541,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,22 +1,20 @@\n const express = require('express');\r\n const router = express.Router();\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-const Boleto = require('../models/Boleto');\r\n const mongoose = require('mongoose');\r\n \r\n-// FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO\r\n-// Esta função centraliza a lógica para determinar o intervalo de datas\r\n+// Importa o ESQUEMA do modelo, não o modelo compilado\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n+\r\n+// FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO (sem alterações)\r\n function getDateRange(query) {\r\n     const { startDate, endDate } = query;\r\n     if (startDate && endDate) {\r\n-        // CORREÇÃO: Usamos o formato ISO 8601 com 'Z' para criar a data diretamente em UTC.\r\n         return {\r\n             start: new Date(startDate + 'T00:00:00.000Z'),\r\n             end: new Date(endDate + 'T23:59:59.999Z')\r\n         };\r\n     }\r\n-    // O padrão para o mês corrente continua igual e já estava correto.\r\n     const today = new Date();\r\n     const year = today.getFullYear();\r\n     const month = today.getMonth();\r\n     return {\r\n@@ -26,28 +24,26 @@\n }\r\n \r\n \r\n // Rota: GET /api/reports/expenses-by-category\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/expenses-by-category', protect, async (req, res) => {\r\n+router.get('/expenses-by-category', async (req, res) => {\r\n     try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        // Obtém o modelo 'Boleto' a partir da conexão específica da empresa\r\n+        const Boleto = req.tenantDb.model('Boleto', BoletoSchema);\r\n+        \r\n         const dateRange = getDateRange(req.query);\r\n-        const { status } = req.query; // Novo: Pega o status do filtro\r\n+        const { status } = req.query;\r\n \r\n-        // Define o filtro de status (pago/não pago/todos)\r\n         let paidMatch = {};\r\n         if (status === 'paid') {\r\n             paidMatch = { 'parcels.paid': true };\r\n         } else if (status === 'unpaid') {\r\n             paidMatch = { 'parcels.paid': false };\r\n         }\r\n-        // Se 'status' for 'all' ou indefinido, paidMatch continua como {}, sem filtrar.\r\n \r\n         const report = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n+            // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n             { $unwind: '$parcels' },\r\n-            // A linha abaixo foi MODIFICADA para usar o filtro dinâmico\r\n             { $match: paidMatch },\r\n             { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n             { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n             { $group: { _id: '$category', totalAmount: { $sum: '$parcels.amount' } } },\r\n@@ -62,27 +58,24 @@\n     }\r\n });\r\n \r\n // Rota: GET /api/reports/monthly-summary\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/monthly-summary', protect, async (req, res) => {\r\n+router.get('/monthly-summary', async (req, res) => {\r\n     try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const Boleto = req.tenantDb.model('Boleto', BoletoSchema);\r\n         const dateRange = getDateRange(req.query);\r\n-        const { status } = req.query; // Novo: Pega o status do filtro\r\n+        const { status } = req.query;\r\n \r\n-        // Define o filtro de status (pago/não pago/todos)\r\n         let paidMatch = {};\r\n         if (status === 'paid') {\r\n             paidMatch = { 'parcels.paid': true };\r\n         } else if (status === 'unpaid') {\r\n             paidMatch = { 'parcels.paid': false };\r\n         }\r\n \r\n         const summary = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n+            // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n             { $unwind: '$parcels' },\r\n-            // A linha abaixo foi MODIFICADA para usar o filtro dinâmico\r\n             { $match: paidMatch },\r\n             { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n             { $match: { convertedDate: { $gte: dateRange.start, $lte: dateRange.end } } },\r\n             { $group: { _id: { year: { $year: '$convertedDate' }, month: { $month: '$convertedDate' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n@@ -96,17 +89,16 @@\n     }\r\n });\r\n \r\n // Rota: GET /api/reports/kpi-summary\r\n-// MODIFICADA: Agora aceita ?startDate= e &endDate=\r\n-router.get('/kpi-summary', protect, async (req, res) => {\r\n+router.get('/kpi-summary', async (req, res) => {\r\n     try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const Boleto = req.tenantDb.model('Boleto', BoletoSchema);\r\n         const dateRange = getDateRange(req.query);\r\n \r\n         // Query 1: Calcula os totais para o período selecionado\r\n         const periodTotals = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n+            // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n             { $unwind: '$parcels' },\r\n             { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n             { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n             {\r\n@@ -117,21 +109,20 @@\n                 }\r\n             }\r\n         ]);\r\n         \r\n-        // Query 2: Calcula o total GERAL de contas vencidas (não depende do período)\r\n+        // Query 2: Calcula o total GERAL de contas vencidas\r\n         const overdueTotal = await Boleto.aggregate([\r\n-            { $match: { company: companyId } },\r\n+            // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n             { $unwind: '$parcels' },\r\n             { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n             { $match: { \r\n                 'parcels.paid': false,\r\n-                'parcels.dueDateObject': { $lt: new Date(Date.now()) } // Data de vencimento é anterior a agora\r\n+                'parcels.dueDateObject': { $lt: new Date(Date.now()) }\r\n             }},\r\n             { $group: { _id: null, totalVencido: { $sum: '$parcels.amount' } } }\r\n         ]);\r\n \r\n-        // Combina os resultados das duas queries\r\n         const kpis = {\r\n             totalMes: periodTotals[0]?.totalMes || 0,\r\n             pagoMes: periodTotals[0]?.pagoMes || 0,\r\n             totalVencido: overdueTotal[0]?.totalVencido || 0,\r\n@@ -145,32 +136,24 @@\n     }\r\n });\r\n \r\n // Retorna as próximas 5 parcelas não pagas que estão para vencer.\r\n-router.get('/upcoming-payments', protect, async (req, res) => {\r\n+router.get('/upcoming-payments', async (req, res) => {\r\n     try {\r\n-        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n+        const Boleto = req.tenantDb.model('Boleto', BoletoSchema);\r\n         const today = new Date();\r\n-        // Definimos o início de hoje em UTC para garantir a consistência da consulta\r\n         today.setUTCHours(0, 0, 0, 0);\r\n \r\n         const upcoming = await Boleto.aggregate([\r\n-            // 1. Filtra os boletos da empresa\r\n-            { $match: { company: companyId } },\r\n-            // 2. \"Desmonta\" o array de parcelas\r\n+            // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n             { $unwind: '$parcels' },\r\n-            // 3. Converte a data para um objeto de data real\r\n             { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            // 4. Filtra apenas as parcelas NÃO PAGAS e com vencimento A PARTIR DE HOJE\r\n             { $match: {\r\n                 'parcels.paid': false,\r\n                 'parcels.dueDateObject': { $gte: today }\r\n             }},\r\n-            // 5. Ordena pela data de vencimento mais próxima\r\n             { $sort: { 'parcels.dueDateObject': 1 } },\r\n-            // 6. Limita o resultado a apenas 5 parcelas\r\n             { $limit: 5 },\r\n-            // 7. Formata o resultado para ser mais fácil de usar no frontend\r\n             {\r\n                 $project: {\r\n                     _id: 0,\r\n                     billName: '$name',\r\n"
                },
                {
                    "date": 1754504346705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,33 @@\n \r\n // Importa o ESQUEMA do modelo, não o modelo compilado\r\n const BoletoSchema = require('../models/Boleto').schema;\r\n \r\n+/**\r\n+ * Constrói os estágios iniciais e comuns da pipeline de agregação para relatórios.\r\n+ * Inclui desestruturação de parcelas, filtragem por data e por status (pago/não pago).\r\n+ * @param {object} query - O objeto req.query da rota.\r\n+ * @returns {Array} Um array com os estágios da pipeline de agregação.\r\n+ */\r\n+function buildBasePipeline(query) {\r\n+    const dateRange = getDateRange(query);\r\n+    const { status } = query;\r\n+\r\n+    let paidMatch = {};\r\n+    if (status === 'paid') {\r\n+        paidMatch = { 'parcels.paid': true };\r\n+    } else if (status === 'unpaid') {\r\n+        paidMatch = { 'parcels.paid': false };\r\n+    }\r\n+\r\n+    return [\r\n+        { $unwind: '$parcels' },\r\n+        { $match: paidMatch },\r\n+        { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n+        { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } }\r\n+    ];\r\n+}\r\n+\r\n // FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO (sem alterações)\r\n function getDateRange(query) {\r\n     const { startDate, endDate } = query;\r\n     if (startDate && endDate) {\r\n"
                },
                {
                    "date": 1754504557013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,37 @@\n const express = require('express');\r\n const router = express.Router();\r\n const mongoose = require('mongoose');\r\n \r\n-// Importa o ESQUEMA do modelo, não o modelo compilado\r\n+// Importa o ESQUEMA do modelo, que será compilado na conexão de cada empresa.\r\n const BoletoSchema = require('../models/Boleto').schema;\r\n \r\n /**\r\n+ * Função de ajuda que analisa os parâmetros da query (startDate, endDate)\r\n+ * e retorna um objeto com as datas de início e fim para a filtragem.\r\n+ * Se nenhum parâmetro for fornecido, assume o mês corrente.\r\n+ * @param {object} query - O objeto req.query da rota.\r\n+ * @returns {{start: Date, end: Date}} - Um objeto com as datas de início e fim.\r\n+ */\r\n+function getDateRange(query) {\r\n+    const { startDate, endDate } = query;\r\n+    if (startDate && endDate) {\r\n+        return {\r\n+            start: new Date(startDate + 'T00:00:00.000Z'),\r\n+            end: new Date(endDate + 'T23:59:59.999Z')\r\n+        };\r\n+    }\r\n+    // Se não houver datas, o padrão é o mês atual.\r\n+    const today = new Date();\r\n+    const year = today.getFullYear();\r\n+    const month = today.getMonth();\r\n+    return {\r\n+        start: new Date(Date.UTC(year, month, 1)),\r\n+        end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n+    };\r\n+}\r\n+\r\n+/**\r\n  * Constrói os estágios iniciais e comuns da pipeline de agregação para relatórios.\r\n  * Inclui desestruturação de parcelas, filtragem por data e por status (pago/não pago).\r\n  * @param {object} query - O objeto req.query da rota.\r\n  * @returns {Array} Um array com os estágios da pipeline de agregação.\r\n@@ -21,109 +46,79 @@\n     } else if (status === 'unpaid') {\r\n         paidMatch = { 'parcels.paid': false };\r\n     }\r\n \r\n+    // Retorna um array com os estágios de agregação que são comuns a várias rotas\r\n     return [\r\n-        { $unwind: '$parcels' },\r\n-        { $match: paidMatch },\r\n-        { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-        { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } }\r\n+        { $unwind: '$parcels' }, // \"Desmonta\" o array de parcelas, criando um documento para cada uma\r\n+        { $match: paidMatch },  // Filtra por status (pago/não pago/todos)\r\n+        { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } }, // Converte a data de string para objeto Date\r\n+        { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } } // Filtra pelo período de tempo\r\n     ];\r\n }\r\n \r\n-// FUNÇÃO DE AJUDA PARA OBTER O PERÍODO DE TEMPO (sem alterações)\r\n-function getDateRange(query) {\r\n-    const { startDate, endDate } = query;\r\n-    if (startDate && endDate) {\r\n-        return {\r\n-            start: new Date(startDate + 'T00:00:00.000Z'),\r\n-            end: new Date(endDate + 'T23:59:59.999Z')\r\n-        };\r\n-    }\r\n-    const today = new Date();\r\n-    const year = today.getFullYear();\r\n-    const month = today.getMonth();\r\n-    return {\r\n-        start: new Date(Date.UTC(year, month, 1)),\r\n-        end: new Date(Date.UTC(year, month + 1, 0, 23, 59, 59, 999))\r\n-    };\r\n-}\r\n-\r\n-\r\n // Rota: GET /api/reports/expenses-by-category\r\n+// Gera os dados para o gráfico de despesas por categoria.\r\n router.get('/expenses-by-category', async (req, res) => {\r\n     try {\r\n-        // Obtém o modelo 'Boleto' a partir da conexão específica da empresa\r\n         const Boleto = req.tenantDb.model('Boleto', BoletoSchema);\r\n         \r\n-        const dateRange = getDateRange(req.query);\r\n-        const { status } = req.query;\r\n+        // 1. Obtém a pipeline de base com todos os filtros comuns.\r\n+        const basePipeline = buildBasePipeline(req.query);\r\n \r\n-        let paidMatch = {};\r\n-        if (status === 'paid') {\r\n-            paidMatch = { 'parcels.paid': true };\r\n-        } else if (status === 'unpaid') {\r\n-            paidMatch = { 'parcels.paid': false };\r\n-        }\r\n-\r\n-        const report = await Boleto.aggregate([\r\n-            // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n-            { $unwind: '$parcels' },\r\n-            { $match: paidMatch },\r\n-            { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n-            { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n+        // 2. Adiciona os estágios de agregação que são específicos DESTA rota.\r\n+        const reportPipeline = [\r\n+            ...basePipeline, // Reutiliza os estágios comuns\r\n             { $group: { _id: '$category', totalAmount: { $sum: '$parcels.amount' } } },\r\n             { $lookup: { from: 'categories', localField: '_id', foreignField: '_id', as: 'categoryDetails' } },\r\n             { $project: { _id: 0, categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] }, totalAmount: '$totalAmount' } }\r\n-        ]);\r\n+        ];\r\n \r\n+        const report = await Boleto.aggregate(reportPipeline);\r\n         res.status(200).json(report);\r\n+\r\n     } catch (error) {\r\n         console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n         res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n     }\r\n });\r\n \r\n // Rota: GET /api/reports/monthly-summary\r\n+// Gera os dados para o gráfico de resumo dos últimos meses.\r\n router.get('/monthly-summary', async (req, res) => {\r\n     try {\r\n         const Boleto = req.tenantDb.model('Boleto', BoletoSchema);\r\n-        const dateRange = getDateRange(req.query);\r\n-        const { status } = req.query;\r\n+        \r\n+        // 1. Reutiliza a mesma função para obter a base da pipeline.\r\n+        const basePipeline = buildBasePipeline(req.query);\r\n \r\n-        let paidMatch = {};\r\n-        if (status === 'paid') {\r\n-            paidMatch = { 'parcels.paid': true };\r\n-        } else if (status === 'unpaid') {\r\n-            paidMatch = { 'parcels.paid': false };\r\n-        }\r\n-\r\n-        const summary = await Boleto.aggregate([\r\n-            // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n-            { $unwind: '$parcels' },\r\n-            { $match: paidMatch },\r\n-            { $addFields: { convertedDate: { $toDate: '$parcels.dueDate' } } },\r\n-            { $match: { convertedDate: { $gte: dateRange.start, $lte: dateRange.end } } },\r\n-            { $group: { _id: { year: { $year: '$convertedDate' }, month: { $month: '$convertedDate' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n+        // 2. Adiciona os estágios específicos para agrupar por mês/ano.\r\n+        const summaryPipeline = [\r\n+            ...basePipeline,\r\n+            { $group: { _id: { year: { $year: '$parcels.dueDateObject' }, month: { $month: '$parcels.dueDateObject' } }, totalAmount: { $sum: '$parcels.amount' } } },\r\n             { $sort: { '_id.year': 1, '_id.month': 1 } }\r\n-        ]);\r\n+        ];\r\n \r\n+        const summary = await Boleto.aggregate(summaryPipeline);\r\n         res.status(200).json(summary);\r\n+\r\n     } catch (error) {\r\n         console.error(\"Erro ao gerar resumo mensal:\", error);\r\n         res.status(500).json({ message: \"Erro interno ao gerar resumo.\" });\r\n     }\r\n });\r\n \r\n // Rota: GET /api/reports/kpi-summary\r\n+// Gera os dados para os cartões principais (KPIs) do dashboard.\r\n router.get('/kpi-summary', async (req, res) => {\r\n     try {\r\n         const Boleto = req.tenantDb.model('Boleto', BoletoSchema);\r\n         const dateRange = getDateRange(req.query);\r\n+        const today = new Date();\r\n+        today.setUTCHours(0, 0, 0, 0);\r\n \r\n-        // Query 1: Calcula os totais para o período selecionado\r\n+        // Query 1: Calcula os totais para o período selecionado.\r\n         const periodTotals = await Boleto.aggregate([\r\n-            // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n             { $unwind: '$parcels' },\r\n             { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n             { $match: { 'parcels.dueDateObject': { $gte: dateRange.start, $lte: dateRange.end } } },\r\n             {\r\n@@ -134,16 +129,15 @@\n                 }\r\n             }\r\n         ]);\r\n         \r\n-        // Query 2: Calcula o total GERAL de contas vencidas\r\n+        // Query 2: Calcula o total GERAL de contas vencidas (não depende do período).\r\n         const overdueTotal = await Boleto.aggregate([\r\n-            // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n             { $unwind: '$parcels' },\r\n             { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n             { $match: { \r\n                 'parcels.paid': false,\r\n-                'parcels.dueDateObject': { $lt: new Date(Date.now()) }\r\n+                'parcels.dueDateObject': { $lt: today }\r\n             }},\r\n             { $group: { _id: null, totalVencido: { $sum: '$parcels.amount' } } }\r\n         ]);\r\n \r\n@@ -160,17 +154,17 @@\n         res.status(500).json({ message: \"Erro interno ao gerar resumo de KPIs.\" });\r\n     }\r\n });\r\n \r\n+// Rota: GET /api/reports/upcoming-payments\r\n // Retorna as próximas 5 parcelas não pagas que estão para vencer.\r\n router.get('/upcoming-payments', async (req, res) => {\r\n     try {\r\n         const Boleto = req.tenantDb.model('Boleto', BoletoSchema);\r\n         const today = new Date();\r\n         today.setUTCHours(0, 0, 0, 0);\r\n \r\n         const upcoming = await Boleto.aggregate([\r\n-            // { $match: { company: companyId } }, // <-- LINHA REMOVIDA\r\n             { $unwind: '$parcels' },\r\n             { $addFields: { 'parcels.dueDateObject': { $toDate: '$parcels.dueDate' } } },\r\n             { $match: {\r\n                 'parcels.paid': false,\r\n"
                },
                {
                    "date": 1754506156493,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n const router = express.Router();\r\n const mongoose = require('mongoose');\r\n \r\n // Importa o ESQUEMA do modelo, que será compilado na conexão de cada empresa.\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n+const { schema: BoletoSchema } = require('../models/Boleto');\r\n \r\n /**\r\n  * Função de ajuda que analisa os parâmetros da query (startDate, endDate)\r\n  * e retorna um objeto com as datas de início e fim para a filtragem.\r\n"
                }
            ],
            "date": 1753280820026,
            "name": "Commit-0",
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst { protect } = require('../middleware/authMiddleware');\r\nconst Boleto = require('../models/Boleto');\r\nconst mongoose = require('mongoose');\r\n\r\n// Rota: GET /api/reports/expenses-by-category\r\n// Retorna o valor total pago para cada categoria da empresa do usuário.\r\nrouter.get('/expenses-by-category', protect, async (req, res) => {\r\n    try {\r\n        const companyId = new mongoose.Types.ObjectId(req.user.companyId);\r\n\r\n        const report = await Boleto.aggregate([\r\n            // 1. Encontra todos os boletos da empresa do usuário\r\n            { $match: { company: companyId } },\r\n            // 2. \"Desmonta\" o array de parcelas para processar cada uma individualmente\r\n            { $unwind: '$parcels' },\r\n            // 3. Filtra para pegar apenas as parcelas que foram pagas\r\n            { $match: { 'parcels.paid': true } },\r\n            // 4. Agrupa os resultados por categoria e soma os valores\r\n            {\r\n                $group: {\r\n                    _id: '$category',\r\n                    totalAmount: { $sum: '$parcels.amount' }\r\n                }\r\n            },\r\n            // 5. Junta (\"lookup\") com a coleção de categorias para obter o nome\r\n            {\r\n                $lookup: {\r\n                    from: 'categories',\r\n                    localField: '_id',\r\n                    foreignField: '_id',\r\n                    as: 'categoryDetails'\r\n                }\r\n            },\r\n            // 6. Formata a saída para ser mais amigável\r\n            {\r\n                $project: {\r\n                    _id: 0,\r\n                    categoryName: { $ifNull: [ { $arrayElemAt: ['$categoryDetails.name', 0] }, 'Sem Categoria' ] },\r\n                    totalAmount: '$totalAmount'\r\n                }\r\n            }\r\n        ]);\r\n\r\n        res.status(200).json(report);\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro ao gerar relatório de despesas por categoria:\", error);\r\n        res.status(500).json({ message: \"Erro interno ao gerar relatório.\" });\r\n    }\r\n});\r\n\r\nmodule.exports = router;"
        }
    ]
}