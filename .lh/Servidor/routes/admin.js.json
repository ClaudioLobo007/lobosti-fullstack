{
    "sourceFile": "Servidor/routes/admin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 32,
            "patches": [
                {
                    "date": 1752269564509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753535153128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n const router = express.Router();\r\n const jwt = require('jsonwebtoken');\r\n \r\n // MUDANÇA: Importamos os modelos necessários\r\n-const Company = require('../models/Company');\r\n+const Company = require('../models/--');\r\n const User = require('../models/User');\r\n \r\n const { protect } = require('../middleware/authMiddleware');\r\n \r\n"
                },
                {
                    "date": 1753535272378,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,36 +1,38 @@\n const express = require('express');\r\n const router = express.Router();\r\n const jwt = require('jsonwebtoken');\r\n \r\n-// MUDANÇA: Importamos os modelos necessários\r\n-const Company = require('../models/--');\r\n-const User = require('../models/User');\r\n+// CORREÇÃO: Importa os modelos do banco de dados MESTRE\r\n+const MasterCompany = require('../models/MasterCompany');\r\n+const MasterUser = require('../models/MasterUser');\r\n \r\n-const { protect } = require('../middleware/authMiddleware');\r\n-\r\n-router.post('/impersonate', protect, async (req, res) => {\r\n+// A rota /impersonate já é protegida pelo 'protect' e recebe a conexão\r\n+// do banco Mestre via 'masterDbMiddleware' que configuramos no server.js\r\n+router.post('/impersonate', async (req, res) => {\r\n     try {\r\n         const adminId = req.user.id;\r\n         const { companyId, userId } = req.body;\r\n-        \r\n-        // ANTES: Procurávamos o usuário dentro do documento da empresa.\r\n-        // AGORA: Procuramos o usuário diretamente e verificamos se ele pertence à empresa correta.\r\n-        const user = await User.findById(userId);\r\n \r\n-        if (!user || user.company.toString() !== companyId) {\r\n+        // CORREÇÃO: Usa os modelos corretos com a conexão do banco Mestre\r\n+        const userToImpersonate = await MasterUser.findById(userId);\r\n+\r\n+        // Garante que o usuário a ser representado pertence à empresa correta\r\n+        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n              return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n         }\r\n-        \r\n-        const company = await Company.findById(companyId);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        // A geração do token continua igual.\r\n+        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n+        if (!companyToImpersonate) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        // A geração do token agora usa os dados dos modelos Mestre\r\n         const token = jwt.sign(\r\n             { \r\n-                id: user._id,\r\n-                companyId: user.company, \r\n-                role: user.role,\r\n+                id: userToImpersonate._id,\r\n+                companyId: userToImpersonate.company, \r\n+                username: userToImpersonate.username, // Adicionamos o username para a rota /me\r\n                 impersonator: adminId\r\n             },\r\n             process.env.JWT_SECRET,\r\n             { expiresIn: '1h' }\r\n@@ -38,10 +40,10 @@\n \r\n         res.status(200).json({\r\n             message: 'Token de representação gerado com sucesso.',\r\n             token,\r\n-            user: { _id: user._id, username: user.username, role: user.role },\r\n-            company: { _id: company._id, nomeEmpresa: company.nomeEmpresa } // Enviamos só o necessário\r\n+            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n+            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n         });\r\n \r\n     } catch (error) {\r\n         console.error(\"Erro ao tentar representar usuário:\", error);\r\n"
                },
                {
                    "date": 1753538418723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,38 +1,43 @@\n const express = require('express');\r\n const router = express.Router();\r\n const jwt = require('jsonwebtoken');\r\n \r\n-// CORREÇÃO: Importa os modelos do banco de dados MESTRE\r\n-const MasterCompany = require('../models/MasterCompany');\r\n-const MasterUser = require('../models/MasterUser');\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n \r\n-// A rota /impersonate já é protegida pelo 'protect' e recebe a conexão\r\n-// do banco Mestre via 'masterDbMiddleware' que configuramos no server.js\r\n+\r\n router.post('/impersonate', async (req, res) => {\r\n     try {\r\n+        // --- CORREÇÃO PRINCIPAL AQUI ---\r\n+        // 1. Obtemos a conexão Mestre ativa que foi passada pelo middleware.\r\n+        const masterDb = req.masterDb;\r\n+        // 2. Compilamos os modelos que vamos usar nesta conexão específica.\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+        // --- FIM DA CORREÇÃO ---\r\n+\r\n         const adminId = req.user.id;\r\n         const { companyId, userId } = req.body;\r\n-\r\n-        // CORREÇÃO: Usa os modelos corretos com a conexão do banco Mestre\r\n+        \r\n+        // 3. Agora a busca usa o modelo corretamente conectado, sem timeout.\r\n         const userToImpersonate = await MasterUser.findById(userId);\r\n \r\n-        // Garante que o usuário a ser representado pertence à empresa correta\r\n         if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n              return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n         }\r\n-\r\n+        \r\n         const companyToImpersonate = await MasterCompany.findById(companyId);\r\n         if (!companyToImpersonate) {\r\n             return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n         }\r\n \r\n-        // A geração do token agora usa os dados dos modelos Mestre\r\n         const token = jwt.sign(\r\n             { \r\n                 id: userToImpersonate._id,\r\n                 companyId: userToImpersonate.company, \r\n-                username: userToImpersonate.username, // Adicionamos o username para a rota /me\r\n+                username: userToImpersonate.username, // Importante para a rota /me\r\n                 impersonator: adminId\r\n             },\r\n             process.env.JWT_SECRET,\r\n             { expiresIn: '1h' }\r\n"
                },
                {
                    "date": 1753806595199,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,11 @@\n \r\n // CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { getTenantConnection } = require('../config/db');\r\n+const { sendDailyReportEmail } = require('../services/emailService');\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n \r\n \r\n router.post('/impersonate', async (req, res) => {\r\n     try {\r\n@@ -55,5 +58,60 @@\n         res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n     }\r\n });\r\n \r\n+// Rota para testar manualmente o envio do relatório diário\r\n+router.post('/test-daily-report', async (req, res) => {\r\n+    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n+    if (!req.user.impersonator) {\r\n+        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n+    }\r\n+\r\n+    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n+    const company = req.company; // O middleware já nos deu a empresa representada\r\n+\r\n+    const today = new Date();\r\n+    today.setUTCHours(0, 0, 0, 0);\r\n+    const todayStr = today.toISOString().split('T')[0];\r\n+\r\n+    try {\r\n+        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n+        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n+        const overdueParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        const dueTodayParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n+        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n+\r\n+        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n+            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+            res.status(200).json({ \r\n+                message: `E-mail de relatório enviado para ${company.email}!`,\r\n+                overdueCount: overdueParcels.length,\r\n+                dueTodayCount: dueTodayParcels.length\r\n+            });\r\n+        } else {\r\n+            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n+            res.status(200).json({ \r\n+                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n+                overdueCount: 0,\r\n+                dueTodayCount: 0\r\n+            });\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('[TESTE MANUAL] Erro:', error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753807256324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,9 @@\n const MasterUserSchema = require('../models/MasterUser').schema;\r\n const { getTenantConnection } = require('../config/db');\r\n const { sendDailyReportEmail } = require('../services/emailService');\r\n const BoletoSchema = require('../models/Boleto').schema;\r\n+const AnnouncementSchema = require('../models/Announcement').schema;\r\n \r\n \r\n router.post('/impersonate', async (req, res) => {\r\n     try {\r\n@@ -113,5 +114,65 @@\n         res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n     }\r\n });\r\n \r\n+// --- ROTAS DE GESTÃO DE ANÚNCIOS (CRUD) ---\r\n+\r\n+// Rota para CRIAR um novo anúncio\r\n+router.post('/announcements', async (req, res) => {\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        const { message, link } = req.body;\r\n+\r\n+        // Desativa todos os outros anúncios para garantir que apenas um esteja ativo\r\n+        await Announcement.updateMany({}, { isActive: false });\r\n+\r\n+        const newAnnouncement = await Announcement.create({ message, link, isActive: true });\r\n+        res.status(201).json(newAnnouncement);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao criar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER todos os anúncios\r\n+router.get('/announcements', async (req, res) => {\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n+        res.status(200).json(announcements);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATIVAR/DESATIVAR um anúncio\r\n+router.patch('/announcements/:id/toggle', async (req, res) => {\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        const { id } = req.params;\r\n+\r\n+        // Desativa todos os outros anúncios\r\n+        await Announcement.updateMany({ _id: { $ne: id } }, { isActive: false });\r\n+\r\n+        // Inverte o status do anúncio alvo\r\n+        const announcement = await Announcement.findById(id);\r\n+        announcement.isActive = !announcement.isActive;\r\n+        await announcement.save();\r\n+\r\n+        res.status(200).json(announcement);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao alterar status do anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para APAGAR um anúncio\r\n+router.delete('/announcements/:id', async (req, res) => {\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        await Announcement.findByIdAndDelete(req.params.id);\r\n+        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753820663840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -114,59 +114,68 @@\n         res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n     }\r\n });\r\n \r\n-// --- ROTAS DE GESTÃO DE ANÚNCIOS (CRUD) ---\r\n+// --- GESTÃO DE ANÚNCIOS ---\r\n \r\n-// Rota para CRIAR um novo anúncio\r\n-router.post('/announcements', async (req, res) => {\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        const { message, link } = req.body;\r\n-\r\n-        // Desativa todos os outros anúncios para garantir que apenas um esteja ativo\r\n-        await Announcement.updateMany({}, { isActive: false });\r\n-\r\n-        const newAnnouncement = await Announcement.create({ message, link, isActive: true });\r\n-        res.status(201).json(newAnnouncement);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao criar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n // Rota para LER todos os anúncios\r\n router.get('/announcements', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n     try {\r\n         const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        // Ordena para mostrar os mais recentes primeiro\r\n         const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n         res.status(200).json(announcements);\r\n     } catch (error) {\r\n         res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n     }\r\n });\r\n \r\n-// Rota para ATIVAR/DESATIVAR um anúncio\r\n-router.patch('/announcements/:id/toggle', async (req, res) => {\r\n+// Rota para CRIAR um novo anúncio\r\n+router.post('/announcements', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n     try {\r\n+        const { message, link, isActive } = req.body;\r\n         const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        const { id } = req.params;\r\n \r\n-        // Desativa todos os outros anúncios\r\n-        await Announcement.updateMany({ _id: { $ne: id } }, { isActive: false });\r\n+        // Lógica para garantir que apenas um anúncio esteja ativo\r\n+        if (isActive) {\r\n+            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        }\r\n \r\n-        // Inverte o status do anúncio alvo\r\n-        const announcement = await Announcement.findById(id);\r\n-        announcement.isActive = !announcement.isActive;\r\n-        await announcement.save();\r\n+        const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+        res.status(201).json(newAnnouncement);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao criar anúncio.' });\r\n+    }\r\n+});\r\n \r\n-        res.status(200).json(announcement);\r\n+// Rota para ATUALIZAR um anúncio\r\n+router.patch('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const { message, link, isActive } = req.body;\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        \r\n+        // Lógica para garantir que apenas um anúncio esteja ativo\r\n+        if (isActive) {\r\n+            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        }\r\n+\r\n+        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { message, link, isActive },\r\n+            { new: true }\r\n+        );\r\n+        res.status(200).json(updatedAnnouncement);\r\n     } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao alterar status do anúncio.' });\r\n+        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n     }\r\n });\r\n \r\n // Rota para APAGAR um anúncio\r\n router.delete('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n     try {\r\n         const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n         await Announcement.findByIdAndDelete(req.params.id);\r\n         res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n"
                },
                {
                    "date": 1753821167060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,12 +121,12 @@\n router.get('/announcements', async (req, res) => {\r\n     if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n     try {\r\n         const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        // Ordena para mostrar os mais recentes primeiro\r\n         const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n         res.status(200).json(announcements);\r\n     } catch (error) {\r\n+        console.error(\"Erro ao buscar anúncios:\", error); // Adiciona log de erro\r\n         res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n     }\r\n });\r\n \r\n@@ -136,16 +136,16 @@\n     try {\r\n         const { message, link, isActive } = req.body;\r\n         const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n \r\n-        // Lógica para garantir que apenas um anúncio esteja ativo\r\n         if (isActive) {\r\n             await Announcement.updateMany({}, { $set: { isActive: false } });\r\n         }\r\n \r\n         const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n         res.status(201).json(newAnnouncement);\r\n     } catch (error) {\r\n+        console.error(\"Erro ao criar anúncio:\", error); // Adiciona log de erro\r\n         res.status(500).json({ message: 'Erro ao criar anúncio.' });\r\n     }\r\n });\r\n \r\n@@ -155,9 +155,8 @@\n     try {\r\n         const { message, link, isActive } = req.body;\r\n         const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n         \r\n-        // Lógica para garantir que apenas um anúncio esteja ativo\r\n         if (isActive) {\r\n             await Announcement.updateMany({}, { $set: { isActive: false } });\r\n         }\r\n \r\n@@ -167,8 +166,9 @@\n             { new: true }\r\n         );\r\n         res.status(200).json(updatedAnnouncement);\r\n     } catch (error) {\r\n+        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n         res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n     }\r\n });\r\n \r\n@@ -179,8 +179,9 @@\n         const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n         await Announcement.findByIdAndDelete(req.params.id);\r\n         res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n     } catch (error) {\r\n+        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n         res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n     }\r\n });\r\n \r\n"
                },
                {
                    "date": 1753821303301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,8 +133,11 @@\n // Rota para CRIAR um novo anúncio\r\n router.post('/announcements', async (req, res) => {\r\n     if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n     try {\r\n+        // --- LINHA DE DEPURAÇÃO ADICIONADA ---\r\n+        console.log('Corpo do Pedido Recebido:', req.body); \r\n+\r\n         const { message, link, isActive } = req.body;\r\n         const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n \r\n         if (isActive) {\r\n@@ -143,9 +146,9 @@\n \r\n         const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n         res.status(201).json(newAnnouncement);\r\n     } catch (error) {\r\n-        console.error(\"Erro ao criar anúncio:\", error); // Adiciona log de erro\r\n+        console.error(\"Erro ao criar anúncio:\", error);\r\n         res.status(500).json({ message: 'Erro ao criar anúncio.' });\r\n     }\r\n });\r\n \r\n"
                },
                {
                    "date": 1753892340706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,25 +131,23 @@\n });\r\n \r\n // Rota para CRIAR um novo anúncio\r\n router.post('/announcements', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n     try {\r\n-        // --- LINHA DE DEPURAÇÃO ADICIONADA ---\r\n-        console.log('Corpo do Pedido Recebido:', req.body); \r\n-\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n         const { message, link, isActive } = req.body;\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n \r\n-        if (isActive) {\r\n-            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        // Validação no servidor\r\n+        if (!message) {\r\n+            return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n         }\r\n \r\n         const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n         res.status(201).json(newAnnouncement);\r\n+\r\n     } catch (error) {\r\n         console.error(\"Erro ao criar anúncio:\", error);\r\n-        res.status(500).json({ message: 'Erro ao criar anúncio.' });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n     }\r\n });\r\n \r\n // Rota para ATUALIZAR um anúncio\r\n"
                },
                {
                    "date": 1753892444062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,16 +133,22 @@\n // Rota para CRIAR um novo anúncio\r\n router.post('/announcements', async (req, res) => {\r\n     try {\r\n         const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        \r\n+        // --- INÍCIO DA CORREÇÃO ---\r\n+        // Precisamos de pegar os dados que vêm do corpo do pedido (req.body)\r\n         const { message, link, isActive } = req.body;\r\n \r\n         // Validação no servidor\r\n         if (!message) {\r\n             return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n         }\r\n+        \r\n+        // Agora, usamos as variáveis para criar o novo anúncio\r\n+        const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+        // --- FIM DA CORREÇÃO ---\r\n \r\n-        const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n         res.status(201).json(newAnnouncement);\r\n \r\n     } catch (error) {\r\n         console.error(\"Erro ao criar anúncio:\", error);\r\n"
                },
                {
                    "date": 1753892690117,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,47 +116,46 @@\n });\r\n \r\n // --- GESTÃO DE ANÚNCIOS ---\r\n \r\n-// Rota para LER todos os anúncios\r\n-router.get('/announcements', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n-        res.status(200).json(announcements);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar anúncios:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n-    }\r\n-});\r\n+router.route('/announcements')\r\n+    // Rota para LER todos os anúncios\r\n+    .get(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n+            res.status(200).json(announcements);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao buscar anúncios:\", error);\r\n+            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n+        }\r\n+    })\r\n+    // Rota para CRIAR um novo anúncio\r\n+    .post(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const { message, link, isActive } = req.body;\r\n \r\n-// Rota para CRIAR um novo anúncio\r\n-router.post('/announcements', async (req, res) => {\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        \r\n-        // --- INÍCIO DA CORREÇÃO ---\r\n-        // Precisamos de pegar os dados que vêm do corpo do pedido (req.body)\r\n-        const { message, link, isActive } = req.body;\r\n+            if (!message) {\r\n+                // Esta validação agora funcionará corretamente\r\n+                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n+            }\r\n \r\n-        // Validação no servidor\r\n-        if (!message) {\r\n-            return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n+            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+            res.status(201).json(newAnnouncement);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao criar anúncio:\", error);\r\n+            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n         }\r\n-        \r\n-        // Agora, usamos as variáveis para criar o novo anúncio\r\n-        const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n-        // --- FIM DA CORREÇÃO ---\r\n+    });\r\n+// --- FIM DA CORREÇÃO ---\r\n \r\n-        res.status(201).json(newAnnouncement);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar anúncio:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n-    }\r\n+// As outras rotas (PATCH, DELETE com /:id) continuam como estão...\r\n+router.patch('/announcements/:id', async (req, res) => {\r\n+    // ...\r\n });\r\n \r\n+\r\n // Rota para ATUALIZAR um anúncio\r\n router.patch('/announcements/:id', async (req, res) => {\r\n     if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n     try {\r\n"
                },
                {
                    "date": 1753892723266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -146,16 +146,9 @@\n             console.error(\"Erro ao criar anúncio:\", error);\r\n             res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n         }\r\n     });\r\n-// --- FIM DA CORREÇÃO ---\r\n \r\n-// As outras rotas (PATCH, DELETE com /:id) continuam como estão...\r\n-router.patch('/announcements/:id', async (req, res) => {\r\n-    // ...\r\n-});\r\n-\r\n-\r\n // Rota para ATUALIZAR um anúncio\r\n router.patch('/announcements/:id', async (req, res) => {\r\n     if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n     try {\r\n"
                },
                {
                    "date": 1753892814148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,13 +131,16 @@\n     })\r\n     // Rota para CRIAR um novo anúncio\r\n     .post(async (req, res) => {\r\n         try {\r\n+            // --- ADICIONE ESTA LINHA DE DEPURAÇÃO ---\r\n+            console.log('CORPO DO PEDIDO RECEBIDO:', req.body);\r\n+            // --- FIM DA LINHA DE DEPURAÇÃO ---\r\n+\r\n             const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n             const { message, link, isActive } = req.body;\r\n \r\n             if (!message) {\r\n-                // Esta validação agora funcionará corretamente\r\n                 return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n             }\r\n \r\n             const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n"
                },
                {
                    "date": 1753901419738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,179 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const jwt = require('jsonwebtoken');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { getTenantConnection } = require('../config/db');\r\n+const { sendDailyReportEmail } = require('../services/emailService');\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n+const AnnouncementSchema = require('../models/Announcement').schema;\r\n+\r\n+\r\n+router.post('/impersonate', async (req, res) => {\r\n+    try {\r\n+        const masterDb = req.masterDb;\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+        const adminId = req.user.id;\r\n+        const { companyId, userId } = req.body;\r\n+        const userToImpersonate = await MasterUser.findById(userId);\r\n+\r\n+        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n+             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n+        }\r\n+        \r\n+        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n+        if (!companyToImpersonate) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        const token = jwt.sign(\r\n+            { \r\n+                id: userToImpersonate._id,\r\n+                companyId: userToImpersonate.company, \r\n+                username: userToImpersonate.username, // Importante para a rota /me\r\n+                impersonator: adminId\r\n+            },\r\n+            process.env.JWT_SECRET,\r\n+            { expiresIn: '1h' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Token de representação gerado com sucesso.',\r\n+            token,\r\n+            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n+            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao tentar representar usuário:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para testar manualmente o envio do relatório diário\r\n+router.post('/test-daily-report', async (req, res) => {\r\n+    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n+    if (!req.user.impersonator) {\r\n+        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n+    }\r\n+\r\n+    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n+    const company = req.company; // O middleware já nos deu a empresa representada\r\n+\r\n+    const today = new Date();\r\n+    today.setUTCHours(0, 0, 0, 0);\r\n+    const todayStr = today.toISOString().split('T')[0];\r\n+\r\n+    try {\r\n+        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n+        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n+        const overdueParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        const dueTodayParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n+        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n+\r\n+        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n+            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+            res.status(200).json({ \r\n+                message: `E-mail de relatório enviado para ${company.email}!`,\r\n+                overdueCount: overdueParcels.length,\r\n+                dueTodayCount: dueTodayParcels.length\r\n+            });\r\n+        } else {\r\n+            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n+            res.status(200).json({ \r\n+                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n+                overdueCount: 0,\r\n+                dueTodayCount: 0\r\n+            });\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('[TESTE MANUAL] Erro:', error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n+    }\r\n+});\r\n+\r\n+// --- GESTÃO DE ANÚNCIOS ---\r\n+\r\n+router.route('/announcements')\r\n+    // Rota para LER todos os anúncios\r\n+    .get(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n+            res.status(200).json(announcements);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao buscar anúncios:\", error);\r\n+            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n+        }\r\n+    })\r\n+    // Rota para CRIAR um novo anúncio\r\n+    .post(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const { message, link, isActive } = req.body;\r\n+\r\n+            if (!message) {\r\n+                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n+            }\r\n+\r\n+            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+            res.status(201).json(newAnnouncement);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao criar anúncio:\", error);\r\n+            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n+        }\r\n+    });\r\n+\r\n+// Rota para ATUALIZAR um anúncio\r\n+router.patch('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const { message, link, isActive } = req.body;\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        \r\n+        if (isActive) {\r\n+            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        }\r\n+\r\n+        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { message, link, isActive },\r\n+            { new: true }\r\n+        );\r\n+        res.status(200).json(updatedAnnouncement);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para APAGAR um anúncio\r\n+router.delete('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        await Announcement.findByIdAndDelete(req.params.id);\r\n+        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754061606313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,201 +10,65 @@\n const BoletoSchema = require('../models/Boleto').schema;\r\n const AnnouncementSchema = require('../models/Announcement').schema;\r\n \r\n \r\n-router.post('/impersonate', async (req, res) => {\r\n+// Nova rota para buscar as estatísticas do dashboard do admin\r\n+router.get('/dashboard-stats', async (req, res) => {\r\n+    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n+    // pelo middleware no seu ficheiro de servidor principal.\r\n+\r\n     try {\r\n-        const masterDb = req.masterDb;\r\n-        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-        const adminId = req.user.id;\r\n-        const { companyId, userId } = req.body;\r\n-        const userToImpersonate = await MasterUser.findById(userId);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n \r\n-        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n-             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n-        }\r\n-        \r\n-        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n-        if (!companyToImpersonate) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n+        // --- 1. Buscar os KPIs (Indicadores) ---\r\n+        const totalCompanies = await MasterCompany.countDocuments();\r\n+        const totalUsers = await MasterUser.countDocuments();\r\n+        const activeSubscriptions = await MasterCompany.countDocuments({\r\n+            'subscription.status': 'active'\r\n+        });\r\n \r\n-        const token = jwt.sign(\r\n-            { \r\n-                id: userToImpersonate._id,\r\n-                companyId: userToImpersonate.company, \r\n-                username: userToImpersonate.username, // Importante para a rota /me\r\n-                impersonator: adminId\r\n+        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n+        const thirtyDaysAgo = new Date();\r\n+        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n+\r\n+        const newCompaniesData = await MasterCompany.aggregate([\r\n+            // Filtra empresas criadas nos últimos 30 dias\r\n+            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n+            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n+            {\r\n+                $group: {\r\n+                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n+                    count: { $sum: 1 }\r\n+                }\r\n             },\r\n-            process.env.JWT_SECRET,\r\n-            { expiresIn: '1h' }\r\n-        );\r\n+            // Ordena por data\r\n+            { $sort: { _id: 1 } },\r\n+            // Formata a saída para o formato que o frontend espera\r\n+            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n+        ]);\r\n \r\n-        res.status(200).json({\r\n-            message: 'Token de representação gerado com sucesso.',\r\n-            token,\r\n-            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n-            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n+        // --- 3. Envia a resposta completa em formato JSON ---\r\n+        res.json({\r\n+            totalCompanies,\r\n+            totalUsers,\r\n+            activeSubscriptions,\r\n+            newCompaniesLast30Days: newCompaniesData\r\n         });\r\n \r\n     } catch (error) {\r\n-        console.error(\"Erro ao tentar representar usuário:\", error);\r\n+        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n         res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n     }\r\n });\r\n \r\n-// Rota para testar manualmente o envio do relatório diário\r\n-router.post('/test-daily-report', async (req, res) => {\r\n-    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n-    if (!req.user.impersonator) {\r\n-        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n-    }\r\n-\r\n-    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n-    const company = req.company; // O middleware já nos deu a empresa representada\r\n-\r\n-    const today = new Date();\r\n-    today.setUTCHours(0, 0, 0, 0);\r\n-    const todayStr = today.toISOString().split('T')[0];\r\n-\r\n-    try {\r\n-        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n-        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n-\r\n-        const overdueParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        const dueTodayParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n-        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n-\r\n-        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n-            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n-            res.status(200).json({ \r\n-                message: `E-mail de relatório enviado para ${company.email}!`,\r\n-                overdueCount: overdueParcels.length,\r\n-                dueTodayCount: dueTodayParcels.length\r\n-            });\r\n-        } else {\r\n-            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n-            res.status(200).json({ \r\n-                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n-                overdueCount: 0,\r\n-                dueTodayCount: 0\r\n-            });\r\n-        }\r\n-    } catch (error) {\r\n-        console.error('[TESTE MANUAL] Erro:', error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n-    }\r\n-});\r\n-\r\n-// --- GESTÃO DE ANÚNCIOS ---\r\n-\r\n-router.route('/announcements')\r\n-    // Rota para LER todos os anúncios\r\n-    .get(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n-            res.status(200).json(announcements);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao buscar anúncios:\", error);\r\n-            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n-        }\r\n-    })\r\n-    // Rota para CRIAR um novo anúncio\r\n-    .post(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const { message, link, isActive } = req.body;\r\n-\r\n-            if (!message) {\r\n-                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n-            }\r\n-\r\n-            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n-            res.status(201).json(newAnnouncement);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao criar anúncio:\", error);\r\n-            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n-        }\r\n-    });\r\n-\r\n-// Rota para ATUALIZAR um anúncio\r\n-router.patch('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const { message, link, isActive } = req.body;\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        \r\n-        if (isActive) {\r\n-            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n-        }\r\n-\r\n-        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { message, link, isActive },\r\n-            { new: true }\r\n-        );\r\n-        res.status(200).json(updatedAnnouncement);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para APAGAR um anúncio\r\n-router.delete('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        await Announcement.findByIdAndDelete(req.params.id);\r\n-        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const jwt = require('jsonwebtoken');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-const { getTenantConnection } = require('../config/db');\r\n-const { sendDailyReportEmail } = require('../services/emailService');\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n-const AnnouncementSchema = require('../models/Announcement').schema;\r\n-\r\n-\r\n router.post('/impersonate', async (req, res) => {\r\n     try {\r\n-        // --- CORREÇÃO PRINCIPAL AQUI ---\r\n-        // 1. Obtemos a conexão Mestre ativa que foi passada pelo middleware.\r\n         const masterDb = req.masterDb;\r\n-        // 2. Compilamos os modelos que vamos usar nesta conexão específica.\r\n         const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n         const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-        // --- FIM DA CORREÇÃO ---\r\n-\r\n         const adminId = req.user.id;\r\n         const { companyId, userId } = req.body;\r\n-        \r\n-        // 3. Agora a busca usa o modelo corretamente conectado, sem timeout.\r\n         const userToImpersonate = await MasterUser.findById(userId);\r\n \r\n         if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n              return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n@@ -310,12 +174,8 @@\n     })\r\n     // Rota para CRIAR um novo anúncio\r\n     .post(async (req, res) => {\r\n         try {\r\n-            // --- ADICIONE ESTA LINHA DE DEPURAÇÃO ---\r\n-            console.log('CORPO DO PEDIDO RECEBIDO:', req.body);\r\n-            // --- FIM DA LINHA DE DEPURAÇÃO ---\r\n-\r\n             const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n             const { message, link, isActive } = req.body;\r\n \r\n             if (!message) {\r\n"
                },
                {
                    "date": 1754062694414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,31 @@\n const BoletoSchema = require('../models/Boleto').schema;\r\n const AnnouncementSchema = require('../models/Announcement').schema;\r\n \r\n \r\n+// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n+router.get('/subscriptions', async (req, res) => {\r\n+    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n+    // que é aplicado a todo este ficheiro no seu server.js.\r\n+\r\n+    try {\r\n+        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // Busca todas as empresas, selecionando apenas os campos necessários\r\n+        const subscriptionsData = await MasterCompany.find({})\r\n+            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n+            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n+\r\n+        // Envia a lista como resposta JSON\r\n+        res.json(subscriptionsData);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n // Nova rota para buscar as estatísticas do dashboard do admin\r\n router.get('/dashboard-stats', async (req, res) => {\r\n     // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n     // pelo middleware no seu ficheiro de servidor principal.\r\n"
                },
                {
                    "date": 1754143918071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,280 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const jwt = require('jsonwebtoken');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { getTenantConnection } = require('../config/db');\r\n+const { sendDailyReportEmail } = require('../services/emailService');\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n+const AnnouncementSchema = require('../models/Announcement').schema;\r\n+const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n+\r\n+\r\n+// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n+router.get('/subscriptions', async (req, res) => {\r\n+    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n+    // que é aplicado a todo este ficheiro no seu server.js.\r\n+\r\n+    try {\r\n+        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // Busca todas as empresas, selecionando apenas os campos necessários\r\n+        const subscriptionsData = await MasterCompany.find({})\r\n+            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n+            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n+\r\n+        // Envia a lista como resposta JSON\r\n+        res.json(subscriptionsData);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Nova rota para buscar as estatísticas do dashboard do admin\r\n+router.get('/dashboard-stats', async (req, res) => {\r\n+    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n+    // pelo middleware no seu ficheiro de servidor principal.\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // --- 1. Buscar os KPIs (Indicadores) ---\r\n+        const totalCompanies = await MasterCompany.countDocuments();\r\n+        const totalUsers = await MasterUser.countDocuments();\r\n+        const activeSubscriptions = await MasterCompany.countDocuments({\r\n+            'subscription.status': 'active'\r\n+        });\r\n+\r\n+        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n+        const thirtyDaysAgo = new Date();\r\n+        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n+\r\n+        const newCompaniesData = await MasterCompany.aggregate([\r\n+            // Filtra empresas criadas nos últimos 30 dias\r\n+            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n+            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n+            {\r\n+                $group: {\r\n+                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n+                    count: { $sum: 1 }\r\n+                }\r\n+            },\r\n+            // Ordena por data\r\n+            { $sort: { _id: 1 } },\r\n+            // Formata a saída para o formato que o frontend espera\r\n+            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n+        ]);\r\n+\r\n+        // --- 3. Envia a resposta completa em formato JSON ---\r\n+        res.json({\r\n+            totalCompanies,\r\n+            totalUsers,\r\n+            activeSubscriptions,\r\n+            newCompaniesLast30Days: newCompaniesData\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/impersonate', async (req, res) => {\r\n+    try {\r\n+        const masterDb = req.masterDb;\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+        const adminId = req.user.id;\r\n+        const { companyId, userId } = req.body;\r\n+        const userToImpersonate = await MasterUser.findById(userId);\r\n+\r\n+        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n+             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n+        }\r\n+        \r\n+        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n+        if (!companyToImpersonate) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        const token = jwt.sign(\r\n+            { \r\n+                id: userToImpersonate._id,\r\n+                companyId: userToImpersonate.company, \r\n+                username: userToImpersonate.username, // Importante para a rota /me\r\n+                impersonator: adminId\r\n+            },\r\n+            process.env.JWT_SECRET,\r\n+            { expiresIn: '1h' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Token de representação gerado com sucesso.',\r\n+            token,\r\n+            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n+            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao tentar representar usuário:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para testar manualmente o envio do relatório diário\r\n+router.post('/test-daily-report', async (req, res) => {\r\n+    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n+    if (!req.user.impersonator) {\r\n+        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n+    }\r\n+\r\n+    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n+    const company = req.company; // O middleware já nos deu a empresa representada\r\n+\r\n+    const today = new Date();\r\n+    today.setUTCHours(0, 0, 0, 0);\r\n+    const todayStr = today.toISOString().split('T')[0];\r\n+\r\n+    try {\r\n+        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n+        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n+        const overdueParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        const dueTodayParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n+        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n+\r\n+        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n+            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+            res.status(200).json({ \r\n+                message: `E-mail de relatório enviado para ${company.email}!`,\r\n+                overdueCount: overdueParcels.length,\r\n+                dueTodayCount: dueTodayParcels.length\r\n+            });\r\n+        } else {\r\n+            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n+            res.status(200).json({ \r\n+                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n+                overdueCount: 0,\r\n+                dueTodayCount: 0\r\n+            });\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('[TESTE MANUAL] Erro:', error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n+    }\r\n+});\r\n+\r\n+// --- GESTÃO DE ANÚNCIOS ---\r\n+\r\n+router.route('/announcements')\r\n+    // Rota para LER todos os anúncios\r\n+    .get(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n+            res.status(200).json(announcements);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao buscar anúncios:\", error);\r\n+            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n+        }\r\n+    })\r\n+    // Rota para CRIAR um novo anúncio\r\n+    .post(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const { message, link, isActive } = req.body;\r\n+\r\n+            if (!message) {\r\n+                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n+            }\r\n+\r\n+            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+            res.status(201).json(newAnnouncement);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao criar anúncio:\", error);\r\n+            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n+        }\r\n+    });\r\n+\r\n+// Rota para ATUALIZAR um anúncio\r\n+router.patch('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const { message, link, isActive } = req.body;\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        \r\n+        if (isActive) {\r\n+            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        }\r\n+\r\n+        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { message, link, isActive },\r\n+            { new: true }\r\n+        );\r\n+        res.status(200).json(updatedAnnouncement);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para APAGAR um anúncio\r\n+router.delete('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        await Announcement.findByIdAndDelete(req.params.id);\r\n+        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER todos os templates de e-mail\r\n+router.get('/email-templates', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n+        res.json(templates);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR um template específico\r\n+router.patch('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const { subject, body } = req.body;\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n+            req.params.templateId,\r\n+            { subject, body },\r\n+            { new: true }\r\n+        );\r\n+        res.json(updatedTemplate);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754145315555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,294 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const jwt = require('jsonwebtoken');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { getTenantConnection } = require('../config/db');\r\n+const { sendDailyReportEmail } = require('../services/emailService');\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n+const AnnouncementSchema = require('../models/Announcement').schema;\r\n+const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n+\r\n+\r\n+// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n+router.get('/subscriptions', async (req, res) => {\r\n+    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n+    // que é aplicado a todo este ficheiro no seu server.js.\r\n+\r\n+    try {\r\n+        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // Busca todas as empresas, selecionando apenas os campos necessários\r\n+        const subscriptionsData = await MasterCompany.find({})\r\n+            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n+            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n+\r\n+        // Envia a lista como resposta JSON\r\n+        res.json(subscriptionsData);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Nova rota para buscar as estatísticas do dashboard do admin\r\n+router.get('/dashboard-stats', async (req, res) => {\r\n+    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n+    // pelo middleware no seu ficheiro de servidor principal.\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // --- 1. Buscar os KPIs (Indicadores) ---\r\n+        const totalCompanies = await MasterCompany.countDocuments();\r\n+        const totalUsers = await MasterUser.countDocuments();\r\n+        const activeSubscriptions = await MasterCompany.countDocuments({\r\n+            'subscription.status': 'active'\r\n+        });\r\n+\r\n+        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n+        const thirtyDaysAgo = new Date();\r\n+        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n+\r\n+        const newCompaniesData = await MasterCompany.aggregate([\r\n+            // Filtra empresas criadas nos últimos 30 dias\r\n+            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n+            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n+            {\r\n+                $group: {\r\n+                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n+                    count: { $sum: 1 }\r\n+                }\r\n+            },\r\n+            // Ordena por data\r\n+            { $sort: { _id: 1 } },\r\n+            // Formata a saída para o formato que o frontend espera\r\n+            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n+        ]);\r\n+\r\n+        // --- 3. Envia a resposta completa em formato JSON ---\r\n+        res.json({\r\n+            totalCompanies,\r\n+            totalUsers,\r\n+            activeSubscriptions,\r\n+            newCompaniesLast30Days: newCompaniesData\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/impersonate', async (req, res) => {\r\n+    try {\r\n+        const masterDb = req.masterDb;\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+        const adminId = req.user.id;\r\n+        const { companyId, userId } = req.body;\r\n+        const userToImpersonate = await MasterUser.findById(userId);\r\n+\r\n+        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n+             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n+        }\r\n+        \r\n+        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n+        if (!companyToImpersonate) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        const token = jwt.sign(\r\n+            { \r\n+                id: userToImpersonate._id,\r\n+                companyId: userToImpersonate.company, \r\n+                username: userToImpersonate.username, // Importante para a rota /me\r\n+                impersonator: adminId\r\n+            },\r\n+            process.env.JWT_SECRET,\r\n+            { expiresIn: '1h' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Token de representação gerado com sucesso.',\r\n+            token,\r\n+            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n+            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao tentar representar usuário:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para testar manualmente o envio do relatório diário\r\n+router.post('/test-daily-report', async (req, res) => {\r\n+    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n+    if (!req.user.impersonator) {\r\n+        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n+    }\r\n+\r\n+    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n+    const company = req.company; // O middleware já nos deu a empresa representada\r\n+\r\n+    const today = new Date();\r\n+    today.setUTCHours(0, 0, 0, 0);\r\n+    const todayStr = today.toISOString().split('T')[0];\r\n+\r\n+    try {\r\n+        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n+        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n+        const overdueParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        const dueTodayParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n+        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n+\r\n+        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n+            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+            res.status(200).json({ \r\n+                message: `E-mail de relatório enviado para ${company.email}!`,\r\n+                overdueCount: overdueParcels.length,\r\n+                dueTodayCount: dueTodayParcels.length\r\n+            });\r\n+        } else {\r\n+            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n+            res.status(200).json({ \r\n+                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n+                overdueCount: 0,\r\n+                dueTodayCount: 0\r\n+            });\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('[TESTE MANUAL] Erro:', error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n+    }\r\n+});\r\n+\r\n+// --- GESTÃO DE ANÚNCIOS ---\r\n+\r\n+router.route('/announcements')\r\n+    // Rota para LER todos os anúncios\r\n+    .get(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n+            res.status(200).json(announcements);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao buscar anúncios:\", error);\r\n+            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n+        }\r\n+    })\r\n+    // Rota para CRIAR um novo anúncio\r\n+    .post(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const { message, link, isActive } = req.body;\r\n+\r\n+            if (!message) {\r\n+                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n+            }\r\n+\r\n+            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+            res.status(201).json(newAnnouncement);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao criar anúncio:\", error);\r\n+            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n+        }\r\n+    });\r\n+\r\n+// Rota para ATUALIZAR um anúncio\r\n+router.patch('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const { message, link, isActive } = req.body;\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        \r\n+        if (isActive) {\r\n+            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        }\r\n+\r\n+        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { message, link, isActive },\r\n+            { new: true }\r\n+        );\r\n+        res.status(200).json(updatedAnnouncement);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para APAGAR um anúncio\r\n+router.delete('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        await Announcement.findByIdAndDelete(req.params.id);\r\n+        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER todos os templates de e-mail\r\n+router.get('/email-templates', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n+        res.json(templates);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER UM template de e-mail específico pelo ID\r\n+router.get('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const template = await EmailTemplate.findById(req.params.templateId);\r\n+        if (!template) {\r\n+            return res.status(404).json({ message: 'Template não encontrado.' });\r\n+        }\r\n+        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR um template específico\r\n+router.patch('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const { subject, body } = req.body;\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n+            req.params.templateId,\r\n+            { subject, body },\r\n+            { new: true }\r\n+        );\r\n+        res.json(updatedTemplate);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754163174045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,337 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const jwt = require('jsonwebtoken');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { getTenantConnection } = require('../config/db');\r\n+const { sendDailyReportEmail } = require('../services/emailService');\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n+const AnnouncementSchema = require('../models/Announcement').schema;\r\n+const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n+\r\n+\r\n+// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n+router.get('/subscriptions', async (req, res) => {\r\n+    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n+    // que é aplicado a todo este ficheiro no seu server.js.\r\n+\r\n+    try {\r\n+        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // Busca todas as empresas, selecionando apenas os campos necessários\r\n+        const subscriptionsData = await MasterCompany.find({})\r\n+            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n+            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n+\r\n+        // Envia a lista como resposta JSON\r\n+        res.json(subscriptionsData);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Nova rota para buscar as estatísticas do dashboard do admin\r\n+router.get('/dashboard-stats', async (req, res) => {\r\n+    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n+    // pelo middleware no seu ficheiro de servidor principal.\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // --- 1. Buscar os KPIs (Indicadores) ---\r\n+        const totalCompanies = await MasterCompany.countDocuments();\r\n+        const totalUsers = await MasterUser.countDocuments();\r\n+        const activeSubscriptions = await MasterCompany.countDocuments({\r\n+            'subscription.status': 'active'\r\n+        });\r\n+\r\n+        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n+        const thirtyDaysAgo = new Date();\r\n+        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n+\r\n+        const newCompaniesData = await MasterCompany.aggregate([\r\n+            // Filtra empresas criadas nos últimos 30 dias\r\n+            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n+            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n+            {\r\n+                $group: {\r\n+                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n+                    count: { $sum: 1 }\r\n+                }\r\n+            },\r\n+            // Ordena por data\r\n+            { $sort: { _id: 1 } },\r\n+            // Formata a saída para o formato que o frontend espera\r\n+            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n+        ]);\r\n+\r\n+        // --- 3. Envia a resposta completa em formato JSON ---\r\n+        res.json({\r\n+            totalCompanies,\r\n+            totalUsers,\r\n+            activeSubscriptions,\r\n+            newCompaniesLast30Days: newCompaniesData\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/impersonate', async (req, res) => {\r\n+    try {\r\n+        const masterDb = req.masterDb;\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+        const adminId = req.user.id;\r\n+        const { companyId, userId } = req.body;\r\n+        const userToImpersonate = await MasterUser.findById(userId);\r\n+\r\n+        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n+             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n+        }\r\n+        \r\n+        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n+        if (!companyToImpersonate) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        const token = jwt.sign(\r\n+            { \r\n+                id: userToImpersonate._id,\r\n+                companyId: userToImpersonate.company, \r\n+                username: userToImpersonate.username, // Importante para a rota /me\r\n+                impersonator: adminId\r\n+            },\r\n+            process.env.JWT_SECRET,\r\n+            { expiresIn: '1h' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Token de representação gerado com sucesso.',\r\n+            token,\r\n+            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n+            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao tentar representar usuário:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para testar manualmente o envio do relatório diário\r\n+router.post('/test-daily-report', async (req, res) => {\r\n+    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n+    if (!req.user.impersonator) {\r\n+        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n+    }\r\n+\r\n+    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n+    const company = req.company; // O middleware já nos deu a empresa representada\r\n+\r\n+    const today = new Date();\r\n+    today.setUTCHours(0, 0, 0, 0);\r\n+    const todayStr = today.toISOString().split('T')[0];\r\n+\r\n+    try {\r\n+        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n+        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n+        const overdueParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        const dueTodayParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n+        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n+\r\n+        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n+            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+            res.status(200).json({ \r\n+                message: `E-mail de relatório enviado para ${company.email}!`,\r\n+                overdueCount: overdueParcels.length,\r\n+                dueTodayCount: dueTodayParcels.length\r\n+            });\r\n+        } else {\r\n+            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n+            res.status(200).json({ \r\n+                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n+                overdueCount: 0,\r\n+                dueTodayCount: 0\r\n+            });\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('[TESTE MANUAL] Erro:', error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n+    }\r\n+});\r\n+\r\n+// --- GESTÃO DE ANÚNCIOS ---\r\n+\r\n+router.route('/announcements')\r\n+    // Rota para LER todos os anúncios\r\n+    .get(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n+            res.status(200).json(announcements);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao buscar anúncios:\", error);\r\n+            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n+        }\r\n+    })\r\n+    // Rota para CRIAR um novo anúncio\r\n+    .post(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const { message, link, isActive } = req.body;\r\n+\r\n+            if (!message) {\r\n+                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n+            }\r\n+\r\n+            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+            res.status(201).json(newAnnouncement);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao criar anúncio:\", error);\r\n+            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n+        }\r\n+    });\r\n+\r\n+// Rota para ATUALIZAR um anúncio\r\n+router.patch('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const { message, link, isActive } = req.body;\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        \r\n+        if (isActive) {\r\n+            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        }\r\n+\r\n+        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { message, link, isActive },\r\n+            { new: true }\r\n+        );\r\n+        res.status(200).json(updatedAnnouncement);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para APAGAR um anúncio\r\n+router.delete('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        await Announcement.findByIdAndDelete(req.params.id);\r\n+        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER todos os templates de e-mail\r\n+router.get('/email-templates', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n+        res.json(templates);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER UM template de e-mail específico pelo ID\r\n+router.get('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const template = await EmailTemplate.findById(req.params.templateId);\r\n+        if (!template) {\r\n+            return res.status(404).json({ message: 'Template não encontrado.' });\r\n+        }\r\n+        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR um template específico\r\n+router.patch('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const { subject, body } = req.body;\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n+            req.params.templateId,\r\n+            { subject, body },\r\n+            { new: true }\r\n+        );\r\n+        res.json(updatedTemplate);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota de pesquisa global para o admin\r\n+router.get('/search', async (req, res) => {\r\n+    try {\r\n+        const query = req.query.q || ''; // 'q' vem de \"query\"\r\n+        if (query.length < 2) {\r\n+            // Evita pesquisas vazias ou muito curtas para não sobrecarregar o DB\r\n+            return res.json({ users: [], companies: [] });\r\n+        }\r\n+\r\n+        // Cria uma expressão regular para pesquisa case-insensitive\r\n+        const searchRegex = new RegExp(query, 'i');\r\n+\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // 1. Pesquisa por Utilizadores (no username e email)\r\n+        const userResults = await MasterUser.find({\r\n+            $or: [\r\n+                { username: searchRegex },\r\n+                { email: searchRegex }\r\n+            ]\r\n+        }).populate('company', 'nomeEmpresa'); // Inclui o nome da empresa no resultado\r\n+\r\n+        // 2. Pesquisa por Empresas (no nome e CNPJ)\r\n+        const companyResults = await MasterCompany.find({\r\n+            $or: [\r\n+                { nomeEmpresa: searchRegex },\r\n+                { cnpj: query.replace(/\\D/g, '') } // Pesquisa por CNPJ apenas com números\r\n+            ]\r\n+        });\r\n+\r\n+        // 3. Retorna os resultados em um objeto organizado\r\n+        res.json({\r\n+            users: userResults,\r\n+            companies: companyResults\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro na pesquisa global do admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754164419447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -333,831 +333,48 @@\n         res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n     }\r\n });\r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const jwt = require('jsonwebtoken');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-const { getTenantConnection } = require('../config/db');\r\n-const { sendDailyReportEmail } = require('../services/emailService');\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n-const AnnouncementSchema = require('../models/Announcement').schema;\r\n-const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n-\r\n-\r\n-// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n-router.get('/subscriptions', async (req, res) => {\r\n-    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n-    // que é aplicado a todo este ficheiro no seu server.js.\r\n-\r\n+router.post('/bulk-email', async (req, res) => {\r\n     try {\r\n-        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // Busca todas as empresas, selecionando apenas os campos necessários\r\n-        const subscriptionsData = await MasterCompany.find({})\r\n-            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n-            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n-\r\n-        // Envia a lista como resposta JSON\r\n-        res.json(subscriptionsData);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Nova rota para buscar as estatísticas do dashboard do admin\r\n-router.get('/dashboard-stats', async (req, res) => {\r\n-    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n-    // pelo middleware no seu ficheiro de servidor principal.\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { audience, subject, body } = req.body;\r\n         const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // --- 1. Buscar os KPIs (Indicadores) ---\r\n-        const totalCompanies = await MasterCompany.countDocuments();\r\n-        const totalUsers = await MasterUser.countDocuments();\r\n-        const activeSubscriptions = await MasterCompany.countDocuments({\r\n-            'subscription.status': 'active'\r\n-        });\r\n-\r\n-        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n-        const thirtyDaysAgo = new Date();\r\n-        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n-\r\n-        const newCompaniesData = await MasterCompany.aggregate([\r\n-            // Filtra empresas criadas nos últimos 30 dias\r\n-            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n-            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n-            {\r\n-                $group: {\r\n-                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n-                    count: { $sum: 1 }\r\n-                }\r\n-            },\r\n-            // Ordena por data\r\n-            { $sort: { _id: 1 } },\r\n-            // Formata a saída para o formato que o frontend espera\r\n-            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n-        ]);\r\n-\r\n-        // --- 3. Envia a resposta completa em formato JSON ---\r\n-        res.json({\r\n-            totalCompanies,\r\n-            totalUsers,\r\n-            activeSubscriptions,\r\n-            newCompaniesLast30Days: newCompaniesData\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/impersonate', async (req, res) => {\r\n-    try {\r\n-        const masterDb = req.masterDb;\r\n-        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-        const adminId = req.user.id;\r\n-        const { companyId, userId } = req.body;\r\n-        const userToImpersonate = await MasterUser.findById(userId);\r\n-\r\n-        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n-             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n-        }\r\n-        \r\n-        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n-        if (!companyToImpersonate) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        const token = jwt.sign(\r\n-            { \r\n-                id: userToImpersonate._id,\r\n-                companyId: userToImpersonate.company, \r\n-                username: userToImpersonate.username, // Importante para a rota /me\r\n-                impersonator: adminId\r\n-            },\r\n-            process.env.JWT_SECRET,\r\n-            { expiresIn: '1h' }\r\n-        );\r\n-\r\n-        res.status(200).json({\r\n-            message: 'Token de representação gerado com sucesso.',\r\n-            token,\r\n-            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n-            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao tentar representar usuário:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota para testar manualmente o envio do relatório diário\r\n-router.post('/test-daily-report', async (req, res) => {\r\n-    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n-    if (!req.user.impersonator) {\r\n-        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n-    }\r\n-\r\n-    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n-    const company = req.company; // O middleware já nos deu a empresa representada\r\n-\r\n-    const today = new Date();\r\n-    today.setUTCHours(0, 0, 0, 0);\r\n-    const todayStr = today.toISOString().split('T')[0];\r\n-\r\n-    try {\r\n-        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n-        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n-\r\n-        const overdueParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        const dueTodayParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n-        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n-\r\n-        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n-            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n-            res.status(200).json({ \r\n-                message: `E-mail de relatório enviado para ${company.email}!`,\r\n-                overdueCount: overdueParcels.length,\r\n-                dueTodayCount: dueTodayParcels.length\r\n-            });\r\n-        } else {\r\n-            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n-            res.status(200).json({ \r\n-                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n-                overdueCount: 0,\r\n-                dueTodayCount: 0\r\n-            });\r\n-        }\r\n-    } catch (error) {\r\n-        console.error('[TESTE MANUAL] Erro:', error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n-    }\r\n-});\r\n-\r\n-// --- GESTÃO DE ANÚNCIOS ---\r\n-\r\n-router.route('/announcements')\r\n-    // Rota para LER todos os anúncios\r\n-    .get(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n-            res.status(200).json(announcements);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao buscar anúncios:\", error);\r\n-            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n-        }\r\n-    })\r\n-    // Rota para CRIAR um novo anúncio\r\n-    .post(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const { message, link, isActive } = req.body;\r\n-\r\n-            if (!message) {\r\n-                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n-            }\r\n-\r\n-            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n-            res.status(201).json(newAnnouncement);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao criar anúncio:\", error);\r\n-            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n-        }\r\n-    });\r\n-\r\n-// Rota para ATUALIZAR um anúncio\r\n-router.patch('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const { message, link, isActive } = req.body;\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        \r\n-        if (isActive) {\r\n-            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n-        }\r\n-\r\n-        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { message, link, isActive },\r\n-            { new: true }\r\n-        );\r\n-        res.status(200).json(updatedAnnouncement);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para APAGAR um anúncio\r\n-router.delete('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        await Announcement.findByIdAndDelete(req.params.id);\r\n-        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER todos os templates de e-mail\r\n-router.get('/email-templates', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n-        res.json(templates);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER UM template de e-mail específico pelo ID\r\n-router.get('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const template = await EmailTemplate.findById(req.params.templateId);\r\n-        if (!template) {\r\n-            return res.status(404).json({ message: 'Template não encontrado.' });\r\n-        }\r\n-        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR um template específico\r\n-router.patch('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const { subject, body } = req.body;\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n-            req.params.templateId,\r\n-            { subject, body },\r\n-            { new: true }\r\n-        );\r\n-        res.json(updatedTemplate);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const jwt = require('jsonwebtoken');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-const { getTenantConnection } = require('../config/db');\r\n-const { sendDailyReportEmail } = require('../services/emailService');\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n-const AnnouncementSchema = require('../models/Announcement').schema;\r\n-const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n-\r\n-\r\n-// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n-router.get('/subscriptions', async (req, res) => {\r\n-    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n-    // que é aplicado a todo este ficheiro no seu server.js.\r\n-\r\n-    try {\r\n-        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n         const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n \r\n-        // Busca todas as empresas, selecionando apenas os campos necessários\r\n-        const subscriptionsData = await MasterCompany.find({})\r\n-            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n-            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n-\r\n-        // Envia a lista como resposta JSON\r\n-        res.json(subscriptionsData);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Nova rota para buscar as estatísticas do dashboard do admin\r\n-router.get('/dashboard-stats', async (req, res) => {\r\n-    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n-    // pelo middleware no seu ficheiro de servidor principal.\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // --- 1. Buscar os KPIs (Indicadores) ---\r\n-        const totalCompanies = await MasterCompany.countDocuments();\r\n-        const totalUsers = await MasterUser.countDocuments();\r\n-        const activeSubscriptions = await MasterCompany.countDocuments({\r\n-            'subscription.status': 'active'\r\n-        });\r\n-\r\n-        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n-        const thirtyDaysAgo = new Date();\r\n-        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n-\r\n-        const newCompaniesData = await MasterCompany.aggregate([\r\n-            // Filtra empresas criadas nos últimos 30 dias\r\n-            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n-            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n-            {\r\n-                $group: {\r\n-                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n-                    count: { $sum: 1 }\r\n-                }\r\n-            },\r\n-            // Ordena por data\r\n-            { $sort: { _id: 1 } },\r\n-            // Formata a saída para o formato que o frontend espera\r\n-            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n-        ]);\r\n-\r\n-        // --- 3. Envia a resposta completa em formato JSON ---\r\n-        res.json({\r\n-            totalCompanies,\r\n-            totalUsers,\r\n-            activeSubscriptions,\r\n-            newCompaniesLast30Days: newCompaniesData\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/impersonate', async (req, res) => {\r\n-    try {\r\n-        const masterDb = req.masterDb;\r\n-        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-        const adminId = req.user.id;\r\n-        const { companyId, userId } = req.body;\r\n-        const userToImpersonate = await MasterUser.findById(userId);\r\n-\r\n-        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n-             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n+        let recipients = [];\r\n+        switch (audience) {\r\n+            case 'allProprietors':\r\n+                recipients = await MasterUser.find({ role: 'Proprietário' }).select('email');\r\n+                break;\r\n+            case 'activeSubscribers':\r\n+                const activeCompanies = await MasterCompany.find({ 'subscription.status': 'active' }).select('_id');\r\n+                const activeCompanyIds = activeCompanies.map(c => c._id);\r\n+                recipients = await MasterUser.find({ company: { $in: activeCompanyIds }, role: 'Proprietário' }).select('email');\r\n+                break;\r\n+            // (Pode adicionar outros casos como 'inactiveSubscribers' e 'allUsers' aqui)\r\n+            default:\r\n+                return res.status(400).json({ message: 'Público-alvo inválido.' });\r\n         }\r\n-        \r\n-        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n-        if (!companyToImpersonate) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n \r\n-        const token = jwt.sign(\r\n-            { \r\n-                id: userToImpersonate._id,\r\n-                companyId: userToImpersonate.company, \r\n-                username: userToImpersonate.username, // Importante para a rota /me\r\n-                impersonator: adminId\r\n-            },\r\n-            process.env.JWT_SECRET,\r\n-            { expiresIn: '1h' }\r\n-        );\r\n+        const emailList = recipients.map(r => r.email);\r\n \r\n-        res.status(200).json({\r\n-            message: 'Token de representação gerado com sucesso.',\r\n-            token,\r\n-            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n-            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao tentar representar usuário:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota para testar manualmente o envio do relatório diário\r\n-router.post('/test-daily-report', async (req, res) => {\r\n-    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n-    if (!req.user.impersonator) {\r\n-        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n-    }\r\n-\r\n-    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n-    const company = req.company; // O middleware já nos deu a empresa representada\r\n-\r\n-    const today = new Date();\r\n-    today.setUTCHours(0, 0, 0, 0);\r\n-    const todayStr = today.toISOString().split('T')[0];\r\n-\r\n-    try {\r\n-        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n-        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n-\r\n-        const overdueParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        const dueTodayParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n-        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n-\r\n-        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n-            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n-            res.status(200).json({ \r\n-                message: `E-mail de relatório enviado para ${company.email}!`,\r\n-                overdueCount: overdueParcels.length,\r\n-                dueTodayCount: dueTodayParcels.length\r\n-            });\r\n-        } else {\r\n-            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n-            res.status(200).json({ \r\n-                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n-                overdueCount: 0,\r\n-                dueTodayCount: 0\r\n-            });\r\n+        if (emailList.length === 0) {\r\n+            return res.status(404).json({ message: 'Nenhum destinatário encontrado para este público.' });\r\n         }\r\n-    } catch (error) {\r\n-        console.error('[TESTE MANUAL] Erro:', error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n-    }\r\n-});\r\n-\r\n-// --- GESTÃO DE ANÚNCIOS ---\r\n-\r\n-router.route('/announcements')\r\n-    // Rota para LER todos os anúncios\r\n-    .get(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n-            res.status(200).json(announcements);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao buscar anúncios:\", error);\r\n-            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n-        }\r\n-    })\r\n-    // Rota para CRIAR um novo anúncio\r\n-    .post(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const { message, link, isActive } = req.body;\r\n-\r\n-            if (!message) {\r\n-                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n-            }\r\n-\r\n-            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n-            res.status(201).json(newAnnouncement);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao criar anúncio:\", error);\r\n-            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n-        }\r\n-    });\r\n-\r\n-// Rota para ATUALIZAR um anúncio\r\n-router.patch('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const { message, link, isActive } = req.body;\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n         \r\n-        if (isActive) {\r\n-            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        // AVISO: A lógica abaixo envia e-mails em sequência.\r\n+        // Para um grande número de utilizadores, isto pode ser lento e causar timeout.\r\n+        // A solução ideal para produção é um sistema de filas (queue).\r\n+        for (const email of emailList) {\r\n+            // Aqui você chamaria uma função genérica do seu emailService\r\n+            // await emailService.sendGenericEmail(email, subject, body);\r\n         }\r\n \r\n-        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { message, link, isActive },\r\n-            { new: true }\r\n-        );\r\n-        res.status(200).json(updatedAnnouncement);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n-    }\r\n-});\r\n+        res.json({ message: `E-mail enviado para ${emailList.length} destinatários.` });\r\n \r\n-// Rota para APAGAR um anúncio\r\n-router.delete('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        await Announcement.findByIdAndDelete(req.params.id);\r\n-        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n     } catch (error) {\r\n-        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER todos os templates de e-mail\r\n-router.get('/email-templates', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n-        res.json(templates);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR um template específico\r\n-router.patch('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const { subject, body } = req.body;\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n-            req.params.templateId,\r\n-            { subject, body },\r\n-            { new: true }\r\n-        );\r\n-        res.json(updatedTemplate);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const jwt = require('jsonwebtoken');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-const { getTenantConnection } = require('../config/db');\r\n-const { sendDailyReportEmail } = require('../services/emailService');\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n-const AnnouncementSchema = require('../models/Announcement').schema;\r\n-\r\n-\r\n-// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n-router.get('/subscriptions', async (req, res) => {\r\n-    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n-    // que é aplicado a todo este ficheiro no seu server.js.\r\n-\r\n-    try {\r\n-        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // Busca todas as empresas, selecionando apenas os campos necessários\r\n-        const subscriptionsData = await MasterCompany.find({})\r\n-            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n-            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n-\r\n-        // Envia a lista como resposta JSON\r\n-        res.json(subscriptionsData);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n+        console.error(\"Erro no envio de e-mail em massa:\", error);\r\n         res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n     }\r\n });\r\n \r\n-// Nova rota para buscar as estatísticas do dashboard do admin\r\n-router.get('/dashboard-stats', async (req, res) => {\r\n-    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n-    // pelo middleware no seu ficheiro de servidor principal.\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // --- 1. Buscar os KPIs (Indicadores) ---\r\n-        const totalCompanies = await MasterCompany.countDocuments();\r\n-        const totalUsers = await MasterUser.countDocuments();\r\n-        const activeSubscriptions = await MasterCompany.countDocuments({\r\n-            'subscription.status': 'active'\r\n-        });\r\n-\r\n-        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n-        const thirtyDaysAgo = new Date();\r\n-        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n-\r\n-        const newCompaniesData = await MasterCompany.aggregate([\r\n-            // Filtra empresas criadas nos últimos 30 dias\r\n-            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n-            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n-            {\r\n-                $group: {\r\n-                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n-                    count: { $sum: 1 }\r\n-                }\r\n-            },\r\n-            // Ordena por data\r\n-            { $sort: { _id: 1 } },\r\n-            // Formata a saída para o formato que o frontend espera\r\n-            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n-        ]);\r\n-\r\n-        // --- 3. Envia a resposta completa em formato JSON ---\r\n-        res.json({\r\n-            totalCompanies,\r\n-            totalUsers,\r\n-            activeSubscriptions,\r\n-            newCompaniesLast30Days: newCompaniesData\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/impersonate', async (req, res) => {\r\n-    try {\r\n-        const masterDb = req.masterDb;\r\n-        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-        const adminId = req.user.id;\r\n-        const { companyId, userId } = req.body;\r\n-        const userToImpersonate = await MasterUser.findById(userId);\r\n-\r\n-        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n-             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n-        }\r\n-        \r\n-        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n-        if (!companyToImpersonate) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        const token = jwt.sign(\r\n-            { \r\n-                id: userToImpersonate._id,\r\n-                companyId: userToImpersonate.company, \r\n-                username: userToImpersonate.username, // Importante para a rota /me\r\n-                impersonator: adminId\r\n-            },\r\n-            process.env.JWT_SECRET,\r\n-            { expiresIn: '1h' }\r\n-        );\r\n-\r\n-        res.status(200).json({\r\n-            message: 'Token de representação gerado com sucesso.',\r\n-            token,\r\n-            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n-            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao tentar representar usuário:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota para testar manualmente o envio do relatório diário\r\n-router.post('/test-daily-report', async (req, res) => {\r\n-    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n-    if (!req.user.impersonator) {\r\n-        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n-    }\r\n-\r\n-    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n-    const company = req.company; // O middleware já nos deu a empresa representada\r\n-\r\n-    const today = new Date();\r\n-    today.setUTCHours(0, 0, 0, 0);\r\n-    const todayStr = today.toISOString().split('T')[0];\r\n-\r\n-    try {\r\n-        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n-        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n-\r\n-        const overdueParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        const dueTodayParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n-        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n-\r\n-        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n-            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n-            res.status(200).json({ \r\n-                message: `E-mail de relatório enviado para ${company.email}!`,\r\n-                overdueCount: overdueParcels.length,\r\n-                dueTodayCount: dueTodayParcels.length\r\n-            });\r\n-        } else {\r\n-            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n-            res.status(200).json({ \r\n-                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n-                overdueCount: 0,\r\n-                dueTodayCount: 0\r\n-            });\r\n-        }\r\n-    } catch (error) {\r\n-        console.error('[TESTE MANUAL] Erro:', error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n-    }\r\n-});\r\n-\r\n-// --- GESTÃO DE ANÚNCIOS ---\r\n-\r\n-router.route('/announcements')\r\n-    // Rota para LER todos os anúncios\r\n-    .get(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n-            res.status(200).json(announcements);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao buscar anúncios:\", error);\r\n-            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n-        }\r\n-    })\r\n-    // Rota para CRIAR um novo anúncio\r\n-    .post(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const { message, link, isActive } = req.body;\r\n-\r\n-            if (!message) {\r\n-                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n-            }\r\n-\r\n-            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n-            res.status(201).json(newAnnouncement);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao criar anúncio:\", error);\r\n-            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n-        }\r\n-    });\r\n-\r\n-// Rota para ATUALIZAR um anúncio\r\n-router.patch('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const { message, link, isActive } = req.body;\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        \r\n-        if (isActive) {\r\n-            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n-        }\r\n-\r\n-        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { message, link, isActive },\r\n-            { new: true }\r\n-        );\r\n-        res.status(200).json(updatedAnnouncement);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para APAGAR um anúncio\r\n-router.delete('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        await Announcement.findByIdAndDelete(req.params.id);\r\n-        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754164878818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,381 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const jwt = require('jsonwebtoken');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { getTenantConnection } = require('../config/db');\r\n+const { sendDailyReportEmail } = require('../services/emailService');\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n+const AnnouncementSchema = require('../models/Announcement').schema;\r\n+const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n+const emailService = require('../services/emailService');\r\n+\r\n+\r\n+// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n+router.get('/subscriptions', async (req, res) => {\r\n+    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n+    // que é aplicado a todo este ficheiro no seu server.js.\r\n+\r\n+    try {\r\n+        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // Busca todas as empresas, selecionando apenas os campos necessários\r\n+        const subscriptionsData = await MasterCompany.find({})\r\n+            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n+            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n+\r\n+        // Envia a lista como resposta JSON\r\n+        res.json(subscriptionsData);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Nova rota para buscar as estatísticas do dashboard do admin\r\n+router.get('/dashboard-stats', async (req, res) => {\r\n+    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n+    // pelo middleware no seu ficheiro de servidor principal.\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // --- 1. Buscar os KPIs (Indicadores) ---\r\n+        const totalCompanies = await MasterCompany.countDocuments();\r\n+        const totalUsers = await MasterUser.countDocuments();\r\n+        const activeSubscriptions = await MasterCompany.countDocuments({\r\n+            'subscription.status': 'active'\r\n+        });\r\n+\r\n+        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n+        const thirtyDaysAgo = new Date();\r\n+        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n+\r\n+        const newCompaniesData = await MasterCompany.aggregate([\r\n+            // Filtra empresas criadas nos últimos 30 dias\r\n+            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n+            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n+            {\r\n+                $group: {\r\n+                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n+                    count: { $sum: 1 }\r\n+                }\r\n+            },\r\n+            // Ordena por data\r\n+            { $sort: { _id: 1 } },\r\n+            // Formata a saída para o formato que o frontend espera\r\n+            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n+        ]);\r\n+\r\n+        // --- 3. Envia a resposta completa em formato JSON ---\r\n+        res.json({\r\n+            totalCompanies,\r\n+            totalUsers,\r\n+            activeSubscriptions,\r\n+            newCompaniesLast30Days: newCompaniesData\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/impersonate', async (req, res) => {\r\n+    try {\r\n+        const masterDb = req.masterDb;\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+        const adminId = req.user.id;\r\n+        const { companyId, userId } = req.body;\r\n+        const userToImpersonate = await MasterUser.findById(userId);\r\n+\r\n+        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n+             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n+        }\r\n+        \r\n+        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n+        if (!companyToImpersonate) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        const token = jwt.sign(\r\n+            { \r\n+                id: userToImpersonate._id,\r\n+                companyId: userToImpersonate.company, \r\n+                username: userToImpersonate.username, // Importante para a rota /me\r\n+                impersonator: adminId\r\n+            },\r\n+            process.env.JWT_SECRET,\r\n+            { expiresIn: '1h' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Token de representação gerado com sucesso.',\r\n+            token,\r\n+            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n+            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao tentar representar usuário:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para testar manualmente o envio do relatório diário\r\n+router.post('/test-daily-report', async (req, res) => {\r\n+    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n+    if (!req.user.impersonator) {\r\n+        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n+    }\r\n+\r\n+    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n+    const company = req.company; // O middleware já nos deu a empresa representada\r\n+\r\n+    const today = new Date();\r\n+    today.setUTCHours(0, 0, 0, 0);\r\n+    const todayStr = today.toISOString().split('T')[0];\r\n+\r\n+    try {\r\n+        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n+        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n+        const overdueParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        const dueTodayParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n+        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n+\r\n+        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n+            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+            res.status(200).json({ \r\n+                message: `E-mail de relatório enviado para ${company.email}!`,\r\n+                overdueCount: overdueParcels.length,\r\n+                dueTodayCount: dueTodayParcels.length\r\n+            });\r\n+        } else {\r\n+            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n+            res.status(200).json({ \r\n+                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n+                overdueCount: 0,\r\n+                dueTodayCount: 0\r\n+            });\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('[TESTE MANUAL] Erro:', error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n+    }\r\n+});\r\n+\r\n+// --- GESTÃO DE ANÚNCIOS ---\r\n+\r\n+router.route('/announcements')\r\n+    // Rota para LER todos os anúncios\r\n+    .get(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n+            res.status(200).json(announcements);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao buscar anúncios:\", error);\r\n+            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n+        }\r\n+    })\r\n+    // Rota para CRIAR um novo anúncio\r\n+    .post(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const { message, link, isActive } = req.body;\r\n+\r\n+            if (!message) {\r\n+                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n+            }\r\n+\r\n+            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+            res.status(201).json(newAnnouncement);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao criar anúncio:\", error);\r\n+            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n+        }\r\n+    });\r\n+\r\n+// Rota para ATUALIZAR um anúncio\r\n+router.patch('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const { message, link, isActive } = req.body;\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        \r\n+        if (isActive) {\r\n+            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        }\r\n+\r\n+        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { message, link, isActive },\r\n+            { new: true }\r\n+        );\r\n+        res.status(200).json(updatedAnnouncement);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para APAGAR um anúncio\r\n+router.delete('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        await Announcement.findByIdAndDelete(req.params.id);\r\n+        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER todos os templates de e-mail\r\n+router.get('/email-templates', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n+        res.json(templates);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER UM template de e-mail específico pelo ID\r\n+router.get('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const template = await EmailTemplate.findById(req.params.templateId);\r\n+        if (!template) {\r\n+            return res.status(404).json({ message: 'Template não encontrado.' });\r\n+        }\r\n+        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR um template específico\r\n+router.patch('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const { subject, body } = req.body;\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n+            req.params.templateId,\r\n+            { subject, body },\r\n+            { new: true }\r\n+        );\r\n+        res.json(updatedTemplate);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota de pesquisa global para o admin\r\n+router.get('/search', async (req, res) => {\r\n+    try {\r\n+        const query = req.query.q || ''; // 'q' vem de \"query\"\r\n+        if (query.length < 2) {\r\n+            // Evita pesquisas vazias ou muito curtas para não sobrecarregar o DB\r\n+            return res.json({ users: [], companies: [] });\r\n+        }\r\n+\r\n+        // Cria uma expressão regular para pesquisa case-insensitive\r\n+        const searchRegex = new RegExp(query, 'i');\r\n+\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // 1. Pesquisa por Utilizadores (no username e email)\r\n+        const userResults = await MasterUser.find({\r\n+            $or: [\r\n+                { username: searchRegex },\r\n+                { email: searchRegex }\r\n+            ]\r\n+        }).populate('company', 'nomeEmpresa'); // Inclui o nome da empresa no resultado\r\n+\r\n+        // 2. Pesquisa por Empresas (no nome e CNPJ)\r\n+        const companyResults = await MasterCompany.find({\r\n+            $or: [\r\n+                { nomeEmpresa: searchRegex },\r\n+                { cnpj: query.replace(/\\D/g, '') } // Pesquisa por CNPJ apenas com números\r\n+            ]\r\n+        });\r\n+\r\n+        // 3. Retorna os resultados em um objeto organizado\r\n+        res.json({\r\n+            users: userResults,\r\n+            companies: companyResults\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro na pesquisa global do admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/bulk-email', async (req, res) => {\r\n+    try {\r\n+        const { audience, subject, body } = req.body;\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        let recipients = [];\r\n+        switch (audience) {\r\n+            case 'allProprietors':\r\n+                recipients = await MasterUser.find({ role: 'Proprietário' }).select('email');\r\n+                break;\r\n+            case 'activeSubscribers':\r\n+                const activeCompanies = await MasterCompany.find({ 'subscription.status': 'active' }).select('_id');\r\n+                const activeCompanyIds = activeCompanies.map(c => c._id);\r\n+                recipients = await MasterUser.find({ company: { $in: activeCompanyIds }, role: 'Proprietário' }).select('email');\r\n+                break;\r\n+            // (Pode adicionar outros casos como 'inactiveSubscribers' e 'allUsers' aqui)\r\n+            default:\r\n+                return res.status(400).json({ message: 'Público-alvo inválido.' });\r\n+        }\r\n+\r\n+        const emailList = recipients.map(r => r.email);\r\n+\r\n+        if (emailList.length === 0) {\r\n+            return res.status(404).json({ message: 'Nenhum destinatário encontrado para este público.' });\r\n+        }\r\n+        \r\n+        // AVISO: A lógica abaixo envia e-mails em sequência.\r\n+        // Para um grande número de utilizadores, isto pode ser lento e causar timeout.\r\n+        // A solução ideal para produção é um sistema de filas (queue).\r\n+        for (const email of emailList) {\r\n+            // Aqui você chamaria uma função genérica do seu emailService\r\n+            // await emailService.sendGenericEmail(email, subject, body);\r\n+        }\r\n+\r\n+        res.json({ message: `E-mail enviado para ${emailList.length} destinatários.` });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no envio de e-mail em massa:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754164919401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,380 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const jwt = require('jsonwebtoken');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { getTenantConnection } = require('../config/db');\r\n+const { sendDailyReportEmail } = require('../services/emailService');\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n+const AnnouncementSchema = require('../models/Announcement').schema;\r\n+const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n+const emailService = require('../services/emailService');\r\n+\r\n+\r\n+// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n+router.get('/subscriptions', async (req, res) => {\r\n+    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n+    // que é aplicado a todo este ficheiro no seu server.js.\r\n+\r\n+    try {\r\n+        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // Busca todas as empresas, selecionando apenas os campos necessários\r\n+        const subscriptionsData = await MasterCompany.find({})\r\n+            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n+            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n+\r\n+        // Envia a lista como resposta JSON\r\n+        res.json(subscriptionsData);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Nova rota para buscar as estatísticas do dashboard do admin\r\n+router.get('/dashboard-stats', async (req, res) => {\r\n+    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n+    // pelo middleware no seu ficheiro de servidor principal.\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // --- 1. Buscar os KPIs (Indicadores) ---\r\n+        const totalCompanies = await MasterCompany.countDocuments();\r\n+        const totalUsers = await MasterUser.countDocuments();\r\n+        const activeSubscriptions = await MasterCompany.countDocuments({\r\n+            'subscription.status': 'active'\r\n+        });\r\n+\r\n+        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n+        const thirtyDaysAgo = new Date();\r\n+        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n+\r\n+        const newCompaniesData = await MasterCompany.aggregate([\r\n+            // Filtra empresas criadas nos últimos 30 dias\r\n+            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n+            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n+            {\r\n+                $group: {\r\n+                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n+                    count: { $sum: 1 }\r\n+                }\r\n+            },\r\n+            // Ordena por data\r\n+            { $sort: { _id: 1 } },\r\n+            // Formata a saída para o formato que o frontend espera\r\n+            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n+        ]);\r\n+\r\n+        // --- 3. Envia a resposta completa em formato JSON ---\r\n+        res.json({\r\n+            totalCompanies,\r\n+            totalUsers,\r\n+            activeSubscriptions,\r\n+            newCompaniesLast30Days: newCompaniesData\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/impersonate', async (req, res) => {\r\n+    try {\r\n+        const masterDb = req.masterDb;\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+        const adminId = req.user.id;\r\n+        const { companyId, userId } = req.body;\r\n+        const userToImpersonate = await MasterUser.findById(userId);\r\n+\r\n+        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n+             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n+        }\r\n+        \r\n+        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n+        if (!companyToImpersonate) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        const token = jwt.sign(\r\n+            { \r\n+                id: userToImpersonate._id,\r\n+                companyId: userToImpersonate.company, \r\n+                username: userToImpersonate.username, // Importante para a rota /me\r\n+                impersonator: adminId\r\n+            },\r\n+            process.env.JWT_SECRET,\r\n+            { expiresIn: '1h' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Token de representação gerado com sucesso.',\r\n+            token,\r\n+            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n+            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao tentar representar usuário:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para testar manualmente o envio do relatório diário\r\n+router.post('/test-daily-report', async (req, res) => {\r\n+    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n+    if (!req.user.impersonator) {\r\n+        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n+    }\r\n+\r\n+    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n+    const company = req.company; // O middleware já nos deu a empresa representada\r\n+\r\n+    const today = new Date();\r\n+    today.setUTCHours(0, 0, 0, 0);\r\n+    const todayStr = today.toISOString().split('T')[0];\r\n+\r\n+    try {\r\n+        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n+        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n+        const overdueParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        const dueTodayParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n+        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n+\r\n+        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n+            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+            res.status(200).json({ \r\n+                message: `E-mail de relatório enviado para ${company.email}!`,\r\n+                overdueCount: overdueParcels.length,\r\n+                dueTodayCount: dueTodayParcels.length\r\n+            });\r\n+        } else {\r\n+            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n+            res.status(200).json({ \r\n+                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n+                overdueCount: 0,\r\n+                dueTodayCount: 0\r\n+            });\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('[TESTE MANUAL] Erro:', error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n+    }\r\n+});\r\n+\r\n+// --- GESTÃO DE ANÚNCIOS ---\r\n+\r\n+router.route('/announcements')\r\n+    // Rota para LER todos os anúncios\r\n+    .get(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n+            res.status(200).json(announcements);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao buscar anúncios:\", error);\r\n+            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n+        }\r\n+    })\r\n+    // Rota para CRIAR um novo anúncio\r\n+    .post(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const { message, link, isActive } = req.body;\r\n+\r\n+            if (!message) {\r\n+                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n+            }\r\n+\r\n+            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+            res.status(201).json(newAnnouncement);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao criar anúncio:\", error);\r\n+            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n+        }\r\n+    });\r\n+\r\n+// Rota para ATUALIZAR um anúncio\r\n+router.patch('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const { message, link, isActive } = req.body;\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        \r\n+        if (isActive) {\r\n+            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        }\r\n+\r\n+        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { message, link, isActive },\r\n+            { new: true }\r\n+        );\r\n+        res.status(200).json(updatedAnnouncement);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para APAGAR um anúncio\r\n+router.delete('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        await Announcement.findByIdAndDelete(req.params.id);\r\n+        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER todos os templates de e-mail\r\n+router.get('/email-templates', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n+        res.json(templates);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER UM template de e-mail específico pelo ID\r\n+router.get('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const template = await EmailTemplate.findById(req.params.templateId);\r\n+        if (!template) {\r\n+            return res.status(404).json({ message: 'Template não encontrado.' });\r\n+        }\r\n+        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR um template específico\r\n+router.patch('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const { subject, body } = req.body;\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n+            req.params.templateId,\r\n+            { subject, body },\r\n+            { new: true }\r\n+        );\r\n+        res.json(updatedTemplate);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota de pesquisa global para o admin\r\n+router.get('/search', async (req, res) => {\r\n+    try {\r\n+        const query = req.query.q || ''; // 'q' vem de \"query\"\r\n+        if (query.length < 2) {\r\n+            // Evita pesquisas vazias ou muito curtas para não sobrecarregar o DB\r\n+            return res.json({ users: [], companies: [] });\r\n+        }\r\n+\r\n+        // Cria uma expressão regular para pesquisa case-insensitive\r\n+        const searchRegex = new RegExp(query, 'i');\r\n+\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // 1. Pesquisa por Utilizadores (no username e email)\r\n+        const userResults = await MasterUser.find({\r\n+            $or: [\r\n+                { username: searchRegex },\r\n+                { email: searchRegex }\r\n+            ]\r\n+        }).populate('company', 'nomeEmpresa'); // Inclui o nome da empresa no resultado\r\n+\r\n+        // 2. Pesquisa por Empresas (no nome e CNPJ)\r\n+        const companyResults = await MasterCompany.find({\r\n+            $or: [\r\n+                { nomeEmpresa: searchRegex },\r\n+                { cnpj: query.replace(/\\D/g, '') } // Pesquisa por CNPJ apenas com números\r\n+            ]\r\n+        });\r\n+\r\n+        // 3. Retorna os resultados em um objeto organizado\r\n+        res.json({\r\n+            users: userResults,\r\n+            companies: companyResults\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro na pesquisa global do admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/bulk-email', async (req, res) => {\r\n+    try {\r\n+        const { audience, subject, body } = req.body;\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        let recipients = [];\r\n+        // (A sua lógica 'switch' para encontrar os destinatários continua aqui...)\r\n+        switch (audience) {\r\n+            case 'allProprietors':\r\n+                recipients = await MasterUser.find({ role: 'Proprietário' }).select('email');\r\n+                break;\r\n+            case 'activeSubscribers':\r\n+                const activeCompanies = await MasterCompany.find({ 'subscription.status': 'active' }).select('_id');\r\n+                const activeCompanyIds = activeCompanies.map(c => c._id);\r\n+                recipients = await MasterUser.find({ company: { $in: activeCompanyIds }, role: 'Proprietário' }).select('email');\r\n+                break;\r\n+            // (Adicione os outros casos aqui se necessário)\r\n+            default:\r\n+                return res.status(400).json({ message: 'Público-alvo inválido.' });\r\n+        }\r\n+\r\n+        const emailList = recipients.map(r => r.email);\r\n+\r\n+        if (emailList.length === 0) {\r\n+            return res.status(404).json({ message: 'Nenhum destinatário encontrado para este público.' });\r\n+        }\r\n+        \r\n+        // --- AQUI ESTÁ A CORREÇÃO ---\r\n+        // Agora estamos a chamar a função de envio para cada e-mail da lista.\r\n+        for (const email of emailList) {\r\n+            await emailService.sendGenericEmail(email, subject, body);\r\n+        }\r\n+\r\n+        res.json({ message: `E-mail enviado para ${emailList.length} destinatários.` });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no envio de e-mail em massa:\", error);\r\n+        res.status(500).json({ message: \"Ocorreu um erro ao tentar enviar os e-mails.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754165135820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,382 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const jwt = require('jsonwebtoken');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { getTenantConnection } = require('../config/db');\r\n+const { sendDailyReportEmail } = require('../services/emailService');\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n+const AnnouncementSchema = require('../models/Announcement').schema;\r\n+const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n+const emailService = require('../services/emailService');\r\n+\r\n+\r\n+// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n+router.get('/subscriptions', async (req, res) => {\r\n+    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n+    // que é aplicado a todo este ficheiro no seu server.js.\r\n+\r\n+    try {\r\n+        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // Busca todas as empresas, selecionando apenas os campos necessários\r\n+        const subscriptionsData = await MasterCompany.find({})\r\n+            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n+            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n+\r\n+        // Envia a lista como resposta JSON\r\n+        res.json(subscriptionsData);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Nova rota para buscar as estatísticas do dashboard do admin\r\n+router.get('/dashboard-stats', async (req, res) => {\r\n+    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n+    // pelo middleware no seu ficheiro de servidor principal.\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // --- 1. Buscar os KPIs (Indicadores) ---\r\n+        const totalCompanies = await MasterCompany.countDocuments();\r\n+        const totalUsers = await MasterUser.countDocuments();\r\n+        const activeSubscriptions = await MasterCompany.countDocuments({\r\n+            'subscription.status': 'active'\r\n+        });\r\n+\r\n+        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n+        const thirtyDaysAgo = new Date();\r\n+        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n+\r\n+        const newCompaniesData = await MasterCompany.aggregate([\r\n+            // Filtra empresas criadas nos últimos 30 dias\r\n+            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n+            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n+            {\r\n+                $group: {\r\n+                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n+                    count: { $sum: 1 }\r\n+                }\r\n+            },\r\n+            // Ordena por data\r\n+            { $sort: { _id: 1 } },\r\n+            // Formata a saída para o formato que o frontend espera\r\n+            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n+        ]);\r\n+\r\n+        // --- 3. Envia a resposta completa em formato JSON ---\r\n+        res.json({\r\n+            totalCompanies,\r\n+            totalUsers,\r\n+            activeSubscriptions,\r\n+            newCompaniesLast30Days: newCompaniesData\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/impersonate', async (req, res) => {\r\n+    try {\r\n+        const masterDb = req.masterDb;\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+        const adminId = req.user.id;\r\n+        const { companyId, userId } = req.body;\r\n+        const userToImpersonate = await MasterUser.findById(userId);\r\n+\r\n+        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n+             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n+        }\r\n+        \r\n+        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n+        if (!companyToImpersonate) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        const token = jwt.sign(\r\n+            { \r\n+                id: userToImpersonate._id,\r\n+                companyId: userToImpersonate.company, \r\n+                username: userToImpersonate.username, // Importante para a rota /me\r\n+                impersonator: adminId\r\n+            },\r\n+            process.env.JWT_SECRET,\r\n+            { expiresIn: '1h' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Token de representação gerado com sucesso.',\r\n+            token,\r\n+            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n+            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao tentar representar usuário:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para testar manualmente o envio do relatório diário\r\n+router.post('/test-daily-report', async (req, res) => {\r\n+    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n+    if (!req.user.impersonator) {\r\n+        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n+    }\r\n+\r\n+    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n+    const company = req.company; // O middleware já nos deu a empresa representada\r\n+\r\n+    const today = new Date();\r\n+    today.setUTCHours(0, 0, 0, 0);\r\n+    const todayStr = today.toISOString().split('T')[0];\r\n+\r\n+    try {\r\n+        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n+        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n+        const overdueParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        const dueTodayParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n+        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n+\r\n+        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n+            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+            res.status(200).json({ \r\n+                message: `E-mail de relatório enviado para ${company.email}!`,\r\n+                overdueCount: overdueParcels.length,\r\n+                dueTodayCount: dueTodayParcels.length\r\n+            });\r\n+        } else {\r\n+            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n+            res.status(200).json({ \r\n+                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n+                overdueCount: 0,\r\n+                dueTodayCount: 0\r\n+            });\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('[TESTE MANUAL] Erro:', error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n+    }\r\n+});\r\n+\r\n+// --- GESTÃO DE ANÚNCIOS ---\r\n+\r\n+router.route('/announcements')\r\n+    // Rota para LER todos os anúncios\r\n+    .get(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n+            res.status(200).json(announcements);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao buscar anúncios:\", error);\r\n+            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n+        }\r\n+    })\r\n+    // Rota para CRIAR um novo anúncio\r\n+    .post(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const { message, link, isActive } = req.body;\r\n+\r\n+            if (!message) {\r\n+                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n+            }\r\n+\r\n+            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+            res.status(201).json(newAnnouncement);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao criar anúncio:\", error);\r\n+            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n+        }\r\n+    });\r\n+\r\n+// Rota para ATUALIZAR um anúncio\r\n+router.patch('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const { message, link, isActive } = req.body;\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        \r\n+        if (isActive) {\r\n+            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        }\r\n+\r\n+        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { message, link, isActive },\r\n+            { new: true }\r\n+        );\r\n+        res.status(200).json(updatedAnnouncement);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para APAGAR um anúncio\r\n+router.delete('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        await Announcement.findByIdAndDelete(req.params.id);\r\n+        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER todos os templates de e-mail\r\n+router.get('/email-templates', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n+        res.json(templates);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER UM template de e-mail específico pelo ID\r\n+router.get('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const template = await EmailTemplate.findById(req.params.templateId);\r\n+        if (!template) {\r\n+            return res.status(404).json({ message: 'Template não encontrado.' });\r\n+        }\r\n+        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR um template específico\r\n+router.patch('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const { subject, body } = req.body;\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n+            req.params.templateId,\r\n+            { subject, body },\r\n+            { new: true }\r\n+        );\r\n+        res.json(updatedTemplate);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota de pesquisa global para o admin\r\n+router.get('/search', async (req, res) => {\r\n+    try {\r\n+        const query = req.query.q || ''; // 'q' vem de \"query\"\r\n+        if (query.length < 2) {\r\n+            // Evita pesquisas vazias ou muito curtas para não sobrecarregar o DB\r\n+            return res.json({ users: [], companies: [] });\r\n+        }\r\n+\r\n+        // Cria uma expressão regular para pesquisa case-insensitive\r\n+        const searchRegex = new RegExp(query, 'i');\r\n+\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // 1. Pesquisa por Utilizadores (no username e email)\r\n+        const userResults = await MasterUser.find({\r\n+            $or: [\r\n+                { username: searchRegex },\r\n+                { email: searchRegex }\r\n+            ]\r\n+        }).populate('company', 'nomeEmpresa'); // Inclui o nome da empresa no resultado\r\n+\r\n+        // 2. Pesquisa por Empresas (no nome e CNPJ)\r\n+        const companyResults = await MasterCompany.find({\r\n+            $or: [\r\n+                { nomeEmpresa: searchRegex },\r\n+                { cnpj: query.replace(/\\D/g, '') } // Pesquisa por CNPJ apenas com números\r\n+            ]\r\n+        });\r\n+\r\n+        // 3. Retorna os resultados em um objeto organizado\r\n+        res.json({\r\n+            users: userResults,\r\n+            companies: companyResults\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro na pesquisa global do admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/bulk-email', async (req, res) => {\r\n+    try {\r\n+        const { audience, subject, body } = req.body;\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        let recipients = [];\r\n+        // (A sua lógica 'switch' para encontrar os destinatários continua aqui...)\r\n+        switch (audience) {\r\n+            case 'allProprietors':\r\n+                recipients = await MasterUser.find({ role: 'Proprietário' }).select('email');\r\n+                break;\r\n+            case 'activeSubscribers':\r\n+                const activeCompanies = await MasterCompany.find({ 'subscription.status': 'active' }).select('_id');\r\n+                const activeCompanyIds = activeCompanies.map(c => c._id);\r\n+                recipients = await MasterUser.find({ company: { $in: activeCompanyIds }, role: 'Proprietário' }).select('email');\r\n+                break;\r\n+            // (Adicione os outros casos aqui se necessário)\r\n+            default:\r\n+                return res.status(400).json({ message: 'Público-alvo inválido.' });\r\n+        }\r\n+\r\n+        const emailList = recipients\r\n+            .map(r => r.email)\r\n+            .filter(email => email);\r\n+\r\n+        if (emailList.length === 0) {\r\n+            return res.status(404).json({ message: 'Nenhum destinatário encontrado para este público.' });\r\n+        }\r\n+        \r\n+        // --- AQUI ESTÁ A CORREÇÃO ---\r\n+        // Agora estamos a chamar a função de envio para cada e-mail da lista.\r\n+        for (const email of emailList) {\r\n+            await emailService.sendGenericEmail(email, subject, body);\r\n+        }\r\n+\r\n+        res.json({ message: `E-mail enviado para ${emailList.length} destinatários.` });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no envio de e-mail em massa:\", error);\r\n+        res.status(500).json({ message: \"Ocorreu um erro ao tentar enviar os e-mails.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754165418571,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,399 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const jwt = require('jsonwebtoken');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { getTenantConnection } = require('../config/db');\r\n+const { sendDailyReportEmail } = require('../services/emailService');\r\n+const BoletoSchema = require('../models/Boleto').schema;\r\n+const AnnouncementSchema = require('../models/Announcement').schema;\r\n+const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n+const emailService = require('../services/emailService');\r\n+\r\n+\r\n+// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n+router.get('/subscriptions', async (req, res) => {\r\n+    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n+    // que é aplicado a todo este ficheiro no seu server.js.\r\n+\r\n+    try {\r\n+        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // Busca todas as empresas, selecionando apenas os campos necessários\r\n+        const subscriptionsData = await MasterCompany.find({})\r\n+            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n+            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n+\r\n+        // Envia a lista como resposta JSON\r\n+        res.json(subscriptionsData);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Nova rota para buscar as estatísticas do dashboard do admin\r\n+router.get('/dashboard-stats', async (req, res) => {\r\n+    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n+    // pelo middleware no seu ficheiro de servidor principal.\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // --- 1. Buscar os KPIs (Indicadores) ---\r\n+        const totalCompanies = await MasterCompany.countDocuments();\r\n+        const totalUsers = await MasterUser.countDocuments();\r\n+        const activeSubscriptions = await MasterCompany.countDocuments({\r\n+            'subscription.status': 'active'\r\n+        });\r\n+\r\n+        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n+        const thirtyDaysAgo = new Date();\r\n+        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n+\r\n+        const newCompaniesData = await MasterCompany.aggregate([\r\n+            // Filtra empresas criadas nos últimos 30 dias\r\n+            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n+            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n+            {\r\n+                $group: {\r\n+                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n+                    count: { $sum: 1 }\r\n+                }\r\n+            },\r\n+            // Ordena por data\r\n+            { $sort: { _id: 1 } },\r\n+            // Formata a saída para o formato que o frontend espera\r\n+            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n+        ]);\r\n+\r\n+        // --- 3. Envia a resposta completa em formato JSON ---\r\n+        res.json({\r\n+            totalCompanies,\r\n+            totalUsers,\r\n+            activeSubscriptions,\r\n+            newCompaniesLast30Days: newCompaniesData\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/impersonate', async (req, res) => {\r\n+    try {\r\n+        const masterDb = req.masterDb;\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+        const adminId = req.user.id;\r\n+        const { companyId, userId } = req.body;\r\n+        const userToImpersonate = await MasterUser.findById(userId);\r\n+\r\n+        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n+             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n+        }\r\n+        \r\n+        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n+        if (!companyToImpersonate) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        const token = jwt.sign(\r\n+            { \r\n+                id: userToImpersonate._id,\r\n+                companyId: userToImpersonate.company, \r\n+                username: userToImpersonate.username, // Importante para a rota /me\r\n+                impersonator: adminId\r\n+            },\r\n+            process.env.JWT_SECRET,\r\n+            { expiresIn: '1h' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Token de representação gerado com sucesso.',\r\n+            token,\r\n+            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n+            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao tentar representar usuário:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para testar manualmente o envio do relatório diário\r\n+router.post('/test-daily-report', async (req, res) => {\r\n+    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n+    if (!req.user.impersonator) {\r\n+        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n+    }\r\n+\r\n+    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n+    const company = req.company; // O middleware já nos deu a empresa representada\r\n+\r\n+    const today = new Date();\r\n+    today.setUTCHours(0, 0, 0, 0);\r\n+    const todayStr = today.toISOString().split('T')[0];\r\n+\r\n+    try {\r\n+        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n+        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n+        const overdueParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        const dueTodayParcels = await Boleto.aggregate([\r\n+            { $unwind: '$parcels' },\r\n+            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+        ]);\r\n+\r\n+        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n+        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n+\r\n+        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n+            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+            res.status(200).json({ \r\n+                message: `E-mail de relatório enviado para ${company.email}!`,\r\n+                overdueCount: overdueParcels.length,\r\n+                dueTodayCount: dueTodayParcels.length\r\n+            });\r\n+        } else {\r\n+            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n+            res.status(200).json({ \r\n+                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n+                overdueCount: 0,\r\n+                dueTodayCount: 0\r\n+            });\r\n+        }\r\n+    } catch (error) {\r\n+        console.error('[TESTE MANUAL] Erro:', error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n+    }\r\n+});\r\n+\r\n+// --- GESTÃO DE ANÚNCIOS ---\r\n+\r\n+router.route('/announcements')\r\n+    // Rota para LER todos os anúncios\r\n+    .get(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n+            res.status(200).json(announcements);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao buscar anúncios:\", error);\r\n+            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n+        }\r\n+    })\r\n+    // Rota para CRIAR um novo anúncio\r\n+    .post(async (req, res) => {\r\n+        try {\r\n+            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+            const { message, link, isActive } = req.body;\r\n+\r\n+            if (!message) {\r\n+                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n+            }\r\n+\r\n+            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n+            res.status(201).json(newAnnouncement);\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao criar anúncio:\", error);\r\n+            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n+        }\r\n+    });\r\n+\r\n+// Rota para ATUALIZAR um anúncio\r\n+router.patch('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const { message, link, isActive } = req.body;\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        \r\n+        if (isActive) {\r\n+            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n+        }\r\n+\r\n+        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { message, link, isActive },\r\n+            { new: true }\r\n+        );\r\n+        res.status(200).json(updatedAnnouncement);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para APAGAR um anúncio\r\n+router.delete('/announcements/:id', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n+    try {\r\n+        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n+        await Announcement.findByIdAndDelete(req.params.id);\r\n+        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n+        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER todos os templates de e-mail\r\n+router.get('/email-templates', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n+        res.json(templates);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER UM template de e-mail específico pelo ID\r\n+router.get('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const template = await EmailTemplate.findById(req.params.templateId);\r\n+        if (!template) {\r\n+            return res.status(404).json({ message: 'Template não encontrado.' });\r\n+        }\r\n+        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR um template específico\r\n+router.patch('/email-templates/:templateId', async (req, res) => {\r\n+    try {\r\n+        const { subject, body } = req.body;\r\n+        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n+        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n+            req.params.templateId,\r\n+            { subject, body },\r\n+            { new: true }\r\n+        );\r\n+        res.json(updatedTemplate);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota de pesquisa global para o admin\r\n+router.get('/search', async (req, res) => {\r\n+    try {\r\n+        const query = req.query.q || ''; // 'q' vem de \"query\"\r\n+        if (query.length < 2) {\r\n+            // Evita pesquisas vazias ou muito curtas para não sobrecarregar o DB\r\n+            return res.json({ users: [], companies: [] });\r\n+        }\r\n+\r\n+        // Cria uma expressão regular para pesquisa case-insensitive\r\n+        const searchRegex = new RegExp(query, 'i');\r\n+\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // 1. Pesquisa por Utilizadores (no username e email)\r\n+        const userResults = await MasterUser.find({\r\n+            $or: [\r\n+                { username: searchRegex },\r\n+                { email: searchRegex }\r\n+            ]\r\n+        }).populate('company', 'nomeEmpresa'); // Inclui o nome da empresa no resultado\r\n+\r\n+        // 2. Pesquisa por Empresas (no nome e CNPJ)\r\n+        const companyResults = await MasterCompany.find({\r\n+            $or: [\r\n+                { nomeEmpresa: searchRegex },\r\n+                { cnpj: query.replace(/\\D/g, '') } // Pesquisa por CNPJ apenas com números\r\n+            ]\r\n+        });\r\n+\r\n+        // 3. Retorna os resultados em um objeto organizado\r\n+        res.json({\r\n+            users: userResults,\r\n+            companies: companyResults\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro na pesquisa global do admin:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+router.post('/bulk-email', async (req, res) => {\r\n+    try {\r\n+        const { audience, subject, body } = req.body;\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        let recipients = [];\r\n+        \r\n+        // A lógica switch agora está completa\r\n+        switch (audience) {\r\n+            case 'allProprietors':\r\n+                recipients = await MasterUser.find({ role: 'Proprietário' }).select('email');\r\n+                break;\r\n+\r\n+            case 'activeSubscribers':\r\n+                const activeCompanies = await MasterCompany.find({ 'subscription.status': 'active' }).select('_id');\r\n+                const activeCompanyIds = activeCompanies.map(c => c._id);\r\n+                recipients = await MasterUser.find({ company: { $in: activeCompanyIds }, role: 'Proprietário' }).select('email');\r\n+                break;\r\n+            \r\n+            // --- NOVO CÓDIGO ADICIONADO ABAIXO ---\r\n+\r\n+            case 'inactiveSubscribers':\r\n+                // Busca empresas cuja assinatura NÃO seja 'active'\r\n+                const inactiveCompanies = await MasterCompany.find({ 'subscription.status': { $ne: 'active' } }).select('_id');\r\n+                const inactiveCompanyIds = inactiveCompanies.map(c => c._id);\r\n+                recipients = await MasterUser.find({ company: { $in: inactiveCompanyIds }, role: 'Proprietário' }).select('email');\r\n+                break;\r\n+\r\n+            case 'allUsers':\r\n+                // Busca todos os utilizadores, sem distinção de cargo\r\n+                recipients = await MasterUser.find({}).select('email');\r\n+                break;\r\n+\r\n+            // --- FIM DO NOVO CÓDIGO ---\r\n+\r\n+            default:\r\n+                return res.status(400).json({ message: 'Público-alvo inválido.' });\r\n+        }\r\n+\r\n+        const emailList = recipients\r\n+            .map(r => r.email)\r\n+            .filter(email => email);\r\n+\r\n+        if (emailList.length === 0) {\r\n+            // Alterado para um erro 404 (Not Found) que é mais apropriado\r\n+            return res.status(404).json({ message: 'Nenhum destinatário com e-mail válido encontrado para este público.' });\r\n+        }\r\n+        \r\n+        for (const email of emailList) {\r\n+            await emailService.sendGenericEmail(email, subject, body);\r\n+        }\r\n+\r\n+        res.json({ message: `E-mail enviado para ${emailList.length} destinatários.` });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no envio de e-mail em massa:\", error);\r\n+        res.status(500).json({ message: \"Ocorreu um erro ao tentar enviar os e-mails.\" });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754321803884,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,22 +14,27 @@\n \r\n \r\n // Nova rota para buscar a lista de assinaturas de todas as empresas\r\n router.get('/subscriptions', async (req, res) => {\r\n-    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n-    // que é aplicado a todo este ficheiro no seu server.js.\r\n-\r\n     try {\r\n-        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n         const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({}).select('_id nomeEmpresa cnpj subscription').sort({ nomeEmpresa: 1 });\r\n \r\n-        // Busca todas as empresas, selecionando apenas os campos necessários\r\n-        const subscriptionsData = await MasterCompany.find({})\r\n-            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n-            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n+        // --- LÓGICA NOVA ADICIONADA AQUI ---\r\n+        const today = new Date();\r\n+        const processedCompanies = companies.map(c => {\r\n+            const company = c.toObject(); // Converte para um objeto simples para podermos modificar\r\n+            \r\n+            // Se a assinatura está \"ativa\" mas a data de expiração já passou...\r\n+            if (company.subscription && company.subscription.status === 'active' && new Date(company.subscription.endDate) < today) {\r\n+                // ...nós alteramos o status para 'expirada' apenas na resposta da API.\r\n+                company.subscription.status = 'expired';\r\n+            }\r\n+            return company;\r\n+        });\r\n+        // --- FIM DA LÓGICA NOVA ---\r\n \r\n-        // Envia a lista como resposta JSON\r\n-        res.json(subscriptionsData);\r\n+        res.json(processedCompanies); // Envia a lista processada\r\n \r\n     } catch (error) {\r\n         console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n         res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n@@ -395,1528 +400,5 @@\n         res.status(500).json({ message: \"Ocorreu um erro ao tentar enviar os e-mails.\" });\r\n     }\r\n });\r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const jwt = require('jsonwebtoken');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-const { getTenantConnection } = require('../config/db');\r\n-const { sendDailyReportEmail } = require('../services/emailService');\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n-const AnnouncementSchema = require('../models/Announcement').schema;\r\n-const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n-const emailService = require('../services/emailService');\r\n-\r\n-\r\n-// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n-router.get('/subscriptions', async (req, res) => {\r\n-    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n-    // que é aplicado a todo este ficheiro no seu server.js.\r\n-\r\n-    try {\r\n-        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // Busca todas as empresas, selecionando apenas os campos necessários\r\n-        const subscriptionsData = await MasterCompany.find({})\r\n-            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n-            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n-\r\n-        // Envia a lista como resposta JSON\r\n-        res.json(subscriptionsData);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Nova rota para buscar as estatísticas do dashboard do admin\r\n-router.get('/dashboard-stats', async (req, res) => {\r\n-    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n-    // pelo middleware no seu ficheiro de servidor principal.\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // --- 1. Buscar os KPIs (Indicadores) ---\r\n-        const totalCompanies = await MasterCompany.countDocuments();\r\n-        const totalUsers = await MasterUser.countDocuments();\r\n-        const activeSubscriptions = await MasterCompany.countDocuments({\r\n-            'subscription.status': 'active'\r\n-        });\r\n-\r\n-        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n-        const thirtyDaysAgo = new Date();\r\n-        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n-\r\n-        const newCompaniesData = await MasterCompany.aggregate([\r\n-            // Filtra empresas criadas nos últimos 30 dias\r\n-            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n-            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n-            {\r\n-                $group: {\r\n-                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n-                    count: { $sum: 1 }\r\n-                }\r\n-            },\r\n-            // Ordena por data\r\n-            { $sort: { _id: 1 } },\r\n-            // Formata a saída para o formato que o frontend espera\r\n-            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n-        ]);\r\n-\r\n-        // --- 3. Envia a resposta completa em formato JSON ---\r\n-        res.json({\r\n-            totalCompanies,\r\n-            totalUsers,\r\n-            activeSubscriptions,\r\n-            newCompaniesLast30Days: newCompaniesData\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/impersonate', async (req, res) => {\r\n-    try {\r\n-        const masterDb = req.masterDb;\r\n-        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-        const adminId = req.user.id;\r\n-        const { companyId, userId } = req.body;\r\n-        const userToImpersonate = await MasterUser.findById(userId);\r\n-\r\n-        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n-             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n-        }\r\n-        \r\n-        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n-        if (!companyToImpersonate) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        const token = jwt.sign(\r\n-            { \r\n-                id: userToImpersonate._id,\r\n-                companyId: userToImpersonate.company, \r\n-                username: userToImpersonate.username, // Importante para a rota /me\r\n-                impersonator: adminId\r\n-            },\r\n-            process.env.JWT_SECRET,\r\n-            { expiresIn: '1h' }\r\n-        );\r\n-\r\n-        res.status(200).json({\r\n-            message: 'Token de representação gerado com sucesso.',\r\n-            token,\r\n-            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n-            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao tentar representar usuário:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota para testar manualmente o envio do relatório diário\r\n-router.post('/test-daily-report', async (req, res) => {\r\n-    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n-    if (!req.user.impersonator) {\r\n-        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n-    }\r\n-\r\n-    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n-    const company = req.company; // O middleware já nos deu a empresa representada\r\n-\r\n-    const today = new Date();\r\n-    today.setUTCHours(0, 0, 0, 0);\r\n-    const todayStr = today.toISOString().split('T')[0];\r\n-\r\n-    try {\r\n-        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n-        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n-\r\n-        const overdueParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        const dueTodayParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n-        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n-\r\n-        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n-            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n-            res.status(200).json({ \r\n-                message: `E-mail de relatório enviado para ${company.email}!`,\r\n-                overdueCount: overdueParcels.length,\r\n-                dueTodayCount: dueTodayParcels.length\r\n-            });\r\n-        } else {\r\n-            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n-            res.status(200).json({ \r\n-                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n-                overdueCount: 0,\r\n-                dueTodayCount: 0\r\n-            });\r\n-        }\r\n-    } catch (error) {\r\n-        console.error('[TESTE MANUAL] Erro:', error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n-    }\r\n-});\r\n-\r\n-// --- GESTÃO DE ANÚNCIOS ---\r\n-\r\n-router.route('/announcements')\r\n-    // Rota para LER todos os anúncios\r\n-    .get(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n-            res.status(200).json(announcements);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao buscar anúncios:\", error);\r\n-            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n-        }\r\n-    })\r\n-    // Rota para CRIAR um novo anúncio\r\n-    .post(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const { message, link, isActive } = req.body;\r\n-\r\n-            if (!message) {\r\n-                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n-            }\r\n-\r\n-            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n-            res.status(201).json(newAnnouncement);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao criar anúncio:\", error);\r\n-            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n-        }\r\n-    });\r\n-\r\n-// Rota para ATUALIZAR um anúncio\r\n-router.patch('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const { message, link, isActive } = req.body;\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        \r\n-        if (isActive) {\r\n-            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n-        }\r\n-\r\n-        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { message, link, isActive },\r\n-            { new: true }\r\n-        );\r\n-        res.status(200).json(updatedAnnouncement);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para APAGAR um anúncio\r\n-router.delete('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        await Announcement.findByIdAndDelete(req.params.id);\r\n-        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER todos os templates de e-mail\r\n-router.get('/email-templates', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n-        res.json(templates);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER UM template de e-mail específico pelo ID\r\n-router.get('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const template = await EmailTemplate.findById(req.params.templateId);\r\n-        if (!template) {\r\n-            return res.status(404).json({ message: 'Template não encontrado.' });\r\n-        }\r\n-        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR um template específico\r\n-router.patch('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const { subject, body } = req.body;\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n-            req.params.templateId,\r\n-            { subject, body },\r\n-            { new: true }\r\n-        );\r\n-        res.json(updatedTemplate);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota de pesquisa global para o admin\r\n-router.get('/search', async (req, res) => {\r\n-    try {\r\n-        const query = req.query.q || ''; // 'q' vem de \"query\"\r\n-        if (query.length < 2) {\r\n-            // Evita pesquisas vazias ou muito curtas para não sobrecarregar o DB\r\n-            return res.json({ users: [], companies: [] });\r\n-        }\r\n-\r\n-        // Cria uma expressão regular para pesquisa case-insensitive\r\n-        const searchRegex = new RegExp(query, 'i');\r\n-\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // 1. Pesquisa por Utilizadores (no username e email)\r\n-        const userResults = await MasterUser.find({\r\n-            $or: [\r\n-                { username: searchRegex },\r\n-                { email: searchRegex }\r\n-            ]\r\n-        }).populate('company', 'nomeEmpresa'); // Inclui o nome da empresa no resultado\r\n-\r\n-        // 2. Pesquisa por Empresas (no nome e CNPJ)\r\n-        const companyResults = await MasterCompany.find({\r\n-            $or: [\r\n-                { nomeEmpresa: searchRegex },\r\n-                { cnpj: query.replace(/\\D/g, '') } // Pesquisa por CNPJ apenas com números\r\n-            ]\r\n-        });\r\n-\r\n-        // 3. Retorna os resultados em um objeto organizado\r\n-        res.json({\r\n-            users: userResults,\r\n-            companies: companyResults\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro na pesquisa global do admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/bulk-email', async (req, res) => {\r\n-    try {\r\n-        const { audience, subject, body } = req.body;\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        let recipients = [];\r\n-        // (A sua lógica 'switch' para encontrar os destinatários continua aqui...)\r\n-        switch (audience) {\r\n-            case 'allProprietors':\r\n-                recipients = await MasterUser.find({ role: 'Proprietário' }).select('email');\r\n-                break;\r\n-            case 'activeSubscribers':\r\n-                const activeCompanies = await MasterCompany.find({ 'subscription.status': 'active' }).select('_id');\r\n-                const activeCompanyIds = activeCompanies.map(c => c._id);\r\n-                recipients = await MasterUser.find({ company: { $in: activeCompanyIds }, role: 'Proprietário' }).select('email');\r\n-                break;\r\n-            // (Adicione os outros casos aqui se necessário)\r\n-            default:\r\n-                return res.status(400).json({ message: 'Público-alvo inválido.' });\r\n-        }\r\n-\r\n-        const emailList = recipients\r\n-            .map(r => r.email)\r\n-            .filter(email => email);\r\n-\r\n-        if (emailList.length === 0) {\r\n-            return res.status(404).json({ message: 'Nenhum destinatário encontrado para este público.' });\r\n-        }\r\n-        \r\n-        // --- AQUI ESTÁ A CORREÇÃO ---\r\n-        // Agora estamos a chamar a função de envio para cada e-mail da lista.\r\n-        for (const email of emailList) {\r\n-            await emailService.sendGenericEmail(email, subject, body);\r\n-        }\r\n-\r\n-        res.json({ message: `E-mail enviado para ${emailList.length} destinatários.` });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro no envio de e-mail em massa:\", error);\r\n-        res.status(500).json({ message: \"Ocorreu um erro ao tentar enviar os e-mails.\" });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const jwt = require('jsonwebtoken');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-const { getTenantConnection } = require('../config/db');\r\n-const { sendDailyReportEmail } = require('../services/emailService');\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n-const AnnouncementSchema = require('../models/Announcement').schema;\r\n-const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n-const emailService = require('../services/emailService');\r\n-\r\n-\r\n-// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n-router.get('/subscriptions', async (req, res) => {\r\n-    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n-    // que é aplicado a todo este ficheiro no seu server.js.\r\n-\r\n-    try {\r\n-        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // Busca todas as empresas, selecionando apenas os campos necessários\r\n-        const subscriptionsData = await MasterCompany.find({})\r\n-            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n-            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n-\r\n-        // Envia a lista como resposta JSON\r\n-        res.json(subscriptionsData);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Nova rota para buscar as estatísticas do dashboard do admin\r\n-router.get('/dashboard-stats', async (req, res) => {\r\n-    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n-    // pelo middleware no seu ficheiro de servidor principal.\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // --- 1. Buscar os KPIs (Indicadores) ---\r\n-        const totalCompanies = await MasterCompany.countDocuments();\r\n-        const totalUsers = await MasterUser.countDocuments();\r\n-        const activeSubscriptions = await MasterCompany.countDocuments({\r\n-            'subscription.status': 'active'\r\n-        });\r\n-\r\n-        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n-        const thirtyDaysAgo = new Date();\r\n-        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n-\r\n-        const newCompaniesData = await MasterCompany.aggregate([\r\n-            // Filtra empresas criadas nos últimos 30 dias\r\n-            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n-            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n-            {\r\n-                $group: {\r\n-                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n-                    count: { $sum: 1 }\r\n-                }\r\n-            },\r\n-            // Ordena por data\r\n-            { $sort: { _id: 1 } },\r\n-            // Formata a saída para o formato que o frontend espera\r\n-            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n-        ]);\r\n-\r\n-        // --- 3. Envia a resposta completa em formato JSON ---\r\n-        res.json({\r\n-            totalCompanies,\r\n-            totalUsers,\r\n-            activeSubscriptions,\r\n-            newCompaniesLast30Days: newCompaniesData\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/impersonate', async (req, res) => {\r\n-    try {\r\n-        const masterDb = req.masterDb;\r\n-        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-        const adminId = req.user.id;\r\n-        const { companyId, userId } = req.body;\r\n-        const userToImpersonate = await MasterUser.findById(userId);\r\n-\r\n-        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n-             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n-        }\r\n-        \r\n-        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n-        if (!companyToImpersonate) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        const token = jwt.sign(\r\n-            { \r\n-                id: userToImpersonate._id,\r\n-                companyId: userToImpersonate.company, \r\n-                username: userToImpersonate.username, // Importante para a rota /me\r\n-                impersonator: adminId\r\n-            },\r\n-            process.env.JWT_SECRET,\r\n-            { expiresIn: '1h' }\r\n-        );\r\n-\r\n-        res.status(200).json({\r\n-            message: 'Token de representação gerado com sucesso.',\r\n-            token,\r\n-            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n-            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao tentar representar usuário:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota para testar manualmente o envio do relatório diário\r\n-router.post('/test-daily-report', async (req, res) => {\r\n-    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n-    if (!req.user.impersonator) {\r\n-        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n-    }\r\n-\r\n-    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n-    const company = req.company; // O middleware já nos deu a empresa representada\r\n-\r\n-    const today = new Date();\r\n-    today.setUTCHours(0, 0, 0, 0);\r\n-    const todayStr = today.toISOString().split('T')[0];\r\n-\r\n-    try {\r\n-        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n-        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n-\r\n-        const overdueParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        const dueTodayParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n-        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n-\r\n-        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n-            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n-            res.status(200).json({ \r\n-                message: `E-mail de relatório enviado para ${company.email}!`,\r\n-                overdueCount: overdueParcels.length,\r\n-                dueTodayCount: dueTodayParcels.length\r\n-            });\r\n-        } else {\r\n-            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n-            res.status(200).json({ \r\n-                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n-                overdueCount: 0,\r\n-                dueTodayCount: 0\r\n-            });\r\n-        }\r\n-    } catch (error) {\r\n-        console.error('[TESTE MANUAL] Erro:', error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n-    }\r\n-});\r\n-\r\n-// --- GESTÃO DE ANÚNCIOS ---\r\n-\r\n-router.route('/announcements')\r\n-    // Rota para LER todos os anúncios\r\n-    .get(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n-            res.status(200).json(announcements);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao buscar anúncios:\", error);\r\n-            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n-        }\r\n-    })\r\n-    // Rota para CRIAR um novo anúncio\r\n-    .post(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const { message, link, isActive } = req.body;\r\n-\r\n-            if (!message) {\r\n-                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n-            }\r\n-\r\n-            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n-            res.status(201).json(newAnnouncement);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao criar anúncio:\", error);\r\n-            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n-        }\r\n-    });\r\n-\r\n-// Rota para ATUALIZAR um anúncio\r\n-router.patch('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const { message, link, isActive } = req.body;\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        \r\n-        if (isActive) {\r\n-            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n-        }\r\n-\r\n-        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { message, link, isActive },\r\n-            { new: true }\r\n-        );\r\n-        res.status(200).json(updatedAnnouncement);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para APAGAR um anúncio\r\n-router.delete('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        await Announcement.findByIdAndDelete(req.params.id);\r\n-        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER todos os templates de e-mail\r\n-router.get('/email-templates', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n-        res.json(templates);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER UM template de e-mail específico pelo ID\r\n-router.get('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const template = await EmailTemplate.findById(req.params.templateId);\r\n-        if (!template) {\r\n-            return res.status(404).json({ message: 'Template não encontrado.' });\r\n-        }\r\n-        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR um template específico\r\n-router.patch('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const { subject, body } = req.body;\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n-            req.params.templateId,\r\n-            { subject, body },\r\n-            { new: true }\r\n-        );\r\n-        res.json(updatedTemplate);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota de pesquisa global para o admin\r\n-router.get('/search', async (req, res) => {\r\n-    try {\r\n-        const query = req.query.q || ''; // 'q' vem de \"query\"\r\n-        if (query.length < 2) {\r\n-            // Evita pesquisas vazias ou muito curtas para não sobrecarregar o DB\r\n-            return res.json({ users: [], companies: [] });\r\n-        }\r\n-\r\n-        // Cria uma expressão regular para pesquisa case-insensitive\r\n-        const searchRegex = new RegExp(query, 'i');\r\n-\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // 1. Pesquisa por Utilizadores (no username e email)\r\n-        const userResults = await MasterUser.find({\r\n-            $or: [\r\n-                { username: searchRegex },\r\n-                { email: searchRegex }\r\n-            ]\r\n-        }).populate('company', 'nomeEmpresa'); // Inclui o nome da empresa no resultado\r\n-\r\n-        // 2. Pesquisa por Empresas (no nome e CNPJ)\r\n-        const companyResults = await MasterCompany.find({\r\n-            $or: [\r\n-                { nomeEmpresa: searchRegex },\r\n-                { cnpj: query.replace(/\\D/g, '') } // Pesquisa por CNPJ apenas com números\r\n-            ]\r\n-        });\r\n-\r\n-        // 3. Retorna os resultados em um objeto organizado\r\n-        res.json({\r\n-            users: userResults,\r\n-            companies: companyResults\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro na pesquisa global do admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/bulk-email', async (req, res) => {\r\n-    try {\r\n-        const { audience, subject, body } = req.body;\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        let recipients = [];\r\n-        // (A sua lógica 'switch' para encontrar os destinatários continua aqui...)\r\n-        switch (audience) {\r\n-            case 'allProprietors':\r\n-                recipients = await MasterUser.find({ role: 'Proprietário' }).select('email');\r\n-                break;\r\n-            case 'activeSubscribers':\r\n-                const activeCompanies = await MasterCompany.find({ 'subscription.status': 'active' }).select('_id');\r\n-                const activeCompanyIds = activeCompanies.map(c => c._id);\r\n-                recipients = await MasterUser.find({ company: { $in: activeCompanyIds }, role: 'Proprietário' }).select('email');\r\n-                break;\r\n-            // (Adicione os outros casos aqui se necessário)\r\n-            default:\r\n-                return res.status(400).json({ message: 'Público-alvo inválido.' });\r\n-        }\r\n-\r\n-        const emailList = recipients.map(r => r.email);\r\n-\r\n-        if (emailList.length === 0) {\r\n-            return res.status(404).json({ message: 'Nenhum destinatário encontrado para este público.' });\r\n-        }\r\n-        \r\n-        // --- AQUI ESTÁ A CORREÇÃO ---\r\n-        // Agora estamos a chamar a função de envio para cada e-mail da lista.\r\n-        for (const email of emailList) {\r\n-            await emailService.sendGenericEmail(email, subject, body);\r\n-        }\r\n-\r\n-        res.json({ message: `E-mail enviado para ${emailList.length} destinatários.` });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro no envio de e-mail em massa:\", error);\r\n-        res.status(500).json({ message: \"Ocorreu um erro ao tentar enviar os e-mails.\" });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const jwt = require('jsonwebtoken');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-const { getTenantConnection } = require('../config/db');\r\n-const { sendDailyReportEmail } = require('../services/emailService');\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n-const AnnouncementSchema = require('../models/Announcement').schema;\r\n-const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n-const emailService = require('../services/emailService');\r\n-\r\n-\r\n-// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n-router.get('/subscriptions', async (req, res) => {\r\n-    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n-    // que é aplicado a todo este ficheiro no seu server.js.\r\n-\r\n-    try {\r\n-        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // Busca todas as empresas, selecionando apenas os campos necessários\r\n-        const subscriptionsData = await MasterCompany.find({})\r\n-            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n-            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n-\r\n-        // Envia a lista como resposta JSON\r\n-        res.json(subscriptionsData);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Nova rota para buscar as estatísticas do dashboard do admin\r\n-router.get('/dashboard-stats', async (req, res) => {\r\n-    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n-    // pelo middleware no seu ficheiro de servidor principal.\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // --- 1. Buscar os KPIs (Indicadores) ---\r\n-        const totalCompanies = await MasterCompany.countDocuments();\r\n-        const totalUsers = await MasterUser.countDocuments();\r\n-        const activeSubscriptions = await MasterCompany.countDocuments({\r\n-            'subscription.status': 'active'\r\n-        });\r\n-\r\n-        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n-        const thirtyDaysAgo = new Date();\r\n-        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n-\r\n-        const newCompaniesData = await MasterCompany.aggregate([\r\n-            // Filtra empresas criadas nos últimos 30 dias\r\n-            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n-            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n-            {\r\n-                $group: {\r\n-                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n-                    count: { $sum: 1 }\r\n-                }\r\n-            },\r\n-            // Ordena por data\r\n-            { $sort: { _id: 1 } },\r\n-            // Formata a saída para o formato que o frontend espera\r\n-            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n-        ]);\r\n-\r\n-        // --- 3. Envia a resposta completa em formato JSON ---\r\n-        res.json({\r\n-            totalCompanies,\r\n-            totalUsers,\r\n-            activeSubscriptions,\r\n-            newCompaniesLast30Days: newCompaniesData\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/impersonate', async (req, res) => {\r\n-    try {\r\n-        const masterDb = req.masterDb;\r\n-        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-        const adminId = req.user.id;\r\n-        const { companyId, userId } = req.body;\r\n-        const userToImpersonate = await MasterUser.findById(userId);\r\n-\r\n-        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n-             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n-        }\r\n-        \r\n-        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n-        if (!companyToImpersonate) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        const token = jwt.sign(\r\n-            { \r\n-                id: userToImpersonate._id,\r\n-                companyId: userToImpersonate.company, \r\n-                username: userToImpersonate.username, // Importante para a rota /me\r\n-                impersonator: adminId\r\n-            },\r\n-            process.env.JWT_SECRET,\r\n-            { expiresIn: '1h' }\r\n-        );\r\n-\r\n-        res.status(200).json({\r\n-            message: 'Token de representação gerado com sucesso.',\r\n-            token,\r\n-            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n-            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao tentar representar usuário:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota para testar manualmente o envio do relatório diário\r\n-router.post('/test-daily-report', async (req, res) => {\r\n-    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n-    if (!req.user.impersonator) {\r\n-        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n-    }\r\n-\r\n-    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n-    const company = req.company; // O middleware já nos deu a empresa representada\r\n-\r\n-    const today = new Date();\r\n-    today.setUTCHours(0, 0, 0, 0);\r\n-    const todayStr = today.toISOString().split('T')[0];\r\n-\r\n-    try {\r\n-        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n-        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n-\r\n-        const overdueParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        const dueTodayParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n-        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n-\r\n-        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n-            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n-            res.status(200).json({ \r\n-                message: `E-mail de relatório enviado para ${company.email}!`,\r\n-                overdueCount: overdueParcels.length,\r\n-                dueTodayCount: dueTodayParcels.length\r\n-            });\r\n-        } else {\r\n-            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n-            res.status(200).json({ \r\n-                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n-                overdueCount: 0,\r\n-                dueTodayCount: 0\r\n-            });\r\n-        }\r\n-    } catch (error) {\r\n-        console.error('[TESTE MANUAL] Erro:', error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n-    }\r\n-});\r\n-\r\n-// --- GESTÃO DE ANÚNCIOS ---\r\n-\r\n-router.route('/announcements')\r\n-    // Rota para LER todos os anúncios\r\n-    .get(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n-            res.status(200).json(announcements);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao buscar anúncios:\", error);\r\n-            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n-        }\r\n-    })\r\n-    // Rota para CRIAR um novo anúncio\r\n-    .post(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const { message, link, isActive } = req.body;\r\n-\r\n-            if (!message) {\r\n-                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n-            }\r\n-\r\n-            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n-            res.status(201).json(newAnnouncement);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao criar anúncio:\", error);\r\n-            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n-        }\r\n-    });\r\n-\r\n-// Rota para ATUALIZAR um anúncio\r\n-router.patch('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const { message, link, isActive } = req.body;\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        \r\n-        if (isActive) {\r\n-            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n-        }\r\n-\r\n-        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { message, link, isActive },\r\n-            { new: true }\r\n-        );\r\n-        res.status(200).json(updatedAnnouncement);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para APAGAR um anúncio\r\n-router.delete('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        await Announcement.findByIdAndDelete(req.params.id);\r\n-        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER todos os templates de e-mail\r\n-router.get('/email-templates', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n-        res.json(templates);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER UM template de e-mail específico pelo ID\r\n-router.get('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const template = await EmailTemplate.findById(req.params.templateId);\r\n-        if (!template) {\r\n-            return res.status(404).json({ message: 'Template não encontrado.' });\r\n-        }\r\n-        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR um template específico\r\n-router.patch('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const { subject, body } = req.body;\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n-            req.params.templateId,\r\n-            { subject, body },\r\n-            { new: true }\r\n-        );\r\n-        res.json(updatedTemplate);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota de pesquisa global para o admin\r\n-router.get('/search', async (req, res) => {\r\n-    try {\r\n-        const query = req.query.q || ''; // 'q' vem de \"query\"\r\n-        if (query.length < 2) {\r\n-            // Evita pesquisas vazias ou muito curtas para não sobrecarregar o DB\r\n-            return res.json({ users: [], companies: [] });\r\n-        }\r\n-\r\n-        // Cria uma expressão regular para pesquisa case-insensitive\r\n-        const searchRegex = new RegExp(query, 'i');\r\n-\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // 1. Pesquisa por Utilizadores (no username e email)\r\n-        const userResults = await MasterUser.find({\r\n-            $or: [\r\n-                { username: searchRegex },\r\n-                { email: searchRegex }\r\n-            ]\r\n-        }).populate('company', 'nomeEmpresa'); // Inclui o nome da empresa no resultado\r\n-\r\n-        // 2. Pesquisa por Empresas (no nome e CNPJ)\r\n-        const companyResults = await MasterCompany.find({\r\n-            $or: [\r\n-                { nomeEmpresa: searchRegex },\r\n-                { cnpj: query.replace(/\\D/g, '') } // Pesquisa por CNPJ apenas com números\r\n-            ]\r\n-        });\r\n-\r\n-        // 3. Retorna os resultados em um objeto organizado\r\n-        res.json({\r\n-            users: userResults,\r\n-            companies: companyResults\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro na pesquisa global do admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/bulk-email', async (req, res) => {\r\n-    try {\r\n-        const { audience, subject, body } = req.body;\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        let recipients = [];\r\n-        switch (audience) {\r\n-            case 'allProprietors':\r\n-                recipients = await MasterUser.find({ role: 'Proprietário' }).select('email');\r\n-                break;\r\n-            case 'activeSubscribers':\r\n-                const activeCompanies = await MasterCompany.find({ 'subscription.status': 'active' }).select('_id');\r\n-                const activeCompanyIds = activeCompanies.map(c => c._id);\r\n-                recipients = await MasterUser.find({ company: { $in: activeCompanyIds }, role: 'Proprietário' }).select('email');\r\n-                break;\r\n-            // (Pode adicionar outros casos como 'inactiveSubscribers' e 'allUsers' aqui)\r\n-            default:\r\n-                return res.status(400).json({ message: 'Público-alvo inválido.' });\r\n-        }\r\n-\r\n-        const emailList = recipients.map(r => r.email);\r\n-\r\n-        if (emailList.length === 0) {\r\n-            return res.status(404).json({ message: 'Nenhum destinatário encontrado para este público.' });\r\n-        }\r\n-        \r\n-        // AVISO: A lógica abaixo envia e-mails em sequência.\r\n-        // Para um grande número de utilizadores, isto pode ser lento e causar timeout.\r\n-        // A solução ideal para produção é um sistema de filas (queue).\r\n-        for (const email of emailList) {\r\n-            // Aqui você chamaria uma função genérica do seu emailService\r\n-            // await emailService.sendGenericEmail(email, subject, body);\r\n-        }\r\n-\r\n-        res.json({ message: `E-mail enviado para ${emailList.length} destinatários.` });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro no envio de e-mail em massa:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const jwt = require('jsonwebtoken');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-const { getTenantConnection } = require('../config/db');\r\n-const { sendDailyReportEmail } = require('../services/emailService');\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n-const AnnouncementSchema = require('../models/Announcement').schema;\r\n-const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n-\r\n-\r\n-// Nova rota para buscar a lista de assinaturas de todas as empresas\r\n-router.get('/subscriptions', async (req, res) => {\r\n-    // A segurança (verificar se é SuperAdmin) já é tratada pelo middleware\r\n-    // que é aplicado a todo este ficheiro no seu server.js.\r\n-\r\n-    try {\r\n-        // Obtém o modelo a partir da conexão com o banco de dados mestre\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // Busca todas as empresas, selecionando apenas os campos necessários\r\n-        const subscriptionsData = await MasterCompany.find({})\r\n-            .select('_id nomeEmpresa cnpj subscription') // Otimização para buscar só o que precisamos\r\n-            .sort({ nomeEmpresa: 1 }); // Ordena por nome da empresa\r\n-\r\n-        // Envia a lista como resposta JSON\r\n-        res.json(subscriptionsData);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar dados de assinaturas para o admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Nova rota para buscar as estatísticas do dashboard do admin\r\n-router.get('/dashboard-stats', async (req, res) => {\r\n-    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n-    // pelo middleware no seu ficheiro de servidor principal.\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // --- 1. Buscar os KPIs (Indicadores) ---\r\n-        const totalCompanies = await MasterCompany.countDocuments();\r\n-        const totalUsers = await MasterUser.countDocuments();\r\n-        const activeSubscriptions = await MasterCompany.countDocuments({\r\n-            'subscription.status': 'active'\r\n-        });\r\n-\r\n-        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n-        const thirtyDaysAgo = new Date();\r\n-        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n-\r\n-        const newCompaniesData = await MasterCompany.aggregate([\r\n-            // Filtra empresas criadas nos últimos 30 dias\r\n-            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n-            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n-            {\r\n-                $group: {\r\n-                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n-                    count: { $sum: 1 }\r\n-                }\r\n-            },\r\n-            // Ordena por data\r\n-            { $sort: { _id: 1 } },\r\n-            // Formata a saída para o formato que o frontend espera\r\n-            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n-        ]);\r\n-\r\n-        // --- 3. Envia a resposta completa em formato JSON ---\r\n-        res.json({\r\n-            totalCompanies,\r\n-            totalUsers,\r\n-            activeSubscriptions,\r\n-            newCompaniesLast30Days: newCompaniesData\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/impersonate', async (req, res) => {\r\n-    try {\r\n-        const masterDb = req.masterDb;\r\n-        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-        const adminId = req.user.id;\r\n-        const { companyId, userId } = req.body;\r\n-        const userToImpersonate = await MasterUser.findById(userId);\r\n-\r\n-        if (!userToImpersonate || userToImpersonate.company.toString() !== companyId) {\r\n-             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n-        }\r\n-        \r\n-        const companyToImpersonate = await MasterCompany.findById(companyId);\r\n-        if (!companyToImpersonate) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        const token = jwt.sign(\r\n-            { \r\n-                id: userToImpersonate._id,\r\n-                companyId: userToImpersonate.company, \r\n-                username: userToImpersonate.username, // Importante para a rota /me\r\n-                impersonator: adminId\r\n-            },\r\n-            process.env.JWT_SECRET,\r\n-            { expiresIn: '1h' }\r\n-        );\r\n-\r\n-        res.status(200).json({\r\n-            message: 'Token de representação gerado com sucesso.',\r\n-            token,\r\n-            user: { _id: userToImpersonate._id, username: userToImpersonate.username },\r\n-            company: { _id: companyToImpersonate._id, nomeEmpresa: companyToImpersonate.nomeEmpresa }\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao tentar representar usuário:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-// Rota para testar manualmente o envio do relatório diário\r\n-router.post('/test-daily-report', async (req, res) => {\r\n-    // Esta rota é para o admin representar uma empresa e testar o e-mail para ela\r\n-    if (!req.user.impersonator) {\r\n-        return res.status(403).json({ message: 'Esta função só pode ser usada pelo SuperAdmin ao representar uma empresa.' });\r\n-    }\r\n-\r\n-    console.log('[TESTE MANUAL] A iniciar teste de relatório diário...');\r\n-    const company = req.company; // O middleware já nos deu a empresa representada\r\n-\r\n-    const today = new Date();\r\n-    today.setUTCHours(0, 0, 0, 0);\r\n-    const todayStr = today.toISOString().split('T')[0];\r\n-\r\n-    try {\r\n-        const tenantDb = req.tenantDb; // O middleware já nos deu a conexão\r\n-        const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n-\r\n-        const overdueParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        const dueTodayParcels = await Boleto.aggregate([\r\n-            { $unwind: '$parcels' },\r\n-            { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n-            { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-        ]);\r\n-\r\n-        console.log(`[TESTE MANUAL] Parcelas vencidas encontradas: ${overdueParcels.length}`);\r\n-        console.log(`[TESTE MANUAL] Parcelas a vencer hoje encontradas: ${dueTodayParcels.length}`);\r\n-\r\n-        if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-            console.log(`[TESTE MANUAL] A enviar e-mail para ${company.email}...`);\r\n-            await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n-            res.status(200).json({ \r\n-                message: `E-mail de relatório enviado para ${company.email}!`,\r\n-                overdueCount: overdueParcels.length,\r\n-                dueTodayCount: dueTodayParcels.length\r\n-            });\r\n-        } else {\r\n-            console.log('[TESTE MANUAL] Nenhum dado para enviar.');\r\n-            res.status(200).json({ \r\n-                message: 'A lógica funcionou, mas não havia parcelas vencidas ou a vencer hoje para reportar.',\r\n-                overdueCount: 0,\r\n-                dueTodayCount: 0\r\n-            });\r\n-        }\r\n-    } catch (error) {\r\n-        console.error('[TESTE MANUAL] Erro:', error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro durante o teste.' });\r\n-    }\r\n-});\r\n-\r\n-// --- GESTÃO DE ANÚNCIOS ---\r\n-\r\n-router.route('/announcements')\r\n-    // Rota para LER todos os anúncios\r\n-    .get(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const announcements = await Announcement.find({}).sort({ createdAt: -1 });\r\n-            res.status(200).json(announcements);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao buscar anúncios:\", error);\r\n-            res.status(500).json({ message: 'Erro ao buscar anúncios.' });\r\n-        }\r\n-    })\r\n-    // Rota para CRIAR um novo anúncio\r\n-    .post(async (req, res) => {\r\n-        try {\r\n-            const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-            const { message, link, isActive } = req.body;\r\n-\r\n-            if (!message) {\r\n-                return res.status(400).json({ message: 'O campo \"message\" é obrigatório.' });\r\n-            }\r\n-\r\n-            const newAnnouncement = await Announcement.create({ message, link, isActive });\r\n-            res.status(201).json(newAnnouncement);\r\n-        } catch (error) {\r\n-            console.error(\"Erro ao criar anúncio:\", error);\r\n-            res.status(500).json({ message: 'Erro interno do servidor ao criar o anúncio.' });\r\n-        }\r\n-    });\r\n-\r\n-// Rota para ATUALIZAR um anúncio\r\n-router.patch('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const { message, link, isActive } = req.body;\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        \r\n-        if (isActive) {\r\n-            await Announcement.updateMany({}, { $set: { isActive: false } });\r\n-        }\r\n-\r\n-        const updatedAnnouncement = await Announcement.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { message, link, isActive },\r\n-            { new: true }\r\n-        );\r\n-        res.status(200).json(updatedAnnouncement);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao atualizar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para APAGAR um anúncio\r\n-router.delete('/announcements/:id', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') return res.status(403).json({ message: 'Acesso negado.' });\r\n-    try {\r\n-        const Announcement = req.masterDb.model('Announcement', AnnouncementSchema);\r\n-        await Announcement.findByIdAndDelete(req.params.id);\r\n-        res.status(200).json({ message: 'Anúncio apagado com sucesso.' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao apagar anúncio:\", error); // Adiciona log de erro\r\n-        res.status(500).json({ message: 'Erro ao apagar anúncio.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER todos os templates de e-mail\r\n-router.get('/email-templates', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const templates = await EmailTemplate.find({}).select('name subject'); // Só precisamos do nome e assunto para a lista\r\n-        res.json(templates);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar templates de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER UM template de e-mail específico pelo ID\r\n-router.get('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const template = await EmailTemplate.findById(req.params.templateId);\r\n-        if (!template) {\r\n-            return res.status(404).json({ message: 'Template não encontrado.' });\r\n-        }\r\n-        res.json(template); // Retorna o documento completo, incluindo o 'body'\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao buscar detalhes do template.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR um template específico\r\n-router.patch('/email-templates/:templateId', async (req, res) => {\r\n-    try {\r\n-        const { subject, body } = req.body;\r\n-        const EmailTemplate = req.masterDb.model('EmailTemplate', EmailTemplateSchema);\r\n-        const updatedTemplate = await EmailTemplate.findByIdAndUpdate(\r\n-            req.params.templateId,\r\n-            { subject, body },\r\n-            { new: true }\r\n-        );\r\n-        res.json(updatedTemplate);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro ao atualizar o template de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota de pesquisa global para o admin\r\n-router.get('/search', async (req, res) => {\r\n-    try {\r\n-        const query = req.query.q || ''; // 'q' vem de \"query\"\r\n-        if (query.length < 2) {\r\n-            // Evita pesquisas vazias ou muito curtas para não sobrecarregar o DB\r\n-            return res.json({ users: [], companies: [] });\r\n-        }\r\n-\r\n-        // Cria uma expressão regular para pesquisa case-insensitive\r\n-        const searchRegex = new RegExp(query, 'i');\r\n-\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // 1. Pesquisa por Utilizadores (no username e email)\r\n-        const userResults = await MasterUser.find({\r\n-            $or: [\r\n-                { username: searchRegex },\r\n-                { email: searchRegex }\r\n-            ]\r\n-        }).populate('company', 'nomeEmpresa'); // Inclui o nome da empresa no resultado\r\n-\r\n-        // 2. Pesquisa por Empresas (no nome e CNPJ)\r\n-        const companyResults = await MasterCompany.find({\r\n-            $or: [\r\n-                { nomeEmpresa: searchRegex },\r\n-                { cnpj: query.replace(/\\D/g, '') } // Pesquisa por CNPJ apenas com números\r\n-            ]\r\n-        });\r\n-\r\n-        // 3. Retorna os resultados em um objeto organizado\r\n-        res.json({\r\n-            users: userResults,\r\n-            companies: companyResults\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro na pesquisa global do admin:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n-router.post('/bulk-email', async (req, res) => {\r\n-    try {\r\n-        const { audience, subject, body } = req.body;\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        let recipients = [];\r\n-        switch (audience) {\r\n-            case 'allProprietors':\r\n-                recipients = await MasterUser.find({ role: 'Proprietário' }).select('email');\r\n-                break;\r\n-            case 'activeSubscribers':\r\n-                const activeCompanies = await MasterCompany.find({ 'subscription.status': 'active' }).select('_id');\r\n-                const activeCompanyIds = activeCompanies.map(c => c._id);\r\n-                recipients = await MasterUser.find({ company: { $in: activeCompanyIds }, role: 'Proprietário' }).select('email');\r\n-                break;\r\n-            // (Pode adicionar outros casos como 'inactiveSubscribers' e 'allUsers' aqui)\r\n-            default:\r\n-                return res.status(400).json({ message: 'Público-alvo inválido.' });\r\n-        }\r\n-\r\n-        const emailList = recipients.map(r => r.email);\r\n-\r\n-        if (emailList.length === 0) {\r\n-            return res.status(404).json({ message: 'Nenhum destinatário encontrado para este público.' });\r\n-        }\r\n-        \r\n-        // AVISO: A lógica abaixo envia e-mails em sequência.\r\n-        // Para um grande número de utilizadores, isto pode ser lento e causar timeout.\r\n-        // A solução ideal para produção é um sistema de filas (queue).\r\n-        for (const email of emailList) {\r\n-            // Aqui você chamaria uma função genérica do seu emailService\r\n-            // await emailService.sendGenericEmail(email, subject, body);\r\n-        }\r\n-\r\n-        res.json({ message: `E-mail enviado para ${emailList.length} destinatários.` });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro no envio de e-mail em massa:\", error);\r\n-        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n-    }\r\n-});\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754323328769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -400,5 +400,68 @@\n         res.status(500).json({ message: \"Ocorreu um erro ao tentar enviar os e-mails.\" });\r\n     }\r\n });\r\n \r\n+router.post('/email-templates/test-send', async (req, res) => {\r\n+    try {\r\n+        const { templateName, companyId, recipientEmail } = req.body;\r\n+\r\n+        if (!templateName || !companyId || !recipientEmail) {\r\n+            return res.status(400).json({ message: 'Todos os campos são obrigatórios.' });\r\n+        }\r\n+\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const company = await MasterCompany.findById(companyId);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa selecionada não encontrada.' });\r\n+        }\r\n+\r\n+        let placeholders = {};\r\n+\r\n+        // Simulamos a recolha de dados com base no nome do template\r\n+        switch (templateName) {\r\n+            case 'dailyReport':\r\n+                const tenantDb = await getTenantConnection(company.dbName);\r\n+                const Boleto = tenantDb.model('Boleto', require('../models/Boleto').schema);\r\n+                const todayStr = new Date().toISOString().split('T')[0];\r\n+\r\n+                const overdueParcels = await Boleto.aggregate([ /* Sua lógica de agregação para vencidos */ ]);\r\n+                const dueTodayParcels = await Boleto.aggregate([ /* Sua lógica de agregação para a vencer hoje */ ]);\r\n+                \r\n+                // Precisamos de gerar o HTML das parcelas aqui, como no emailService\r\n+                let parcelsHtml = '<h3>Este é um teste de relatório:</h3>'; // Simplificado para o exemplo\r\n+                \r\n+                placeholders = {\r\n+                    companyName: company.nomeEmpresa,\r\n+                    parcelsHtml: parcelsHtml\r\n+                };\r\n+                break;\r\n+\r\n+            case 'emailVerification':\r\n+                placeholders = {\r\n+                    companyName: company.nomeEmpresa,\r\n+                    verificationLink: '#' // Usamos um link de exemplo para o teste\r\n+                };\r\n+                break;\r\n+\r\n+            case 'passwordReset':\r\n+                placeholders = {\r\n+                    resetLink: '#' // Usamos um link de exemplo para o teste\r\n+                };\r\n+                break;\r\n+\r\n+            default:\r\n+                return res.status(400).json({ message: 'Nome de template desconhecido.' });\r\n+        }\r\n+\r\n+        // Usamos a função do emailService para enviar o e-mail de teste\r\n+        await emailService.sendEmailFromTemplate(req.masterDb, templateName, recipientEmail, placeholders);\r\n+\r\n+        res.json({ message: `E-mail de teste enviado com sucesso para ${recipientEmail}!` });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao enviar e-mail de teste:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754323737621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -421,15 +421,40 @@\n         switch (templateName) {\r\n             case 'dailyReport':\r\n                 const tenantDb = await getTenantConnection(company.dbName);\r\n                 const Boleto = tenantDb.model('Boleto', require('../models/Boleto').schema);\r\n-                const todayStr = new Date().toISOString().split('T')[0];\r\n+                const today = new Date();\r\n+                today.setUTCHours(0, 0, 0, 0);\r\n+                const todayStr = today.toISOString().split('T')[0];\r\n \r\n-                const overdueParcels = await Boleto.aggregate([ /* Sua lógica de agregação para vencidos */ ]);\r\n-                const dueTodayParcels = await Boleto.aggregate([ /* Sua lógica de agregação para a vencer hoje */ ]);\r\n+                // --- A CORREÇÃO ESTÁ AQUI ---\r\n+                // Copiamos a lógica de agregação do seu server.js (CRON Job)\r\n+                const overdueParcels = await Boleto.aggregate([\r\n+                    { $unwind: '$parcels' },\r\n+                    { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+                    { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+                ]);\r\n+\r\n+                const dueTodayParcels = await Boleto.aggregate([\r\n+                    { $unwind: '$parcels' },\r\n+                    { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+                    { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+                ]);\r\n                 \r\n-                // Precisamos de gerar o HTML das parcelas aqui, como no emailService\r\n-                let parcelsHtml = '<h3>Este é um teste de relatório:</h3>'; // Simplificado para o exemplo\r\n+                // Também copiamos a lógica de geração de HTML do seu emailService.js\r\n+                let parcelsHtml = '';\r\n+                if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+                    if (overdueParcels.length > 0) {\r\n+                         const overdueHtmlList = overdueParcels.map(item => `...`).join(''); // Cole aqui o HTML de overdueParcels do seu emailService.js\r\n+                         parcelsHtml += `<h3>🚨 Parcelas Vencidas</h3>${overdueHtmlList}`;\r\n+                    }\r\n+                    if (dueTodayParcels.length > 0) {\r\n+                        const dueTodayHtmlList = dueTodayParcels.map(item => `...`).join(''); // Cole aqui o HTML de dueTodayParcels do seu emailService.js\r\n+                        parcelsHtml += `<h3>🔵 A Vencer Hoje</h3>${dueTodayHtmlList}`;\r\n+                    }\r\n+                } else {\r\n+                    parcelsHtml = '<p>Nenhum boleto vencido ou a vencer hoje. Bom trabalho!</p>';\r\n+                }\r\n                 \r\n                 placeholders = {\r\n                     companyName: company.nomeEmpresa,\r\n                     parcelsHtml: parcelsHtml\r\n@@ -438,15 +463,15 @@\n \r\n             case 'emailVerification':\r\n                 placeholders = {\r\n                     companyName: company.nomeEmpresa,\r\n-                    verificationLink: '#' // Usamos um link de exemplo para o teste\r\n+                    verificationLink: '#'\r\n                 };\r\n                 break;\r\n \r\n             case 'passwordReset':\r\n                 placeholders = {\r\n-                    resetLink: '#' // Usamos um link de exemplo para o teste\r\n+                    resetLink: '#'\r\n                 };\r\n                 break;\r\n \r\n             default:\r\n"
                },
                {
                    "date": 1754324111307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -405,9 +405,9 @@\n     try {\r\n         const { templateName, companyId, recipientEmail } = req.body;\r\n \r\n         if (!templateName || !companyId || !recipientEmail) {\r\n-            return res.status(400).json({ message: 'Todos os campos são obrigatórios.' });\r\n+            return res.status(400).json({ message: 'Todos os campos são obrigatórios: nome do template, ID da empresa e e-mail do destinatário.' });\r\n         }\r\n \r\n         const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n         const company = await MasterCompany.findById(companyId);\r\n@@ -416,45 +416,62 @@\n         }\r\n \r\n         let placeholders = {};\r\n \r\n-        // Simulamos a recolha de dados com base no nome do template\r\n+        // Simula a recolha de dados com base no nome do template\r\n         switch (templateName) {\r\n             case 'dailyReport':\r\n                 const tenantDb = await getTenantConnection(company.dbName);\r\n                 const Boleto = tenantDb.model('Boleto', require('../models/Boleto').schema);\r\n                 const today = new Date();\r\n                 today.setUTCHours(0, 0, 0, 0);\r\n                 const todayStr = today.toISOString().split('T')[0];\r\n \r\n-                // --- A CORREÇÃO ESTÁ AQUI ---\r\n-                // Copiamos a lógica de agregação do seu server.js (CRON Job)\r\n+                // Busca as parcelas vencidas\r\n                 const overdueParcels = await Boleto.aggregate([\r\n                     { $unwind: '$parcels' },\r\n                     { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n                     { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n                 ]);\r\n \r\n+                // Busca as parcelas que vencem hoje\r\n                 const dueTodayParcels = await Boleto.aggregate([\r\n                     { $unwind: '$parcels' },\r\n                     { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n                     { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n                 ]);\r\n                 \r\n-                // Também copiamos a lógica de geração de HTML do seu emailService.js\r\n+                // Gera o HTML das listas de parcelas\r\n                 let parcelsHtml = '';\r\n-                if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-                    if (overdueParcels.length > 0) {\r\n-                         const overdueHtmlList = overdueParcels.map(item => `...`).join(''); // Cole aqui o HTML de overdueParcels do seu emailService.js\r\n-                         parcelsHtml += `<h3>🚨 Parcelas Vencidas</h3>${overdueHtmlList}`;\r\n-                    }\r\n-                    if (dueTodayParcels.length > 0) {\r\n-                        const dueTodayHtmlList = dueTodayParcels.map(item => `...`).join(''); // Cole aqui o HTML de dueTodayParcels do seu emailService.js\r\n-                        parcelsHtml += `<h3>🔵 A Vencer Hoje</h3>${dueTodayHtmlList}`;\r\n-                    }\r\n-                } else {\r\n-                    parcelsHtml = '<p>Nenhum boleto vencido ou a vencer hoje. Bom trabalho!</p>';\r\n+                if (overdueParcels.length > 0) {\r\n+                    const overdueHtmlList = overdueParcels.map(item => `\r\n+                        <div style=\"border: 1px solid #c0392b; padding: 10px; margin-bottom: 10px; border-radius: 5px; background-color: #f2dede;\">\r\n+                            <strong>Nome:</strong> ${item.billName}<br>\r\n+                            ${item.nfeNumber ? `<strong>Cód. NF:</strong> ${item.nfeNumber}<br>` : ''}\r\n+                            <strong>Parcela:</strong> ${item.parcelNumber}<br>\r\n+                            <strong>Valor:</strong> ${item.amount.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}<br>\r\n+                            <strong>Vencimento:</strong> ${new Date(item.dueDate + 'T00:00:00').toLocaleDateString('pt-BR')}\r\n+                        </div>\r\n+                    `).join('');\r\n+                    parcelsHtml += `<h3 style=\"color: #c0392b;\">🚨 Parcelas Vencidas</h3>${overdueHtmlList}`;\r\n                 }\r\n+\r\n+                if (dueTodayParcels.length > 0) {\r\n+                    const dueTodayHtmlList = dueTodayParcels.map(item => `\r\n+                        <div style=\"border: 1px solid #2980b9; padding: 10px; margin-bottom: 10px; border-radius: 5px; background-color: #eaf2f8;\">\r\n+                            <strong>Nome:</strong> ${item.billName}<br>\r\n+                            ${item.nfeNumber ? `<strong>Cód. NF:</strong> ${item.nfeNumber}<br>` : ''}\r\n+                            <strong>Parcela:</strong> ${item.parcelNumber}<br>\r\n+                            <strong>Valor:</strong> ${item.amount.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}<br>\r\n+                            <strong>Vencimento:</strong> ${new Date(item.dueDate + 'T00:00:00').toLocaleDateString('pt-BR')}\r\n+                        </div>\r\n+                    `).join('');\r\n+                    parcelsHtml += `<h3 style=\"margin-top: 25px;\">🔵 A Vencer Hoje</h3>${dueTodayHtmlList}`;\r\n+                }\r\n+\r\n+                if (parcelsHtml === '') {\r\n+                    parcelsHtml = '<p>Nenhum boleto vencido ou a vencer hoje para esta empresa. Bom trabalho!</p>';\r\n+                }\r\n                 \r\n                 placeholders = {\r\n                     companyName: company.nomeEmpresa,\r\n                     parcelsHtml: parcelsHtml\r\n@@ -463,23 +480,23 @@\n \r\n             case 'emailVerification':\r\n                 placeholders = {\r\n                     companyName: company.nomeEmpresa,\r\n-                    verificationLink: '#'\r\n+                    verificationLink: '#' // Usamos um link de exemplo, pois o token é gerado apenas no registo real\r\n                 };\r\n                 break;\r\n \r\n             case 'passwordReset':\r\n                 placeholders = {\r\n-                    resetLink: '#'\r\n+                    resetLink: '#' // Usamos um link de exemplo, pois o token é gerado apenas na solicitação real\r\n                 };\r\n                 break;\r\n \r\n             default:\r\n                 return res.status(400).json({ message: 'Nome de template desconhecido.' });\r\n         }\r\n \r\n-        // Usamos a função do emailService para enviar o e-mail de teste\r\n+        // Usa a função do emailService para enviar o e-mail de teste para o destinatário especificado\r\n         await emailService.sendEmailFromTemplate(req.masterDb, templateName, recipientEmail, placeholders);\r\n \r\n         res.json({ message: `E-mail de teste enviado com sucesso para ${recipientEmail}!` });\r\n \r\n"
                },
                {
                    "date": 1754326040645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,48 +42,37 @@\n });\r\n \r\n // Nova rota para buscar as estatísticas do dashboard do admin\r\n router.get('/dashboard-stats', async (req, res) => {\r\n-    // A verificação de que o req.user.role é 'SuperAdmin' já é feita\r\n-    // pelo middleware no seu ficheiro de servidor principal.\r\n-\r\n     try {\r\n         const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterCompanySchema);\r\n \r\n-        // --- 1. Buscar os KPIs (Indicadores) ---\r\n+        // --- As buscas existentes continuam iguais ---\r\n         const totalCompanies = await MasterCompany.countDocuments();\r\n         const totalUsers = await MasterUser.countDocuments();\r\n-        const activeSubscriptions = await MasterCompany.countDocuments({\r\n-            'subscription.status': 'active'\r\n-        });\r\n+        const activeSubscriptions = await MasterCompany.countDocuments({ 'subscription.status': 'active' });\r\n \r\n-        // --- 2. Buscar os dados para o gráfico de novas empresas ---\r\n         const thirtyDaysAgo = new Date();\r\n         thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n+        const newCompaniesData = await MasterCompany.aggregate([ /* ... sua agregação aqui ... */ ]);\r\n \r\n-        const newCompaniesData = await MasterCompany.aggregate([\r\n-            // Filtra empresas criadas nos últimos 30 dias\r\n-            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n-            // Agrupa por dia e conta quantas empresas foram criadas em cada dia\r\n-            {\r\n-                $group: {\r\n-                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n-                    count: { $sum: 1 }\r\n-                }\r\n-            },\r\n-            // Ordena por data\r\n-            { $sort: { _id: 1 } },\r\n-            // Formata a saída para o formato que o frontend espera\r\n-            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n-        ]);\r\n+        // --- NOVA LÓGICA ADICIONADA AQUI ---\r\n+        // Busca as 5 empresas mais recentes, ordenando pela data de criação\r\n+        const recentlyAddedCompanies = await MasterCompany.find({})\r\n+            .sort({ createdAt: -1 }) // -1 para ordem descendente (mais novo primeiro)\r\n+            .limit(5) // Limita o resultado a 5 documentos\r\n+            .select('nomeEmpresa createdAt'); // Seleciona apenas os campos que precisamos\r\n \r\n-        // --- 3. Envia a resposta completa em formato JSON ---\r\n+        // --- FIM DA NOVA LÓGICA ---\r\n+\r\n+        // Adiciona a nova lista à resposta JSON\r\n         res.json({\r\n             totalCompanies,\r\n             totalUsers,\r\n             activeSubscriptions,\r\n-            newCompaniesLast30Days: newCompaniesData\r\n+            newCompaniesLast30Days: newCompaniesData,\r\n+            recentlyAddedCompanies: recentlyAddedCompanies // Nova propriedade\r\n         });\r\n \r\n     } catch (error) {\r\n         console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n"
                },
                {
                    "date": 1754326397503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,35 +44,45 @@\n // Nova rota para buscar as estatísticas do dashboard do admin\r\n router.get('/dashboard-stats', async (req, res) => {\r\n     try {\r\n         const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema); // Corrigido para usar o Schema correto\r\n \r\n-        // --- As buscas existentes continuam iguais ---\r\n+        // Buscas para os KPIs\r\n         const totalCompanies = await MasterCompany.countDocuments();\r\n         const totalUsers = await MasterUser.countDocuments();\r\n         const activeSubscriptions = await MasterCompany.countDocuments({ 'subscription.status': 'active' });\r\n \r\n+        // --- A CORREÇÃO ESTÁ AQUI ---\r\n+        // Preenchemos a lógica de agregação que estava em falta\r\n         const thirtyDaysAgo = new Date();\r\n         thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n-        const newCompaniesData = await MasterCompany.aggregate([ /* ... sua agregação aqui ... */ ]);\r\n+        \r\n+        const newCompaniesData = await MasterCompany.aggregate([\r\n+            { $match: { createdAt: { $gte: thirtyDaysAgo } } },\r\n+            { \r\n+                $group: { \r\n+                    _id: { $dateToString: { format: \"%Y-%m-%d\", date: \"$createdAt\" } },\r\n+                    count: { $sum: 1 }\r\n+                } \r\n+            },\r\n+            { $sort: { _id: 1 } },\r\n+            { $project: { _id: 0, date: \"$_id\", count: \"$count\" } }\r\n+        ]);\r\n \r\n-        // --- NOVA LÓGICA ADICIONADA AQUI ---\r\n-        // Busca as 5 empresas mais recentes, ordenando pela data de criação\r\n+        // Busca pelas empresas recentes\r\n         const recentlyAddedCompanies = await MasterCompany.find({})\r\n-            .sort({ createdAt: -1 }) // -1 para ordem descendente (mais novo primeiro)\r\n-            .limit(5) // Limita o resultado a 5 documentos\r\n-            .select('nomeEmpresa createdAt'); // Seleciona apenas os campos que precisamos\r\n+            .sort({ createdAt: -1 })\r\n+            .limit(5)\r\n+            .select('nomeEmpresa createdAt');\r\n \r\n-        // --- FIM DA NOVA LÓGICA ---\r\n-\r\n-        // Adiciona a nova lista à resposta JSON\r\n+        // Envia a resposta completa\r\n         res.json({\r\n             totalCompanies,\r\n             totalUsers,\r\n             activeSubscriptions,\r\n             newCompaniesLast30Days: newCompaniesData,\r\n-            recentlyAddedCompanies: recentlyAddedCompanies // Nova propriedade\r\n+            recentlyAddedCompanies: recentlyAddedCompanies\r\n         });\r\n \r\n     } catch (error) {\r\n         console.error(\"Erro ao buscar estatísticas do dashboard de admin:\", error);\r\n"
                },
                {
                    "date": 1754505730892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,15 +2,16 @@\n const router = express.Router();\r\n const jwt = require('jsonwebtoken');\r\n \r\n // CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const { schema: MasterCompanySchema } = require('../models/MasterCompany');\r\n+const { schema: MasterUserSchema } = require('../models/MasterUser');\r\n+const { schema: BoletoSchema } = require('../models/Boleto')\r\n+const { schema: AnnouncementSchema } = require('../models/Announcement')\r\n+const { schema: EmailTemplateSchema } = require('../models/EmailTemplate')\r\n+\r\n const { getTenantConnection } = require('../config/db');\r\n const { sendDailyReportEmail } = require('../services/emailService');\r\n-const BoletoSchema = require('../models/Boleto').schema;\r\n-const AnnouncementSchema = require('../models/Announcement').schema;\r\n-const EmailTemplateSchema = require('../models/EmailTemplate').schema;\r\n const emailService = require('../services/emailService');\r\n \r\n \r\n // Nova rota para buscar a lista de assinaturas de todas as empresas\r\n"
                },
                {
                    "date": 1754505933939,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,11 +4,11 @@\n \r\n // CORREÇÃO: Importamos os ESQUEMAS, e não os modelos pré-compilados\r\n const { schema: MasterCompanySchema } = require('../models/MasterCompany');\r\n const { schema: MasterUserSchema } = require('../models/MasterUser');\r\n-const { schema: BoletoSchema } = require('../models/Boleto')\r\n-const { schema: AnnouncementSchema } = require('../models/Announcement')\r\n-const { schema: EmailTemplateSchema } = require('../models/EmailTemplate')\r\n+const { schema: BoletoSchema } = require('../models/Boleto');\r\n+const { schema: AnnouncementSchema } = require('../models/Announcement');\r\n+const { schema: EmailTemplateSchema } = require('../models/EmailTemplate');\r\n \r\n const { getTenantConnection } = require('../config/db');\r\n const { sendDailyReportEmail } = require('../services/emailService');\r\n const emailService = require('../services/emailService');\r\n"
                }
            ],
            "date": 1752269564509,
            "name": "Commit-0",
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst jwt = require('jsonwebtoken');\r\n\r\n// MUDANÇA: Importamos os modelos necessários\r\nconst Company = require('../models/Company');\r\nconst User = require('../models/User');\r\n\r\nconst { protect } = require('../middleware/authMiddleware');\r\n\r\nrouter.post('/impersonate', protect, async (req, res) => {\r\n    try {\r\n        const adminId = req.user.id;\r\n        const { companyId, userId } = req.body;\r\n        \r\n        // ANTES: Procurávamos o usuário dentro do documento da empresa.\r\n        // AGORA: Procuramos o usuário diretamente e verificamos se ele pertence à empresa correta.\r\n        const user = await User.findById(userId);\r\n\r\n        if (!user || user.company.toString() !== companyId) {\r\n             return res.status(404).json({ message: \"Usuário não encontrado nesta empresa.\" });\r\n        }\r\n        \r\n        const company = await Company.findById(companyId);\r\n        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n\r\n        // A geração do token continua igual.\r\n        const token = jwt.sign(\r\n            { \r\n                id: user._id,\r\n                companyId: user.company, \r\n                role: user.role,\r\n                impersonator: adminId\r\n            },\r\n            process.env.JWT_SECRET,\r\n            { expiresIn: '1h' }\r\n        );\r\n\r\n        res.status(200).json({\r\n            message: 'Token de representação gerado com sucesso.',\r\n            token,\r\n            user: { _id: user._id, username: user.username, role: user.role },\r\n            company: { _id: company._id, nomeEmpresa: company.nomeEmpresa } // Enviamos só o necessário\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro ao tentar representar usuário:\", error);\r\n        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n    }\r\n});\r\n\r\nmodule.exports = router;"
        }
    ]
}