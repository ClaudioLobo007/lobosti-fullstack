{
    "sourceFile": "Servidor/routes/boletos.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 21,
            "patches": [
                {
                    "date": 1752243404018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752243417277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,42 +107,39 @@\n \r\n // ================================================================\r\n // Rota para EXCLUIR uma parcela específica (Delete)\r\n // ================================================================\r\n-router.delete('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n+router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role } = req.user;\r\n+        const { companyId, role, username } = req.user;\r\n+        const { boletoId } = req.params;\r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        // <<< VERIFICAÇÃO DE PERMISSÃO ADICIONADA >>>\r\n-        if (role !== 'Proprietário' && !company.permissions[role]?.canDelete) {\r\n-            return res.status(403).json({ message: 'Você não tem permissão para excluir boletos.' });\r\n+        const userOwner = company.usuarios.find(user => user.boletos.some(boleto => boleto.id === boletoId));\r\n+        if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+\r\n+        const boletoToDelete = userOwner.boletos.find(b => b.id === boletoId);\r\n+\r\n+        // <<< NOVA LÓGICA DE VERIFICAÇÃO DE PERMISSÃO >>>\r\n+        const permissionLevel = company.permissions[role]?.canDelete;\r\n+        const isOwner = boletoToDelete.ownerUsername === username;\r\n+\r\n+        if (role !== 'Proprietário') {\r\n+            if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n+            }\r\n         }\r\n-        \r\n-        const { boletoId, parcelId } = req.params;\r\n-        let userOwner, boletoToUpdate;\r\n-        for (const user of company.usuarios) {\r\n-            const foundBoleto = user.boletos.find(b => b.id === boletoId);\r\n-            if (foundBoleto) { userOwner = user; boletoToUpdate = foundBoleto; break; }\r\n-        }\r\n-        if (!boletoToUpdate) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        // <<< FIM DA VERIFICAÇÃO >>>\r\n \r\n-        const originalParcelCount = boletoToUpdate.parcels.length;\r\n-        boletoToUpdate.parcels = boletoToUpdate.parcels.filter(p => p.id !== parcelId);\r\n+        userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n         \r\n-        if (boletoToUpdate.parcels.length < originalParcelCount && boletoToUpdate.parcels.length === 0) {\r\n-            userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n-        }\r\n-        \r\n         await company.save();\r\n-        res.status(200).json({ message: 'Parcela excluída com sucesso!' });\r\n+        res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n     } catch (error) {\r\n-        console.error(\"Erro ao excluir parcela:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n-\r\n // ================================================================\r\n // Rota para EXCLUIR um BOLETO INTEIRO\r\n // ================================================================\r\n router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n"
                },
                {
                    "date": 1752243423783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -138,8 +138,9 @@\n     } catch (error) {\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n+\r\n // ================================================================\r\n // Rota para EXCLUIR um BOLETO INTEIRO\r\n // ================================================================\r\n router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n"
                },
                {
                    "date": 1752251416081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,41 +62,37 @@\n // Rota para ATUALIZAR uma parcela específica (Update)\r\n // ================================================================\r\n router.patch('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, username } = req.user;\r\n+        const { companyId, role, id: loggedInUserId } = req.user; // <<< MUDANÇA: Usando o ID do usuário\r\n         const { boletoId, parcelId } = req.params;\r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n         let boletoToUpdate, parcelToUpdate, userOwner;\r\n         for (const user of company.usuarios) {\r\n             boletoToUpdate = user.boletos.find(b => b.id === boletoId);\r\n             if (boletoToUpdate) {\r\n-                userOwner = user;\r\n+                userOwner = user; // userOwner agora é o objeto completo do usuário dono do boleto\r\n                 parcelToUpdate = boletoToUpdate.parcels.find(p => p.id === parcelId);\r\n                 if (parcelToUpdate) break;\r\n             }\r\n         }\r\n         if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n \r\n-        // <<< NOVA LÓGICA DE VERIFICAÇÃO DE PERMISSÃO >>>\r\n+        // <<< LÓGICA DE PERMISSÃO CORRIGIDA >>>\r\n         const permissionLevel = company.permissions[role]?.canUpdate;\r\n-        const isOwner = boletoToUpdate.ownerUsername === username;\r\n+        const isOwner = userOwner._id.toString() === loggedInUserId; // <<< MUDANÇA: Comparando IDs\r\n \r\n-        if (role !== 'Proprietário') {\r\n-            if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n+        if (role !== 'Proprietário' && role !== 'Gerente') { // Gerente com 'all' pode editar\r\n+             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n             }\r\n         }\r\n         // <<< FIM DA VERIFICAÇÃO >>>\r\n \r\n         const { paid, amount, dueDate, description, barcode } = req.body;\r\n-        if (paid !== undefined) parcelToUpdate.paid = paid;\r\n-        if (amount !== undefined) parcelToUpdate.amount = amount;\r\n-        if (dueDate !== undefined) parcelToUpdate.dueDate = dueDate;\r\n-        if (description !== undefined) parcelToUpdate.description = description;\r\n-        if (barcode !== undefined) parcelToUpdate.barcode = barcode;\r\n+        // ... resto do código de atualização ...\r\n         \r\n         company.markModified('usuarios');\r\n         await company.save();\r\n         res.status(200).json({ message: 'Parcela atualizada com sucesso!', parcel: parcelToUpdate });\r\n@@ -144,27 +140,32 @@\n // Rota para EXCLUIR um BOLETO INTEIRO\r\n // ================================================================\r\n router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role } = req.user;\r\n+        const { companyId, role, id: loggedInUserId } = req.user;\r\n         const { boletoId } = req.params;\r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        // <<< VERIFICAÇÃO DE PERMISSÃO ADICIONADA >>>\r\n-        if (role !== 'Proprietário' && !company.permissions[role]?.canDelete) {\r\n-            return res.status(403).json({ message: 'Você não tem permissão para excluir boletos.' });\r\n-        }\r\n-\r\n         const userOwner = company.usuarios.find(user => user.boletos.some(boleto => boleto.id === boletoId));\r\n         if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n \r\n+        // <<< LÓGICA DE PERMISSÃO CORRIGIDA >>>\r\n+        const permissionLevel = company.permissions[role]?.canDelete;\r\n+        const isOwner = userOwner._id.toString() === loggedInUserId; // <<< MUDANÇA: Comparando IDs\r\n+\r\n+        if (role !== 'Proprietário' && role !== 'Gerente') { // Gerente com 'all' pode excluir\r\n+            if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n+            }\r\n+        }\r\n+        // <<< FIM DA VERIFICAÇÃO >>>\r\n+\r\n         userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n         \r\n         await company.save();\r\n         res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n     } catch (error) {\r\n-        console.error(\"Erro ao excluir o boleto completo:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n"
                },
                {
                    "date": 1752252559739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,16 +3,13 @@\n const Company = require('../models/Company');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const { logAction } = require('../middleware/logMiddleware');\r\n \r\n-// ================================================================\r\n-// Rota para CRIAR um novo boleto (Create)\r\n-// Por padrão, todos os usuários podem criar boletos.\r\n-// ================================================================\r\n+// Rota para CRIAR um novo boleto (Não muda)\r\n router.post('/', protect, logAction, async (req, res) => {\r\n     try {\r\n         const { name, parcels } = req.body;\r\n-        const { companyId, id: userId } = req.user;\r\n+        const { companyId, id: userId, username } = req.user;\r\n \r\n         if (!name || !parcels || parcels.length === 0) {\r\n             return res.status(400).json({ message: 'Dados do boleto ou das parcelas estão faltando.' });\r\n         }\r\n@@ -39,12 +36,9 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// ================================================================\r\n-// Rota para LER os boletos da empresa (Read)\r\n-// Todos os usuários da empresa podem ver todos os boletos.\r\n-// ================================================================\r\n+// Rota para LER os boletos da empresa (Não muda)\r\n router.get('/', protect, async (req, res) => {\r\n     try {\r\n         const { companyId } = req.user;\r\n         const company = await Company.findById(companyId);\r\n@@ -57,115 +51,122 @@\n         res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n     }\r\n });\r\n \r\n-// ================================================================\r\n-// Rota para ATUALIZAR uma parcela específica (Update)\r\n-// ================================================================\r\n+// Rota para ATUALIZAR uma parcela específica\r\n router.patch('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, id: loggedInUserId } = req.user; // <<< MUDANÇA: Usando o ID do usuário\r\n+        const { companyId, role, username } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n+        const { paid, amount, dueDate, description, barcode } = req.body;\r\n+\r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        let boletoToUpdate, parcelToUpdate, userOwner;\r\n+        let boletoToUpdate, parcelToUpdate;\r\n         for (const user of company.usuarios) {\r\n             boletoToUpdate = user.boletos.find(b => b.id === boletoId);\r\n             if (boletoToUpdate) {\r\n-                userOwner = user; // userOwner agora é o objeto completo do usuário dono do boleto\r\n                 parcelToUpdate = boletoToUpdate.parcels.find(p => p.id === parcelId);\r\n                 if (parcelToUpdate) break;\r\n             }\r\n         }\r\n         if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n \r\n-        // <<< LÓGICA DE PERMISSÃO CORRIGIDA >>>\r\n         const permissionLevel = company.permissions[role]?.canUpdate;\r\n-        const isOwner = userOwner._id.toString() === loggedInUserId; // <<< MUDANÇA: Comparando IDs\r\n+        const isOwner = boletoToUpdate.ownerUsername === username;\r\n \r\n-        if (role !== 'Proprietário' && role !== 'Gerente') { // Gerente com 'all' pode editar\r\n-             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n+        if (role !== 'Proprietário') {\r\n+            if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n             }\r\n         }\r\n-        // <<< FIM DA VERIFICAÇÃO >>>\r\n \r\n-        const { paid, amount, dueDate, description, barcode } = req.body;\r\n-        // ... resto do código de atualização ...\r\n+        if (paid !== undefined) parcelToUpdate.paid = paid;\r\n+        if (amount !== undefined) parcelToUpdate.amount = amount;\r\n+        if (dueDate !== undefined) parcelToUpdate.dueDate = dueDate;\r\n+        if (description !== undefined) parcelToUpdate.description = description;\r\n+        if (barcode !== undefined) parcelToUpdate.barcode = barcode;\r\n         \r\n-        company.markModified('usuarios');\r\n+        company.markModified('usuarios'); \r\n         await company.save();\r\n+\r\n         res.status(200).json({ message: 'Parcela atualizada com sucesso!', parcel: parcelToUpdate });\r\n     } catch (error) {\r\n+        console.error(\"Erro ao atualizar parcela:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// ================================================================\r\n-// Rota para EXCLUIR uma parcela específica (Delete)\r\n-// ================================================================\r\n-router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n+// <<< ROTA ADICIONADA DE VOLTA >>>\r\n+// Rota para EXCLUIR uma PARCELA específica\r\n+router.delete('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n         const { companyId, role, username } = req.user;\r\n-        const { boletoId } = req.params;\r\n+        const { boletoId, parcelId } = req.params;\r\n+\r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        const userOwner = company.usuarios.find(user => user.boletos.some(boleto => boleto.id === boletoId));\r\n+        const userOwner = company.usuarios.find(user => user.boletos.some(b => b.id === boletoId));\r\n         if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        \r\n+        const boleto = userOwner.boletos.find(b => b.id === boletoId);\r\n+        const parcelIndex = boleto.parcels.findIndex(p => p.id === parcelId);\r\n \r\n-        const boletoToDelete = userOwner.boletos.find(b => b.id === boletoId);\r\n+        if (parcelIndex === -1) {\r\n+            return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n+        }\r\n \r\n-        // <<< NOVA LÓGICA DE VERIFICAÇÃO DE PERMISSÃO >>>\r\n         const permissionLevel = company.permissions[role]?.canDelete;\r\n-        const isOwner = boletoToDelete.ownerUsername === username;\r\n+        const isOwner = boleto.ownerUsername === username;\r\n \r\n         if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n-                return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n             }\r\n         }\r\n-        // <<< FIM DA VERIFICAÇÃO >>>\r\n \r\n-        userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n-        \r\n+        // Remove a parcela do array\r\n+        boleto.parcels.splice(parcelIndex, 1);\r\n+\r\n+        company.markModified('usuarios');\r\n         await company.save();\r\n-        res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n+        res.status(200).json({ message: 'Parcela excluída com sucesso!' });\r\n     } catch (error) {\r\n+        console.error(\"Erro ao excluir parcela:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// ================================================================\r\n+\r\n // Rota para EXCLUIR um BOLETO INTEIRO\r\n-// ================================================================\r\n router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, id: loggedInUserId } = req.user;\r\n+        const { companyId, role, username } = req.user;\r\n         const { boletoId } = req.params;\r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n         const userOwner = company.usuarios.find(user => user.boletos.some(boleto => boleto.id === boletoId));\r\n         if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n \r\n-        // <<< LÓGICA DE PERMISSÃO CORRIGIDA >>>\r\n+        const boletoToDelete = userOwner.boletos.find(b => b.id === boletoId);\r\n         const permissionLevel = company.permissions[role]?.canDelete;\r\n-        const isOwner = userOwner._id.toString() === loggedInUserId; // <<< MUDANÇA: Comparando IDs\r\n+        const isOwner = boletoToDelete.ownerUsername === username;\r\n \r\n-        if (role !== 'Proprietário' && role !== 'Gerente') { // Gerente com 'all' pode excluir\r\n+        if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n             }\r\n         }\r\n-        // <<< FIM DA VERIFICAÇÃO >>>\r\n \r\n         userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n         \r\n         await company.save();\r\n         res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n     } catch (error) {\r\n+        console.error(\"Erro ao excluir o boleto completo:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n"
                },
                {
                    "date": 1752252919974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,13 +3,13 @@\n const Company = require('../models/Company');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const { logAction } = require('../middleware/logMiddleware');\r\n \r\n-// Rota para CRIAR um novo boleto (Não muda)\r\n+// Rota para CRIAR um novo boleto\r\n router.post('/', protect, logAction, async (req, res) => {\r\n     try {\r\n         const { name, parcels } = req.body;\r\n-        const { companyId, id: userId, username } = req.user;\r\n+        const { companyId, id: userId } = req.user; // Usando o ID do usuário\r\n \r\n         if (!name || !parcels || parcels.length === 0) {\r\n             return res.status(400).json({ message: 'Dados do boleto ou das parcelas estão faltando.' });\r\n         }\r\n@@ -19,26 +19,27 @@\n \r\n         const user = company.usuarios.id(userId);\r\n         if (!user) return res.status(404).json({ message: \"Usuário não encontrado na empresa.\" });\r\n         \r\n+        // Adiciona o ID do dono em cada boleto\r\n         const newBoleto = {\r\n             id: `boleto-${Date.now()}`,\r\n             parentId: `boleto-${Date.now()}`,\r\n             name,\r\n+            ownerId: user._id, // <<< MUDANÇA IMPORTANTE: Armazenando o ID do dono\r\n             ownerUsername: user.username,\r\n             parcels: parcels\r\n         };\r\n \r\n         user.boletos.push(newBoleto);\r\n         await company.save();\r\n         res.status(201).json({ message: 'Boleto criado com sucesso!', boleto: newBoleto });\r\n     } catch (error) {\r\n-        console.error(\"Erro ao criar boleto:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// Rota para LER os boletos da empresa (Não muda)\r\n+// Rota para LER os boletos da empresa\r\n router.get('/', protect, async (req, res) => {\r\n     try {\r\n         const { companyId } = req.user;\r\n         const company = await Company.findById(companyId);\r\n@@ -46,17 +47,16 @@\n         \r\n         const allCompanyBoletos = company.usuarios.flatMap(user => user.boletos);\r\n         res.status(200).json(allCompanyBoletos);\r\n     } catch (error) {\r\n-        console.error(\"Erro ao buscar boletos da empresa:\", error);\r\n         res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n     }\r\n });\r\n \r\n // Rota para ATUALIZAR uma parcela específica\r\n router.patch('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, username } = req.user;\r\n+        const { companyId, role, id: loggedInUserId } = req.user; // Pegando o ID do usuário logado\r\n         const { boletoId, parcelId } = req.params;\r\n         const { paid, amount, dueDate, description, barcode } = req.body;\r\n \r\n         const company = await Company.findById(companyId);\r\n@@ -71,10 +71,11 @@\n             }\r\n         }\r\n         if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n \r\n+        // <<< LÓGICA DE PERMISSÃO CORRIGIDA >>>\r\n         const permissionLevel = company.permissions[role]?.canUpdate;\r\n-        const isOwner = boletoToUpdate.ownerUsername === username;\r\n+        const isOwner = boletoToUpdate.ownerId.toString() === loggedInUserId; // Comparando IDs\r\n \r\n         if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n@@ -91,18 +92,16 @@\n         await company.save();\r\n \r\n         res.status(200).json({ message: 'Parcela atualizada com sucesso!', parcel: parcelToUpdate });\r\n     } catch (error) {\r\n-        console.error(\"Erro ao atualizar parcela:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// <<< ROTA ADICIONADA DE VOLTA >>>\r\n // Rota para EXCLUIR uma PARCELA específica\r\n router.delete('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, username } = req.user;\r\n+        const { companyId, role, id: loggedInUserId } = req.user; // Pegando o ID\r\n         const { boletoId, parcelId } = req.params;\r\n \r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n@@ -112,61 +111,56 @@\n         \r\n         const boleto = userOwner.boletos.find(b => b.id === boletoId);\r\n         const parcelIndex = boleto.parcels.findIndex(p => p.id === parcelId);\r\n \r\n-        if (parcelIndex === -1) {\r\n-            return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n-        }\r\n+        if (parcelIndex === -1) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n \r\n+        // <<< LÓGICA DE PERMISSÃO CORRIGIDA >>>\r\n         const permissionLevel = company.permissions[role]?.canDelete;\r\n-        const isOwner = boleto.ownerUsername === username;\r\n+        const isOwner = boleto.ownerId.toString() === loggedInUserId; // Comparando IDs\r\n \r\n         if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n             }\r\n         }\r\n \r\n-        // Remove a parcela do array\r\n         boleto.parcels.splice(parcelIndex, 1);\r\n-\r\n         company.markModified('usuarios');\r\n         await company.save();\r\n         res.status(200).json({ message: 'Parcela excluída com sucesso!' });\r\n     } catch (error) {\r\n-        console.error(\"Erro ao excluir parcela:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-\r\n // Rota para EXCLUIR um BOLETO INTEIRO\r\n router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, username } = req.user;\r\n+        const { companyId, role, id: loggedInUserId } = req.user; // Pegando o ID\r\n         const { boletoId } = req.params;\r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        const userOwner = company.usuarios.find(user => user.boletos.some(boleto => boleto.id === boletoId));\r\n+        const userOwner = company.usuarios.find(user => user.boletos.some(b => b.id === boletoId));\r\n         if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n \r\n         const boletoToDelete = userOwner.boletos.find(b => b.id === boletoId);\r\n+        \r\n+        // <<< LÓGICA DE PERMISSÃO CORRIGIDA >>>\r\n         const permissionLevel = company.permissions[role]?.canDelete;\r\n-        const isOwner = boletoToDelete.ownerUsername === username;\r\n+        const isOwner = boletoToDelete.ownerId.toString() === loggedInUserId; // Comparando IDs\r\n \r\n         if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n             }\r\n         }\r\n \r\n         userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n-        \r\n         await company.save();\r\n         res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n     } catch (error) {\r\n-        console.error(\"Erro ao excluir o boleto completo:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n"
                },
                {
                    "date": 1752252963310,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,13 +3,13 @@\n const Company = require('../models/Company');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const { logAction } = require('../middleware/logMiddleware');\r\n \r\n-// Rota para CRIAR um novo boleto\r\n+// Rota para CRIAR um novo boleto (Não muda)\r\n router.post('/', protect, logAction, async (req, res) => {\r\n     try {\r\n         const { name, parcels } = req.body;\r\n-        const { companyId, id: userId } = req.user; // Usando o ID do usuário\r\n+        const { companyId, id: userId, username } = req.user;\r\n \r\n         if (!name || !parcels || parcels.length === 0) {\r\n             return res.status(400).json({ message: 'Dados do boleto ou das parcelas estão faltando.' });\r\n         }\r\n@@ -19,27 +19,26 @@\n \r\n         const user = company.usuarios.id(userId);\r\n         if (!user) return res.status(404).json({ message: \"Usuário não encontrado na empresa.\" });\r\n         \r\n-        // Adiciona o ID do dono em cada boleto\r\n         const newBoleto = {\r\n             id: `boleto-${Date.now()}`,\r\n             parentId: `boleto-${Date.now()}`,\r\n             name,\r\n-            ownerId: user._id, // <<< MUDANÇA IMPORTANTE: Armazenando o ID do dono\r\n             ownerUsername: user.username,\r\n             parcels: parcels\r\n         };\r\n \r\n         user.boletos.push(newBoleto);\r\n         await company.save();\r\n         res.status(201).json({ message: 'Boleto criado com sucesso!', boleto: newBoleto });\r\n     } catch (error) {\r\n+        console.error(\"Erro ao criar boleto:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// Rota para LER os boletos da empresa\r\n+// Rota para LER os boletos da empresa (Não muda)\r\n router.get('/', protect, async (req, res) => {\r\n     try {\r\n         const { companyId } = req.user;\r\n         const company = await Company.findById(companyId);\r\n@@ -47,16 +46,17 @@\n         \r\n         const allCompanyBoletos = company.usuarios.flatMap(user => user.boletos);\r\n         res.status(200).json(allCompanyBoletos);\r\n     } catch (error) {\r\n+        console.error(\"Erro ao buscar boletos da empresa:\", error);\r\n         res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n     }\r\n });\r\n \r\n // Rota para ATUALIZAR uma parcela específica\r\n router.patch('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, id: loggedInUserId } = req.user; // Pegando o ID do usuário logado\r\n+        const { companyId, role, username } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n         const { paid, amount, dueDate, description, barcode } = req.body;\r\n \r\n         const company = await Company.findById(companyId);\r\n@@ -71,11 +71,10 @@\n             }\r\n         }\r\n         if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n \r\n-        // <<< LÓGICA DE PERMISSÃO CORRIGIDA >>>\r\n         const permissionLevel = company.permissions[role]?.canUpdate;\r\n-        const isOwner = boletoToUpdate.ownerId.toString() === loggedInUserId; // Comparando IDs\r\n+        const isOwner = boletoToUpdate.ownerUsername === username;\r\n \r\n         if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n@@ -92,16 +91,18 @@\n         await company.save();\r\n \r\n         res.status(200).json({ message: 'Parcela atualizada com sucesso!', parcel: parcelToUpdate });\r\n     } catch (error) {\r\n+        console.error(\"Erro ao atualizar parcela:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+// <<< ROTA ADICIONADA DE VOLTA >>>\r\n // Rota para EXCLUIR uma PARCELA específica\r\n router.delete('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, id: loggedInUserId } = req.user; // Pegando o ID\r\n+        const { companyId, role, username } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n \r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n@@ -111,56 +112,61 @@\n         \r\n         const boleto = userOwner.boletos.find(b => b.id === boletoId);\r\n         const parcelIndex = boleto.parcels.findIndex(p => p.id === parcelId);\r\n \r\n-        if (parcelIndex === -1) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n+        if (parcelIndex === -1) {\r\n+            return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n+        }\r\n \r\n-        // <<< LÓGICA DE PERMISSÃO CORRIGIDA >>>\r\n         const permissionLevel = company.permissions[role]?.canDelete;\r\n-        const isOwner = boleto.ownerId.toString() === loggedInUserId; // Comparando IDs\r\n+        const isOwner = boleto.ownerUsername === username;\r\n \r\n         if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n             }\r\n         }\r\n \r\n+        // Remove a parcela do array\r\n         boleto.parcels.splice(parcelIndex, 1);\r\n+\r\n         company.markModified('usuarios');\r\n         await company.save();\r\n         res.status(200).json({ message: 'Parcela excluída com sucesso!' });\r\n     } catch (error) {\r\n+        console.error(\"Erro ao excluir parcela:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+\r\n // Rota para EXCLUIR um BOLETO INTEIRO\r\n router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, id: loggedInUserId } = req.user; // Pegando o ID\r\n+        const { companyId, role, username } = req.user;\r\n         const { boletoId } = req.params;\r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        const userOwner = company.usuarios.find(user => user.boletos.some(b => b.id === boletoId));\r\n+        const userOwner = company.usuarios.find(user => user.boletos.some(boleto => boleto.id === boletoId));\r\n         if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n \r\n         const boletoToDelete = userOwner.boletos.find(b => b.id === boletoId);\r\n-        \r\n-        // <<< LÓGICA DE PERMISSÃO CORRIGIDA >>>\r\n         const permissionLevel = company.permissions[role]?.canDelete;\r\n-        const isOwner = boletoToDelete.ownerId.toString() === loggedInUserId; // Comparando IDs\r\n+        const isOwner = boletoToDelete.ownerUsername === username;\r\n \r\n         if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n             }\r\n         }\r\n \r\n         userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n+        \r\n         await company.save();\r\n         res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n     } catch (error) {\r\n+        console.error(\"Erro ao excluir o boleto completo:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n"
                },
                {
                    "date": 1752254159422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,13 +3,13 @@\n const Company = require('../models/Company');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const { logAction } = require('../middleware/logMiddleware');\r\n \r\n-// Rota para CRIAR um novo boleto (Não muda)\r\n+// Rota para CRIAR um novo boleto\r\n router.post('/', protect, logAction, async (req, res) => {\r\n     try {\r\n         const { name, parcels } = req.body;\r\n-        const { companyId, id: userId, username } = req.user;\r\n+        const { companyId, id: userId } = req.user;\r\n \r\n         if (!name || !parcels || parcels.length === 0) {\r\n             return res.status(400).json({ message: 'Dados do boleto ou das parcelas estão faltando.' });\r\n         }\r\n@@ -23,8 +23,9 @@\n         const newBoleto = {\r\n             id: `boleto-${Date.now()}`,\r\n             parentId: `boleto-${Date.now()}`,\r\n             name,\r\n+            ownerId: user._id, // <<< MUDANÇA: Salvando o ID do dono\r\n             ownerUsername: user.username,\r\n             parcels: parcels\r\n         };\r\n \r\n@@ -36,9 +37,9 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// Rota para LER os boletos da empresa (Não muda)\r\n+// Rota para LER os boletos da empresa\r\n router.get('/', protect, async (req, res) => {\r\n     try {\r\n         const { companyId } = req.user;\r\n         const company = await Company.findById(companyId);\r\n@@ -54,9 +55,9 @@\n \r\n // Rota para ATUALIZAR uma parcela específica\r\n router.patch('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, username } = req.user;\r\n+        const { companyId, role, id: loggedInUserId } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n         const { paid, amount, dueDate, description, barcode } = req.body;\r\n \r\n         const company = await Company.findById(companyId);\r\n@@ -72,9 +73,9 @@\n         }\r\n         if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n \r\n         const permissionLevel = company.permissions[role]?.canUpdate;\r\n-        const isOwner = boletoToUpdate.ownerUsername === username;\r\n+        const isOwner = boletoToUpdate.ownerId.toString() === loggedInUserId; // <<< MUDANÇA: Comparando IDs\r\n \r\n         if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n@@ -96,13 +97,12 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// <<< ROTA ADICIONADA DE VOLTA >>>\r\n // Rota para EXCLUIR uma PARCELA específica\r\n router.delete('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, username } = req.user;\r\n+        const { companyId, role, id: loggedInUserId } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n \r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n@@ -117,19 +117,17 @@\n             return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n         }\r\n \r\n         const permissionLevel = company.permissions[role]?.canDelete;\r\n-        const isOwner = boleto.ownerUsername === username;\r\n+        const isOwner = boleto.ownerId.toString() === loggedInUserId; // <<< MUDANÇA: Comparando IDs\r\n \r\n         if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n             }\r\n         }\r\n \r\n-        // Remove a parcela do array\r\n         boleto.parcels.splice(parcelIndex, 1);\r\n-\r\n         company.markModified('usuarios');\r\n         await company.save();\r\n         res.status(200).json({ message: 'Parcela excluída com sucesso!' });\r\n     } catch (error) {\r\n@@ -137,23 +135,23 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-\r\n // Rota para EXCLUIR um BOLETO INTEIRO\r\n router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, username } = req.user;\r\n+        const { companyId, role, id: loggedInUserId } = req.user;\r\n         const { boletoId } = req.params;\r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n         const userOwner = company.usuarios.find(user => user.boletos.some(boleto => boleto.id === boletoId));\r\n         if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n \r\n         const boletoToDelete = userOwner.boletos.find(b => b.id === boletoId);\r\n+        \r\n         const permissionLevel = company.permissions[role]?.canDelete;\r\n-        const isOwner = boletoToDelete.ownerUsername === username;\r\n+        const isOwner = boletoToDelete.ownerId.toString() === loggedInUserId; // <<< MUDANÇA: Comparando IDs\r\n \r\n         if (role !== 'Proprietário') {\r\n             if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                 return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n"
                },
                {
                    "date": 1752268927838,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n \r\n // Rota para ATUALIZAR uma parcela específica\r\n router.patch('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, id: loggedInUserId } = req.user;\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n         const { paid, amount, dueDate, description, barcode } = req.body;\r\n \r\n         const company = await Company.findById(companyId);\r\n@@ -72,14 +72,16 @@\n             }\r\n         }\r\n         if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n \r\n-        const permissionLevel = company.permissions[role]?.canUpdate;\r\n-        const isOwner = boletoToUpdate.ownerId.toString() === loggedInUserId; // <<< MUDANÇA: Comparando IDs\r\n+        if (!impersonator) { \r\n+            const permissionLevel = company.permissions[role]?.canUpdate;\r\n+            const isOwner = boletoToUpdate.ownerId.toString() === loggedInUserId;\r\n \r\n-        if (role !== 'Proprietário') {\r\n-            if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n-                return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n+            if (role !== 'Proprietário') {\r\n+                if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n+                    return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n+                }\r\n             }\r\n         }\r\n \r\n         if (paid !== undefined) parcelToUpdate.paid = paid;\r\n@@ -100,9 +102,9 @@\n \r\n // Rota para EXCLUIR uma PARCELA específica\r\n router.delete('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, id: loggedInUserId } = req.user;\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n \r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n@@ -116,14 +118,17 @@\n         if (parcelIndex === -1) {\r\n             return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n         }\r\n \r\n-        const permissionLevel = company.permissions[role]?.canDelete;\r\n-        const isOwner = boleto.ownerId.toString() === loggedInUserId; // <<< MUDANÇA: Comparando IDs\r\n+        // Se não for um admin a representar alguém, aplicamos as regras normais\r\n+        if (!impersonator) {\r\n+            const permissionLevel = company.permissions[role]?.canDelete;\r\n+            const isOwner = boleto.ownerId.toString() === loggedInUserId;\r\n \r\n-        if (role !== 'Proprietário') {\r\n-            if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n-                return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n+            if (role !== 'Proprietário') {\r\n+                if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n+                    return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n+                }\r\n             }\r\n         }\r\n \r\n         boleto.parcels.splice(parcelIndex, 1);\r\n@@ -138,9 +143,9 @@\n \r\n // Rota para EXCLUIR um BOLETO INTEIRO\r\n router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n     try {\r\n-        const { companyId, role, id: loggedInUserId } = req.user;\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n         const { boletoId } = req.params;\r\n         const company = await Company.findById(companyId);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n@@ -148,14 +153,17 @@\n         if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n \r\n         const boletoToDelete = userOwner.boletos.find(b => b.id === boletoId);\r\n         \r\n-        const permissionLevel = company.permissions[role]?.canDelete;\r\n-        const isOwner = boletoToDelete.ownerId.toString() === loggedInUserId; // <<< MUDANÇA: Comparando IDs\r\n+        // Se não for um admin a representar alguém, aplicamos as regras normais\r\n+        if (!impersonator) {\r\n+            const permissionLevel = company.permissions[role]?.canDelete;\r\n+            const isOwner = boletoToDelete.ownerId.toString() === loggedInUserId;\r\n \r\n-        if (role !== 'Proprietário') {\r\n-            if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n-                return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n+            if (role !== 'Proprietário') {\r\n+                if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n+                    return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n+                }\r\n             }\r\n         }\r\n \r\n         userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n"
                },
                {
                    "date": 1752269789473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,37 +1,31 @@\n const express = require('express');\r\n const router = express.Router();\r\n+\r\n+// Importamos os modelos que vamos usar\r\n+const Boleto = require('../models/Boleto');\r\n const Company = require('../models/Company');\r\n const { protect } = require('../middleware/authMiddleware');\r\n-const { logAction } = require('../middleware/logMiddleware');\r\n \r\n // Rota para CRIAR um novo boleto\r\n-router.post('/', protect, logAction, async (req, res) => {\r\n+router.post('/', protect, async (req, res) => {\r\n     try {\r\n-        const { name, parcels } = req.body;\r\n-        const { companyId, id: userId } = req.user;\r\n+        const { name, parcels, description, barcode } = req.body;\r\n+        const { companyId, id: userId } = req.user; // Dados do token\r\n \r\n         if (!name || !parcels || parcels.length === 0) {\r\n             return res.status(400).json({ message: 'Dados do boleto ou das parcelas estão faltando.' });\r\n         }\r\n         \r\n-        const company = await Company.findById(companyId);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-\r\n-        const user = company.usuarios.id(userId);\r\n-        if (!user) return res.status(404).json({ message: \"Usuário não encontrado na empresa.\" });\r\n-        \r\n-        const newBoleto = {\r\n-            id: `boleto-${Date.now()}`,\r\n-            parentId: `boleto-${Date.now()}`,\r\n+        const newBoleto = await Boleto.create({\r\n             name,\r\n-            ownerId: user._id, // <<< MUDANÇA: Salvando o ID do dono\r\n-            ownerUsername: user.username,\r\n-            parcels: parcels\r\n-        };\r\n+            parcels,\r\n+            description,\r\n+            barcode,\r\n+            company: companyId,\r\n+            user: userId\r\n+        });\r\n \r\n-        user.boletos.push(newBoleto);\r\n-        await company.save();\r\n         res.status(201).json({ message: 'Boleto criado com sucesso!', boleto: newBoleto });\r\n     } catch (error) {\r\n         console.error(\"Erro ao criar boleto:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n@@ -41,139 +35,116 @@\n // Rota para LER os boletos da empresa\r\n router.get('/', protect, async (req, res) => {\r\n     try {\r\n         const { companyId } = req.user;\r\n-        const company = await Company.findById(companyId);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n         \r\n-        const allCompanyBoletos = company.usuarios.flatMap(user => user.boletos);\r\n+        const allCompanyBoletos = await Boleto.find({ company: companyId })\r\n+            .populate('user', 'username role') // Anexa o username e o role do usuário dono do boleto\r\n+            .sort({ 'parcels.dueDate': 1 }); // Ordena os resultados\r\n+\r\n         res.status(200).json(allCompanyBoletos);\r\n     } catch (error) {\r\n         console.error(\"Erro ao buscar boletos da empresa:\", error);\r\n         res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n     }\r\n });\r\n \r\n // Rota para ATUALIZAR uma parcela específica\r\n-router.patch('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n+router.patch('/:boletoId/parcels/:parcelId', protect, async (req, res) => {\r\n     try {\r\n         const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n-        const { paid, amount, dueDate, description, barcode } = req.body;\r\n+        const updateData = req.body;\r\n \r\n-        const company = await Company.findById(companyId);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n \r\n-        let boletoToUpdate, parcelToUpdate;\r\n-        for (const user of company.usuarios) {\r\n-            boletoToUpdate = user.boletos.find(b => b.id === boletoId);\r\n-            if (boletoToUpdate) {\r\n-                parcelToUpdate = boletoToUpdate.parcels.find(p => p.id === parcelId);\r\n-                if (parcelToUpdate) break;\r\n-            }\r\n-        }\r\n+        const parcelToUpdate = boleto.parcels.id(parcelId);\r\n         if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n-\r\n-        if (!impersonator) { \r\n+        \r\n+        if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n             const permissionLevel = company.permissions[role]?.canUpdate;\r\n-            const isOwner = boletoToUpdate.ownerId.toString() === loggedInUserId;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n \r\n-            if (role !== 'Proprietário') {\r\n-                if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n-                    return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n-                }\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n             }\r\n         }\r\n-\r\n-        if (paid !== undefined) parcelToUpdate.paid = paid;\r\n-        if (amount !== undefined) parcelToUpdate.amount = amount;\r\n-        if (dueDate !== undefined) parcelToUpdate.dueDate = dueDate;\r\n-        if (description !== undefined) parcelToUpdate.description = description;\r\n-        if (barcode !== undefined) parcelToUpdate.barcode = barcode;\r\n         \r\n-        company.markModified('usuarios'); \r\n-        await company.save();\r\n-\r\n-        res.status(200).json({ message: 'Parcela atualizada com sucesso!', parcel: parcelToUpdate });\r\n+        Object.assign(parcelToUpdate, updateData);\r\n+        await boleto.save();\r\n+        res.status(200).json({ message: 'Parcela atualizada com sucesso!', boleto });\r\n     } catch (error) {\r\n         console.error(\"Erro ao atualizar parcela:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n // Rota para EXCLUIR uma PARCELA específica\r\n-router.delete('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n+router.delete('/:boletoId/parcels/:parcelId', protect, async (req, res) => {\r\n     try {\r\n         const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n \r\n-        const company = await Company.findById(companyId);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n \r\n-        const userOwner = company.usuarios.find(user => user.boletos.some(b => b.id === boletoId));\r\n-        if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n-        \r\n-        const boleto = userOwner.boletos.find(b => b.id === boletoId);\r\n-        const parcelIndex = boleto.parcels.findIndex(p => p.id === parcelId);\r\n+        const parcelToDelete = boleto.parcels.id(parcelId);\r\n+        if (!parcelToDelete) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n \r\n-        if (parcelIndex === -1) {\r\n-            return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n-        }\r\n-\r\n-        // Se não for um admin a representar alguém, aplicamos as regras normais\r\n         if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n             const permissionLevel = company.permissions[role]?.canDelete;\r\n-            const isOwner = boleto.ownerId.toString() === loggedInUserId;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n \r\n-            if (role !== 'Proprietário') {\r\n-                if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n-                    return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n-                }\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n             }\r\n         }\r\n \r\n-        boleto.parcels.splice(parcelIndex, 1);\r\n-        company.markModified('usuarios');\r\n-        await company.save();\r\n+        parcelToDelete.deleteOne();\r\n+        await boleto.save();\r\n         res.status(200).json({ message: 'Parcela excluída com sucesso!' });\r\n     } catch (error) {\r\n         console.error(\"Erro ao excluir parcela:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+\r\n // Rota para EXCLUIR um BOLETO INTEIRO\r\n-router.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n+router.delete('/:boletoId', protect, async (req, res) => {\r\n     try {\r\n         const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n         const { boletoId } = req.params;\r\n-        const company = await Company.findById(companyId);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        const userOwner = company.usuarios.find(user => user.boletos.some(boleto => boleto.id === boletoId));\r\n-        if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n-\r\n-        const boletoToDelete = userOwner.boletos.find(b => b.id === boletoId);\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n         \r\n-        // Se não for um admin a representar alguém, aplicamos as regras normais\r\n         if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n             const permissionLevel = company.permissions[role]?.canDelete;\r\n-            const isOwner = boletoToDelete.ownerId.toString() === loggedInUserId;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n \r\n-            if (role !== 'Proprietário') {\r\n-                if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n-                    return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n-                }\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n             }\r\n         }\r\n \r\n-        userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n+        await Boleto.findByIdAndDelete(boletoId);\r\n         \r\n-        await company.save();\r\n         res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n     } catch (error) {\r\n         console.error(\"Erro ao excluir o boleto completo:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752343329204,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -145,6 +145,47 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+// NOVA ROTA: GET para contar boletos vencidos e obter dados para notificação\r\n+router.get('/report/overdue', protect, async (req, res) => {\r\n+    try {\r\n+        const { companyId } = req.user;\r\n \r\n+        const company = await Company.findById(companyId);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        const today = new Date();\r\n+        today.setHours(0, 0, 0, 0); // Zera a hora para comparar apenas a data\r\n+\r\n+        let overdueCount = 0;\r\n+\r\n+        // Itera por todos os usuários da empresa\r\n+        for (const user of company.usuarios) {\r\n+            // Itera por todos os boletos de cada usuário\r\n+            for (const boleto of user.boletos) {\r\n+                // Filtra as parcelas vencidas e não pagas\r\n+                const overdueParcels = boleto.parcels.filter(parcel => {\r\n+                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n+                    return !parcel.paid && dueDate < today;\r\n+                });\r\n+                overdueCount += overdueParcels.length;\r\n+            }\r\n+        }\r\n+\r\n+        // Retorna os dados necessários para o frontend\r\n+        res.status(200).json({\r\n+            overdueCount: overdueCount,\r\n+            whatsappNumber: company.telefoneWhatsapp || '', // Retorna o número do WhatsApp\r\n+            companyName: company.nomeEmpresa\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao gerar relatório de vencidos:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752343598397,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -158,27 +158,26 @@\n \r\n         const today = new Date();\r\n         today.setHours(0, 0, 0, 0); // Zera a hora para comparar apenas a data\r\n \r\n+        // MUDANÇA: Em vez de iterar por usuários, buscamos todos os boletos da empresa de uma só vez.\r\n+        const allBoletos = await Boleto.find({ company: companyId });\r\n+\r\n         let overdueCount = 0;\r\n-\r\n-        // Itera por todos os usuários da empresa\r\n-        for (const user of company.usuarios) {\r\n-            // Itera por todos os boletos de cada usuário\r\n-            for (const boleto of user.boletos) {\r\n-                // Filtra as parcelas vencidas e não pagas\r\n-                const overdueParcels = boleto.parcels.filter(parcel => {\r\n-                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n-                    return !parcel.paid && dueDate < today;\r\n-                });\r\n-                overdueCount += overdueParcels.length;\r\n-            }\r\n+        \r\n+        // Agora iteramos sobre a lista de boletos encontrada\r\n+        for (const boleto of allBoletos) {\r\n+            const overdueParcels = boleto.parcels.filter(parcel => {\r\n+                const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n+                return !parcel.paid && dueDate < today;\r\n+            });\r\n+            overdueCount += overdueParcels.length;\r\n         }\r\n \r\n-        // Retorna os dados necessários para o frontend\r\n+        // A resposta continua a mesma\r\n         res.status(200).json({\r\n             overdueCount: overdueCount,\r\n-            whatsappNumber: company.telefoneWhatsapp || '', // Retorna o número do WhatsApp\r\n+            whatsappNumber: company.telefoneWhatsapp || '',\r\n             companyName: company.nomeEmpresa\r\n         });\r\n \r\n     } catch (error) {\r\n"
                },
                {
                    "date": 1752344435341,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -145,46 +145,6 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// NOVA ROTA: GET para contar boletos vencidos e obter dados para notificação\r\n-router.get('/report/overdue', protect, async (req, res) => {\r\n-    try {\r\n-        const { companyId } = req.user;\r\n \r\n-        const company = await Company.findById(companyId);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        const today = new Date();\r\n-        today.setHours(0, 0, 0, 0); // Zera a hora para comparar apenas a data\r\n-\r\n-        // MUDANÇA: Em vez de iterar por usuários, buscamos todos os boletos da empresa de uma só vez.\r\n-        const allBoletos = await Boleto.find({ company: companyId });\r\n-\r\n-        let overdueCount = 0;\r\n-        \r\n-        // Agora iteramos sobre a lista de boletos encontrada\r\n-        for (const boleto of allBoletos) {\r\n-            const overdueParcels = boleto.parcels.filter(parcel => {\r\n-                const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n-                return !parcel.paid && dueDate < today;\r\n-            });\r\n-            overdueCount += overdueParcels.length;\r\n-        }\r\n-\r\n-        // A resposta continua a mesma\r\n-        res.status(200).json({\r\n-            overdueCount: overdueCount,\r\n-            whatsappNumber: company.telefoneWhatsapp || '',\r\n-            companyName: company.nomeEmpresa\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao gerar relatório de vencidos:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752581981649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,11 +4,12 @@\n // Importamos os modelos que vamos usar\r\n const Boleto = require('../models/Boleto');\r\n const Company = require('../models/Company');\r\n const { protect } = require('../middleware/authMiddleware');\r\n+const { checkSubscription } = require('../middleware/subscriptionMiddleware');\r\n \r\n // Rota para CRIAR um novo boleto\r\n-router.post('/', protect, async (req, res) => {\r\n+router.post('/', async (req, res) => {\r\n     try {\r\n         const { name, parcels, description, barcode } = req.body;\r\n         const { companyId, id: userId } = req.user; // Dados do token\r\n \r\n@@ -32,9 +33,9 @@\n     }\r\n });\r\n \r\n // Rota para LER os boletos da empresa\r\n-router.get('/', protect, async (req, res) => {\r\n+router.get('/', async (req, res) => {\r\n     try {\r\n         const { companyId } = req.user;\r\n         \r\n         const allCompanyBoletos = await Boleto.find({ company: companyId })\r\n@@ -48,9 +49,9 @@\n     }\r\n });\r\n \r\n // Rota para ATUALIZAR uma parcela específica\r\n-router.patch('/:boletoId/parcels/:parcelId', protect, async (req, res) => {\r\n+router.patch('/:boletoId/parcels/:parcelId', async (req, res) => {\r\n     try {\r\n         const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n         const updateData = req.body;\r\n@@ -82,9 +83,9 @@\n     }\r\n });\r\n \r\n // Rota para EXCLUIR uma PARCELA específica\r\n-router.delete('/:boletoId/parcels/:parcelId', protect, async (req, res) => {\r\n+router.delete('/:boletoId/parcels/:parcelId', async (req, res) => {\r\n     try {\r\n         const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n         const { boletoId, parcelId } = req.params;\r\n \r\n@@ -116,9 +117,9 @@\n });\r\n \r\n \r\n // Rota para EXCLUIR um BOLETO INTEIRO\r\n-router.delete('/:boletoId', protect, async (req, res) => {\r\n+router.delete('/:boletoId', async (req, res) => {\r\n     try {\r\n         const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n         const { boletoId } = req.params;\r\n \r\n"
                },
                {
                    "date": 1752582073835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,10 @@\n const Company = require('../models/Company');\r\n const { protect } = require('../middleware/authMiddleware');\r\n const { checkSubscription } = require('../middleware/subscriptionMiddleware');\r\n \r\n+router.use(protect, checkSubscription);\r\n+\r\n // Rota para CRIAR um novo boleto\r\n router.post('/', async (req, res) => {\r\n     try {\r\n         const { name, parcels, description, barcode } = req.body;\r\n"
                },
                {
                    "date": 1752694219700,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,14 +12,27 @@\n // Rota para CRIAR um novo boleto\r\n router.post('/', async (req, res) => {\r\n     try {\r\n         const { name, parcels, description, barcode } = req.body;\r\n-        const { companyId, id: userId } = req.user; // Dados do token\r\n+        // Agora também extraímos o 'role' do token do utilizador\r\n+        const { companyId, id: userId, role } = req.user; \r\n \r\n         if (!name || !parcels || parcels.length === 0) {\r\n             return res.status(400).json({ message: 'Dados do boleto ou das parcelas estão faltando.' });\r\n         }\r\n-        \r\n+\r\n+        // Proprietários podem sempre criar. Para outros cargos, verificamos.\r\n+        if (role !== 'Proprietário') {\r\n+            const company = await Company.findById(companyId).select('permissions');\r\n+            const canCreate = company.permissions[role]?.canCreate;\r\n+\r\n+            // Se a permissão 'canCreate' for false, bloqueamos a ação.\r\n+            if (!canCreate) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para criar novos boletos.' });\r\n+            }\r\n+        }\r\n+\r\n+        // Se a verificação passar, o resto do código é executado normalmente.\r\n         const newBoleto = await Boleto.create({\r\n             name,\r\n             parcels,\r\n             description,\r\n"
                },
                {
                    "date": 1752774032123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,8 +33,9 @@\n \r\n         // Se a verificação passar, o resto do código é executado normalmente.\r\n         const newBoleto = await Boleto.create({\r\n             name,\r\n+            nfeNumber,\r\n             parcels,\r\n             description,\r\n             barcode,\r\n             company: companyId,\r\n"
                },
                {
                    "date": 1752774069312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \r\n // Rota para CRIAR um novo boleto\r\n router.post('/', async (req, res) => {\r\n     try {\r\n-        const { name, parcels, description, barcode } = req.body;\r\n+        const { name, parcels, description, barcode, nfeNumber } = req.body;\r\n         // Agora também extraímos o 'role' do token do utilizador\r\n         const { companyId, id: userId, role } = req.user; \r\n \r\n         if (!name || !parcels || parcels.length === 0) {\r\n"
                },
                {
                    "date": 1752792829505,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,194 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+\r\n+// Importamos os modelos que vamos usar\r\n+const Boleto = require('../models/Boleto');\r\n+const Company = require('../models/Company');\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const { checkSubscription } = require('../middleware/subscriptionMiddleware');\r\n+const upload = require('../services/uploadService');\r\n+\r\n+router.use(protect, checkSubscription);\r\n+\r\n+// Rota para CRIAR um novo boleto\r\n+router.post('/', async (req, res) => {\r\n+    try {\r\n+        const { name, parcels, description, barcode, nfeNumber } = req.body;\r\n+        // Agora também extraímos o 'role' do token do utilizador\r\n+        const { companyId, id: userId, role } = req.user; \r\n+\r\n+        if (!name || !parcels || parcels.length === 0) {\r\n+            return res.status(400).json({ message: 'Dados do boleto ou das parcelas estão faltando.' });\r\n+        }\r\n+\r\n+        // Proprietários podem sempre criar. Para outros cargos, verificamos.\r\n+        if (role !== 'Proprietário') {\r\n+            const company = await Company.findById(companyId).select('permissions');\r\n+            const canCreate = company.permissions[role]?.canCreate;\r\n+\r\n+            // Se a permissão 'canCreate' for false, bloqueamos a ação.\r\n+            if (!canCreate) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para criar novos boletos.' });\r\n+            }\r\n+        }\r\n+\r\n+        // Se a verificação passar, o resto do código é executado normalmente.\r\n+        const newBoleto = await Boleto.create({\r\n+            name,\r\n+            nfeNumber,\r\n+            parcels,\r\n+            description,\r\n+            barcode,\r\n+            company: companyId,\r\n+            user: userId\r\n+        });\r\n+\r\n+        res.status(201).json({ message: 'Boleto criado com sucesso!', boleto: newBoleto });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar boleto:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os boletos da empresa\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const { companyId } = req.user;\r\n+        \r\n+        const allCompanyBoletos = await Boleto.find({ company: companyId })\r\n+            .populate('user', 'username role') // Anexa o username e o role do usuário dono do boleto\r\n+            .sort({ 'parcels.dueDate': 1 }); // Ordena os resultados\r\n+\r\n+        res.status(200).json(allCompanyBoletos);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar boletos da empresa:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR uma parcela específica\r\n+router.patch('/:boletoId/parcels/:parcelId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n+        const { boletoId, parcelId } = req.params;\r\n+        const updateData = req.body;\r\n+\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n+\r\n+        const parcelToUpdate = boleto.parcels.id(parcelId);\r\n+        if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n+        \r\n+        if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n+            const permissionLevel = company.permissions[role]?.canUpdate;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n+\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n+            }\r\n+        }\r\n+        \r\n+        Object.assign(parcelToUpdate, updateData);\r\n+        await boleto.save();\r\n+        res.status(200).json({ message: 'Parcela atualizada com sucesso!', boleto });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar parcela:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma PARCELA específica\r\n+router.delete('/:boletoId/parcels/:parcelId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n+        const { boletoId, parcelId } = req.params;\r\n+\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n+\r\n+        const parcelToDelete = boleto.parcels.id(parcelId);\r\n+        if (!parcelToDelete) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n+\r\n+        if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n+            const permissionLevel = company.permissions[role]?.canDelete;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n+\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n+            }\r\n+        }\r\n+\r\n+        parcelToDelete.deleteOne();\r\n+        await boleto.save();\r\n+        res.status(200).json({ message: 'Parcela excluída com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir parcela:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para EXCLUIR um BOLETO INTEIRO\r\n+router.delete('/:boletoId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n+        const { boletoId } = req.params;\r\n+\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n+        \r\n+        if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n+            const permissionLevel = company.permissions[role]?.canDelete;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n+\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n+            }\r\n+        }\r\n+\r\n+        await Boleto.findByIdAndDelete(boletoId);\r\n+        \r\n+        res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir o boleto completo:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para fazer o UPLOAD de um anexo para uma parcela\r\n+router.post('/:boletoId/parcels/:parcelId/attach', protect, upload.single('comprovante'), async (req, res) => {\r\n+    try {\r\n+        const { boletoId, parcelId } = req.params;\r\n+\r\n+        if (!req.file) {\r\n+            return res.status(400).json({ message: 'Nenhum ficheiro foi enviado.' });\r\n+        }\r\n+\r\n+        // O multer-s3 disponibiliza a localização do ficheiro no S3 aqui\r\n+        const attachmentUrl = req.file.location;\r\n+\r\n+        // Atualiza a parcela específica na base de dados com o novo URL\r\n+        await Boleto.updateOne(\r\n+            { \"_id\": boletoId, \"parcels._id\": parcelId },\r\n+            { \"$set\": { \"parcels.$.attachmentUrl\": attachmentUrl } }\r\n+        );\r\n+\r\n+        res.status(200).json({ message: 'Comprovativo anexado com sucesso!', attachmentUrl });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao anexar comprovativo:\", error);\r\n+        res.status(500).json({ message: 'Erro interno ao anexar o ficheiro.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752794300824,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,199 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+\r\n+// Importamos os modelos que vamos usar\r\n+const Boleto = require('../models/Boleto');\r\n+const Company = require('../models/Company');\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const { checkSubscription } = require('../middleware/subscriptionMiddleware');\r\n+const upload = require('../services/uploadService');\r\n+\r\n+router.use(protect, checkSubscription);\r\n+\r\n+// Rota para CRIAR um novo boleto\r\n+router.post('/', async (req, res) => {\r\n+    try {\r\n+        const { name, parcels, description, barcode, nfeNumber } = req.body;\r\n+        // Agora também extraímos o 'role' do token do utilizador\r\n+        const { companyId, id: userId, role } = req.user; \r\n+\r\n+        if (!name || !parcels || parcels.length === 0) {\r\n+            return res.status(400).json({ message: 'Dados do boleto ou das parcelas estão faltando.' });\r\n+        }\r\n+\r\n+        // Proprietários podem sempre criar. Para outros cargos, verificamos.\r\n+        if (role !== 'Proprietário') {\r\n+            const company = await Company.findById(companyId).select('permissions');\r\n+            const canCreate = company.permissions[role]?.canCreate;\r\n+\r\n+            // Se a permissão 'canCreate' for false, bloqueamos a ação.\r\n+            if (!canCreate) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para criar novos boletos.' });\r\n+            }\r\n+        }\r\n+\r\n+        // Se a verificação passar, o resto do código é executado normalmente.\r\n+        const newBoleto = await Boleto.create({\r\n+            name,\r\n+            nfeNumber,\r\n+            parcels,\r\n+            description,\r\n+            barcode,\r\n+            company: companyId,\r\n+            user: userId\r\n+        });\r\n+\r\n+        res.status(201).json({ message: 'Boleto criado com sucesso!', boleto: newBoleto });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar boleto:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os boletos da empresa\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const { companyId } = req.user;\r\n+        \r\n+        const allCompanyBoletos = await Boleto.find({ company: companyId })\r\n+            .populate('user', 'username role') // Anexa o username e o role do usuário dono do boleto\r\n+            .sort({ 'parcels.dueDate': 1 }); // Ordena os resultados\r\n+\r\n+        res.status(200).json(allCompanyBoletos);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar boletos da empresa:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR uma parcela específica\r\n+router.patch('/:boletoId/parcels/:parcelId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n+        const { boletoId, parcelId } = req.params;\r\n+        const updateData = req.body;\r\n+\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n+\r\n+        const parcelToUpdate = boleto.parcels.id(parcelId);\r\n+        if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n+        \r\n+        if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n+            const permissionLevel = company.permissions[role]?.canUpdate;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n+\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n+            }\r\n+        }\r\n+        \r\n+        Object.assign(parcelToUpdate, updateData);\r\n+        await boleto.save();\r\n+        res.status(200).json({ message: 'Parcela atualizada com sucesso!', boleto });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar parcela:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma PARCELA específica\r\n+router.delete('/:boletoId/parcels/:parcelId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n+        const { boletoId, parcelId } = req.params;\r\n+\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n+\r\n+        const parcelToDelete = boleto.parcels.id(parcelId);\r\n+        if (!parcelToDelete) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n+\r\n+        if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n+            const permissionLevel = company.permissions[role]?.canDelete;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n+\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n+            }\r\n+        }\r\n+\r\n+        parcelToDelete.deleteOne();\r\n+        await boleto.save();\r\n+        res.status(200).json({ message: 'Parcela excluída com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir parcela:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para EXCLUIR um BOLETO INTEIRO\r\n+router.delete('/:boletoId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n+        const { boletoId } = req.params;\r\n+\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n+        \r\n+        if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n+            const permissionLevel = company.permissions[role]?.canDelete;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n+\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n+            }\r\n+        }\r\n+\r\n+        await Boleto.findByIdAndDelete(boletoId);\r\n+        \r\n+        res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir o boleto completo:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para fazer o UPLOAD de um anexo para uma parcela\r\n+router.post('/:boletoId/parcels/:parcelId/attach', protect, (req, res) => {\r\n+    // Chamamos o middleware de upload dentro de uma função para capturar os seus erros\r\n+    upload.single('comprovante')(req, res, async function (err) {\r\n+        if (err) {\r\n+            console.error(\"ERRO DURANTE O UPLOAD (MULTER):\", err);\r\n+            return res.status(422).json({ message: \"Erro no upload para o S3. Verifique as credenciais da AWS.\", error: err.message });\r\n+        }\r\n+\r\n+        try {\r\n+            const { boletoId, parcelId } = req.params;\r\n+\r\n+            if (!req.file) {\r\n+                return res.status(400).json({ message: 'Nenhum ficheiro foi enviado.' });\r\n+            }\r\n+\r\n+            const attachmentUrl = req.file.location;\r\n+            await Boleto.updateOne(\r\n+                { \"_id\": boletoId, \"parcels._id\": parcelId },\r\n+                { \"$set\": { \"parcels.$.attachmentUrl\": attachmentUrl } }\r\n+            );\r\n+\r\n+            res.status(200).json({ message: 'Comprovativo anexado com sucesso!', attachmentUrl });\r\n+\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao anexar comprovativo:\", error);\r\n+            res.status(500).json({ message: 'Erro interno ao anexar o ficheiro.' });\r\n+        }\r\n+    });\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752794585216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,5 +189,15 @@\n                 { \"_id\": boletoId, \"parcels._id\": parcelId },\r\n                 { \"$set\": { \"parcels.$.attachmentUrl\": attachmentUrl } }\r\n             );\r\n \r\n-            res.status(200).json({ message: 'Compro\n\\ No newline at end of file\n+            res.status(200).json({ message: 'Comprovativo anexado com sucesso!', attachmentUrl });\r\n+\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao salvar o anexo no banco de dados:\", error);\r\n+            res.status(500).json({ message: 'Erro interno ao salvar o anexo.' });\r\n+        }\r\n+    });\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752800042518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,235 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+\r\n+// Importamos os modelos que vamos usar\r\n+const Boleto = require('../models/Boleto');\r\n+const Company = require('../models/Company');\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+const { checkSubscription } = require('../middleware/subscriptionMiddleware');\r\n+const upload = require('../services/uploadService');\r\n+const { upload, deleteFile } = require('../services/uploadService');\r\n+\r\n+router.use(protect, checkSubscription);\r\n+\r\n+// Rota para CRIAR um novo boleto\r\n+router.post('/', async (req, res) => {\r\n+    try {\r\n+        const { name, parcels, description, barcode, nfeNumber } = req.body;\r\n+        // Agora também extraímos o 'role' do token do utilizador\r\n+        const { companyId, id: userId, role } = req.user; \r\n+\r\n+        if (!name || !parcels || parcels.length === 0) {\r\n+            return res.status(400).json({ message: 'Dados do boleto ou das parcelas estão faltando.' });\r\n+        }\r\n+\r\n+        // Proprietários podem sempre criar. Para outros cargos, verificamos.\r\n+        if (role !== 'Proprietário') {\r\n+            const company = await Company.findById(companyId).select('permissions');\r\n+            const canCreate = company.permissions[role]?.canCreate;\r\n+\r\n+            // Se a permissão 'canCreate' for false, bloqueamos a ação.\r\n+            if (!canCreate) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para criar novos boletos.' });\r\n+            }\r\n+        }\r\n+\r\n+        // Se a verificação passar, o resto do código é executado normalmente.\r\n+        const newBoleto = await Boleto.create({\r\n+            name,\r\n+            nfeNumber,\r\n+            parcels,\r\n+            description,\r\n+            barcode,\r\n+            company: companyId,\r\n+            user: userId\r\n+        });\r\n+\r\n+        res.status(201).json({ message: 'Boleto criado com sucesso!', boleto: newBoleto });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar boleto:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os boletos da empresa\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const { companyId } = req.user;\r\n+        \r\n+        const allCompanyBoletos = await Boleto.find({ company: companyId })\r\n+            .populate('user', 'username role') // Anexa o username e o role do usuário dono do boleto\r\n+            .sort({ 'parcels.dueDate': 1 }); // Ordena os resultados\r\n+\r\n+        res.status(200).json(allCompanyBoletos);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar boletos da empresa:\", error);\r\n+        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR uma parcela específica\r\n+router.patch('/:boletoId/parcels/:parcelId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n+        const { boletoId, parcelId } = req.params;\r\n+        const updateData = req.body;\r\n+\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n+\r\n+        const parcelToUpdate = boleto.parcels.id(parcelId);\r\n+        if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n+        \r\n+        if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n+            const permissionLevel = company.permissions[role]?.canUpdate;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n+\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n+            }\r\n+        }\r\n+        \r\n+        Object.assign(parcelToUpdate, updateData);\r\n+        await boleto.save();\r\n+        res.status(200).json({ message: 'Parcela atualizada com sucesso!', boleto });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar parcela:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma PARCELA específica\r\n+router.delete('/:boletoId/parcels/:parcelId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n+        const { boletoId, parcelId } = req.params;\r\n+\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n+\r\n+        const parcelToDelete = boleto.parcels.id(parcelId);\r\n+        if (!parcelToDelete) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n+\r\n+        if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n+            const permissionLevel = company.permissions[role]?.canDelete;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n+\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir esta parcela.' });\r\n+            }\r\n+        }\r\n+\r\n+        parcelToDelete.deleteOne();\r\n+        await boleto.save();\r\n+        res.status(200).json({ message: 'Parcela excluída com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir parcela:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para EXCLUIR um BOLETO INTEIRO\r\n+router.delete('/:boletoId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, role, id: loggedInUserId, impersonator } = req.user;\r\n+        const { boletoId } = req.params;\r\n+\r\n+        const boleto = await Boleto.findById(boletoId);\r\n+        if (!boleto || boleto.company.toString() !== companyId) {\r\n+            return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n+        }\r\n+        \r\n+        if (!impersonator) {\r\n+            const company = await Company.findById(companyId);\r\n+            const permissionLevel = company.permissions[role]?.canDelete;\r\n+            const isOwner = boleto.user.toString() === loggedInUserId;\r\n+\r\n+            if (role !== 'Proprietário' && (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner))) {\r\n+                return res.status(403).json({ message: 'Você não tem permissão para excluir este boleto.' });\r\n+            }\r\n+        }\r\n+\r\n+        await Boleto.findByIdAndDelete(boletoId);\r\n+        \r\n+        res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir o boleto completo:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para fazer o UPLOAD de um anexo para uma parcela\r\n+router.post('/:boletoId/parcels/:parcelId/attach', protect, (req, res) => {\r\n+    // Chamamos o middleware de upload dentro de uma função para podermos capturar os seus erros\r\n+    upload.single('comprovante')(req, res, async function (err) {\r\n+        // Se o 'multer' ou o 'aws-sdk' derem um erro durante o upload, ele será capturado aqui\r\n+        if (err) {\r\n+            console.error(\"ERRO DURANTE O UPLOAD (MULTER/S3):\", err);\r\n+            // Devolvemos uma mensagem de erro clara em JSON para o frontend\r\n+            return res.status(422).json({ message: \"Erro no upload para o S3. Verifique as credenciais e permissões da AWS.\", error: err.message });\r\n+        }\r\n+\r\n+        // Se o upload correr bem, o resto do código é executado\r\n+        try {\r\n+            const { boletoId, parcelId } = req.params;\r\n+\r\n+            if (!req.file) {\r\n+                return res.status(400).json({ message: 'Nenhum ficheiro foi enviado.' });\r\n+            }\r\n+\r\n+            const attachmentUrl = req.file.location;\r\n+            \r\n+            await Boleto.updateOne(\r\n+                { \"_id\": boletoId, \"parcels._id\": parcelId },\r\n+                { \"$set\": { \"parcels.$.attachmentUrl\": attachmentUrl } }\r\n+            );\r\n+\r\n+            res.status(200).json({ message: 'Comprovativo anexado com sucesso!', attachmentUrl });\r\n+\r\n+        } catch (error) {\r\n+            console.error(\"Erro ao salvar o anexo no banco de dados:\", error);\r\n+            res.status(500).json({ message: 'Erro interno ao salvar o anexo.' });\r\n+        }\r\n+    });\r\n+});\r\n+\r\n+router.delete('/:boletoId/parcels/:parcelId/attach', protect, async (req, res) => {\r\n+    try {\r\n+        const { boletoId, parcelId } = req.params;\r\n+\r\n+        // 1. Encontra a parcela para obter o URL do anexo\r\n+        const boleto = await Boleto.findOne({ \"_id\": boletoId, \"parcels._id\": parcelId }, { 'parcels.$': 1 });\r\n+        if (!boleto || !boleto.parcels[0] || !boleto.parcels[0].attachmentUrl) {\r\n+            return res.status(404).json({ message: \"Anexo não encontrado.\" });\r\n+        }\r\n+\r\n+        const attachmentUrl = boleto.parcels[0].attachmentUrl;\r\n+        // Extrai a \"key\" (nome do ficheiro) do URL completo\r\n+        const fileKey = attachmentUrl.split('/').pop();\r\n+\r\n+        // 2. Apaga o ficheiro do S3\r\n+        await deleteFile(fileKey);\r\n+\r\n+        // 3. Remove o URL da base de dados\r\n+        await Boleto.updateOne(\r\n+            { \"_id\": boletoId, \"parcels._id\": parcelId },\r\n+            { \"$set\": { \"parcels.$.attachmentUrl\": null } }\r\n+        );\r\n+\r\n+        res.status(200).json({ message: 'Comprovativo removido com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover comprovativo:\", error);\r\n+        res.status(500).json({ message: 'Erro interno ao remover o ficheiro.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                }
            ],
            "date": 1752243404018,
            "name": "Commit-0",
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst Company = require('../models/Company');\r\nconst { protect } = require('../middleware/authMiddleware');\r\nconst { logAction } = require('../middleware/logMiddleware');\r\n\r\n// ================================================================\r\n// Rota para CRIAR um novo boleto (Create)\r\n// Por padrão, todos os usuários podem criar boletos.\r\n// ================================================================\r\nrouter.post('/', protect, logAction, async (req, res) => {\r\n    try {\r\n        const { name, parcels } = req.body;\r\n        const { companyId, id: userId } = req.user;\r\n\r\n        if (!name || !parcels || parcels.length === 0) {\r\n            return res.status(400).json({ message: 'Dados do boleto ou das parcelas estão faltando.' });\r\n        }\r\n        \r\n        const company = await Company.findById(companyId);\r\n        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n\r\n        const user = company.usuarios.id(userId);\r\n        if (!user) return res.status(404).json({ message: \"Usuário não encontrado na empresa.\" });\r\n        \r\n        const newBoleto = {\r\n            id: `boleto-${Date.now()}`,\r\n            parentId: `boleto-${Date.now()}`,\r\n            name,\r\n            ownerUsername: user.username,\r\n            parcels: parcels\r\n        };\r\n\r\n        user.boletos.push(newBoleto);\r\n        await company.save();\r\n        res.status(201).json({ message: 'Boleto criado com sucesso!', boleto: newBoleto });\r\n    } catch (error) {\r\n        console.error(\"Erro ao criar boleto:\", error);\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\n// ================================================================\r\n// Rota para LER os boletos da empresa (Read)\r\n// Todos os usuários da empresa podem ver todos os boletos.\r\n// ================================================================\r\nrouter.get('/', protect, async (req, res) => {\r\n    try {\r\n        const { companyId } = req.user;\r\n        const company = await Company.findById(companyId);\r\n        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n        \r\n        const allCompanyBoletos = company.usuarios.flatMap(user => user.boletos);\r\n        res.status(200).json(allCompanyBoletos);\r\n    } catch (error) {\r\n        console.error(\"Erro ao buscar boletos da empresa:\", error);\r\n        res.status(500).json({ message: \"Erro interno do servidor.\" });\r\n    }\r\n});\r\n\r\n// ================================================================\r\n// Rota para ATUALIZAR uma parcela específica (Update)\r\n// ================================================================\r\nrouter.patch('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n    try {\r\n        const { companyId, role, username } = req.user;\r\n        const { boletoId, parcelId } = req.params;\r\n        const company = await Company.findById(companyId);\r\n        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n\r\n        let boletoToUpdate, parcelToUpdate, userOwner;\r\n        for (const user of company.usuarios) {\r\n            boletoToUpdate = user.boletos.find(b => b.id === boletoId);\r\n            if (boletoToUpdate) {\r\n                userOwner = user;\r\n                parcelToUpdate = boletoToUpdate.parcels.find(p => p.id === parcelId);\r\n                if (parcelToUpdate) break;\r\n            }\r\n        }\r\n        if (!parcelToUpdate) return res.status(404).json({ message: \"Parcela não encontrada.\" });\r\n\r\n        // <<< NOVA LÓGICA DE VERIFICAÇÃO DE PERMISSÃO >>>\r\n        const permissionLevel = company.permissions[role]?.canUpdate;\r\n        const isOwner = boletoToUpdate.ownerUsername === username;\r\n\r\n        if (role !== 'Proprietário') {\r\n            if (permissionLevel === 'none' || (permissionLevel === 'own' && !isOwner)) {\r\n                return res.status(403).json({ message: 'Você não tem permissão para editar esta parcela.' });\r\n            }\r\n        }\r\n        // <<< FIM DA VERIFICAÇÃO >>>\r\n\r\n        const { paid, amount, dueDate, description, barcode } = req.body;\r\n        if (paid !== undefined) parcelToUpdate.paid = paid;\r\n        if (amount !== undefined) parcelToUpdate.amount = amount;\r\n        if (dueDate !== undefined) parcelToUpdate.dueDate = dueDate;\r\n        if (description !== undefined) parcelToUpdate.description = description;\r\n        if (barcode !== undefined) parcelToUpdate.barcode = barcode;\r\n        \r\n        company.markModified('usuarios');\r\n        await company.save();\r\n        res.status(200).json({ message: 'Parcela atualizada com sucesso!', parcel: parcelToUpdate });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\n// ================================================================\r\n// Rota para EXCLUIR uma parcela específica (Delete)\r\n// ================================================================\r\nrouter.delete('/:boletoId/parcels/:parcelId', protect, logAction, async (req, res) => {\r\n    try {\r\n        const { companyId, role } = req.user;\r\n        const company = await Company.findById(companyId);\r\n        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n\r\n        // <<< VERIFICAÇÃO DE PERMISSÃO ADICIONADA >>>\r\n        if (role !== 'Proprietário' && !company.permissions[role]?.canDelete) {\r\n            return res.status(403).json({ message: 'Você não tem permissão para excluir boletos.' });\r\n        }\r\n        \r\n        const { boletoId, parcelId } = req.params;\r\n        let userOwner, boletoToUpdate;\r\n        for (const user of company.usuarios) {\r\n            const foundBoleto = user.boletos.find(b => b.id === boletoId);\r\n            if (foundBoleto) { userOwner = user; boletoToUpdate = foundBoleto; break; }\r\n        }\r\n        if (!boletoToUpdate) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n\r\n        const originalParcelCount = boletoToUpdate.parcels.length;\r\n        boletoToUpdate.parcels = boletoToUpdate.parcels.filter(p => p.id !== parcelId);\r\n        \r\n        if (boletoToUpdate.parcels.length < originalParcelCount && boletoToUpdate.parcels.length === 0) {\r\n            userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n        }\r\n        \r\n        await company.save();\r\n        res.status(200).json({ message: 'Parcela excluída com sucesso!' });\r\n    } catch (error) {\r\n        console.error(\"Erro ao excluir parcela:\", error);\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\n// ================================================================\r\n// Rota para EXCLUIR um BOLETO INTEIRO\r\n// ================================================================\r\nrouter.delete('/:boletoId', protect, logAction, async (req, res) => {\r\n    try {\r\n        const { companyId, role } = req.user;\r\n        const { boletoId } = req.params;\r\n        const company = await Company.findById(companyId);\r\n        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n\r\n        // <<< VERIFICAÇÃO DE PERMISSÃO ADICIONADA >>>\r\n        if (role !== 'Proprietário' && !company.permissions[role]?.canDelete) {\r\n            return res.status(403).json({ message: 'Você não tem permissão para excluir boletos.' });\r\n        }\r\n\r\n        const userOwner = company.usuarios.find(user => user.boletos.some(boleto => boleto.id === boletoId));\r\n        if (!userOwner) return res.status(404).json({ message: \"Boleto não encontrado.\" });\r\n\r\n        userOwner.boletos = userOwner.boletos.filter(b => b.id !== boletoId);\r\n        \r\n        await company.save();\r\n        res.status(200).json({ message: 'Boleto completo excluído com sucesso!' });\r\n    } catch (error) {\r\n        console.error(\"Erro ao excluir o boleto completo:\", error);\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\nmodule.exports = router;"
        }
    ]
}