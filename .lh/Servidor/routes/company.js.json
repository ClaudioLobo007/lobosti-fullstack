{
    "sourceFile": "Servidor/routes/company.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 33,
            "patches": [
                {
                    "date": 1752269540606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752276321833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,43 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+// Rota para ATUALIZAR UMA EMPRESA (nome e/ou senha)\r\n+router.patch('/:id', protect, async (req, res) => {\r\n+    try {\r\n+        // Extraímos 'nomeEmpresa' e 'newPassword' do corpo da requisição.\r\n+        const { nomeEmpresa, newPassword } = req.body;\r\n+        \r\n+        const company = await Company.findById(req.params.id);\r\n+        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n+        let hasChanges = false;\r\n+\r\n+        // Lógica para atualizar o nome, se ele foi enviado.\r\n+        if (nomeEmpresa && nomeEmpresa.trim() !== '') {\r\n+            company.nomeEmpresa = nomeEmpresa.trim();\r\n+            hasChanges = true;\r\n+        }\r\n+\r\n+        // Lógica para atualizar a senha, se ela foi enviada.\r\n+        if (newPassword && newPassword.length > 0) {\r\n+            const salt = await bcrypt.genSalt(10);\r\n+            company.senhaEmpresa = await bcrypt.hash(newPassword, salt);\r\n+            hasChanges = true;\r\n+        }\r\n+\r\n+        if (hasChanges) {\r\n+            await company.save();\r\n+        }\r\n+\r\n+        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\" });\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n // Rota para ATUALIZAR O PAPEL (ROLE) de um usuário\r\n // MUDANÇA: Lógica muito mais simples e direta.\r\n router.patch('/:companyId/users/:userId/role', protect, async (req, res) => {\r\n     try {\r\n"
                },
                {
                    "date": 1752340383265,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,34 +90,36 @@\n \r\n // Rota para ATUALIZAR UMA EMPRESA (nome e/ou senha)\r\n router.patch('/:id', protect, async (req, res) => {\r\n     try {\r\n-        // Extraímos 'nomeEmpresa' e 'newPassword' do corpo da requisição.\r\n-        const { nomeEmpresa, newPassword } = req.body;\r\n+        // MUDANÇA: Extraímos também os campos de telefone do corpo da requisição.\r\n+        const { nomeEmpresa, newPassword, telefoneFixo, telefoneWhatsapp } = req.body;\r\n         \r\n         const company = await Company.findById(req.params.id);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        let hasChanges = false;\r\n-\r\n         // Lógica para atualizar o nome, se ele foi enviado.\r\n-        if (nomeEmpresa && nomeEmpresa.trim() !== '') {\r\n-            company.nomeEmpresa = nomeEmpresa.trim();\r\n-            hasChanges = true;\r\n+        if (nomeEmpresa) {\r\n+            company.nomeEmpresa = nomeEmpresa;\r\n         }\r\n \r\n         // Lógica para atualizar a senha, se ela foi enviada.\r\n-        if (newPassword && newPassword.length > 0) {\r\n+        if (newPassword) {\r\n             const salt = await bcrypt.genSalt(10);\r\n             company.senhaEmpresa = await bcrypt.hash(newPassword, salt);\r\n-            hasChanges = true;\r\n         }\r\n \r\n-        if (hasChanges) {\r\n-            await company.save();\r\n+        // MUDANÇA: Lógica para atualizar os telefones, se foram enviados.\r\n+        if (telefoneFixo !== undefined) {\r\n+            company.telefoneFixo = telefoneFixo;\r\n         }\r\n+        if (telefoneWhatsapp !== undefined) {\r\n+            company.telefoneWhatsapp = telefoneWhatsapp;\r\n+        }\r\n+        \r\n+        await company.save();\r\n+        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company });\r\n \r\n-        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\" });\r\n     } catch (error) {\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n"
                },
                {
                    "date": 1752340938942,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,32 +90,31 @@\n \r\n // Rota para ATUALIZAR UMA EMPRESA (nome e/ou senha)\r\n router.patch('/:id', protect, async (req, res) => {\r\n     try {\r\n-        // MUDANÇA: Extraímos também os campos de telefone do corpo da requisição.\r\n-        const { nomeEmpresa, newPassword, telefoneFixo, telefoneWhatsapp } = req.body;\r\n+        // MUDANÇA: Extraímos também o campo de e-mail.\r\n+        const { nomeEmpresa, newPassword, telefoneFixo, telefoneWhatsapp, email } = req.body;\r\n         \r\n         const company = await Company.findById(req.params.id);\r\n         if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        // Lógica para atualizar o nome, se ele foi enviado.\r\n         if (nomeEmpresa) {\r\n             company.nomeEmpresa = nomeEmpresa;\r\n         }\r\n-\r\n-        // Lógica para atualizar a senha, se ela foi enviada.\r\n         if (newPassword) {\r\n             const salt = await bcrypt.genSalt(10);\r\n             company.senhaEmpresa = await bcrypt.hash(newPassword, salt);\r\n         }\r\n-\r\n-        // MUDANÇA: Lógica para atualizar os telefones, se foram enviados.\r\n         if (telefoneFixo !== undefined) {\r\n             company.telefoneFixo = telefoneFixo;\r\n         }\r\n         if (telefoneWhatsapp !== undefined) {\r\n             company.telefoneWhatsapp = telefoneWhatsapp;\r\n         }\r\n+        // MUDANÇA: Lógica para atualizar o e-mail, se foi enviado.\r\n+        if (email !== undefined) {\r\n+            company.email = email;\r\n+        }\r\n         \r\n         await company.save();\r\n         res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company });\r\n \r\n"
                },
                {
                    "date": 1752509895974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,6 +189,58 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n+router.patch('/:id/subscription', protect, async (req, res) => {\r\n+    // 1. Verifica se quem faz a requisição é o SuperAdmin\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado. Apenas o administrador mestre pode realizar esta ação.' });\r\n+    }\r\n \r\n+    try {\r\n+        const { daysToAdd } = req.body;\r\n+        const days = parseInt(daysToAdd, 10);\r\n+\r\n+        if (!days || days <= 0) {\r\n+            return res.status(400).json({ message: 'Por favor, forneça um número de dias válido.' });\r\n+        }\r\n+\r\n+        const company = await Company.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        const today = new Date();\r\n+        // Se a data de expiração atual for no passado ou não existir, a nova assinatura começa hoje.\r\n+        // Se a assinatura ainda estiver ativa, adicionamos os dias à data de expiração existente.\r\n+        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n+            ? company.subscription.endDate\r\n+            : today;\r\n+        \r\n+        const newEndDate = new Date(currentEndDate);\r\n+        newEndDate.setDate(newEndDate.getDate() + days);\r\n+\r\n+        // Atualiza os dados da assinatura para 'ativa' e define a nova data de expiração\r\n+        company.subscription.status = 'active';\r\n+        company.subscription.endDate = newEndDate;\r\n+\r\n+        await company.save();\r\n+\r\n+        // Retorna a empresa com os dados atualizados para o frontend\r\n+        const updatedCompanyData = await Company.findById(req.params.id).select('-senhaEmpresa');\r\n+        const users = await User.find({ company: req.params.id }).select('-password');\r\n+\r\n+        res.status(200).json({ \r\n+            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n+            company: updatedCompanyData,\r\n+            users: users\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752524075509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,281 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+\r\n+// MUDANÇA: Importamos todos os nossos novos modelos\r\n+const Company = require('../models/Company');\r\n+const User = require('../models/User');\r\n+const Boleto = require('../models/Boleto');\r\n+\r\n+const { protect } = require('../middleware/authMiddleware');\r\n+\r\n+// Rota para LER TODAS as empresas (sem grandes mudanças)\r\n+router.get('/', protect, async (req, res) => {\r\n+    try {\r\n+        // ANTES: O select já era bom, mas agora não há senhas de usuário para remover aqui.\r\n+        // AGORA: A lógica permanece, mas o modelo Company é mais simples.\r\n+        const companies = await Company.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os detalhes de UMA empresa\r\n+router.get('/:id', protect, async (req, res) => {\r\n+    try {\r\n+        const company = await Company.findById(req.params.id);\r\n+        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+\r\n+        // MUDANÇA: Para ser mais útil, agora também buscamos os usuários associados a esta empresa.\r\n+        const users = await User.find({ company: req.params.id }).select('-password');\r\n+        \r\n+        res.status(200).json({ company, users });\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para CRIAR uma nova empresa\r\n+// GRANDE MUDANÇA: Agora também cria o usuário 'Proprietário'.\r\n+router.post('/register', protect, async (req, res) => {\r\n+    try {\r\n+        // MUDANÇA: A rota agora espera os dados do proprietário junto com os da empresa.\r\n+        // O frontend (painel de admin) precisará ser atualizado para enviar estes dados.\r\n+        const { nomeEmpresa, cnpj, senhaEmpresa, ownerUsername, ownerPassword } = req.body;\r\n+\r\n+        if (!nomeEmpresa || !cnpj || !senhaEmpresa || !ownerUsername || !ownerPassword) {\r\n+            return res.status(400).json({ message: 'Todos os campos são obrigatórios, incluindo os do usuário proprietário.' });\r\n+        }\r\n+        \r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        const existingCompany = await Company.findOne({ cnpj: cleanCnpj });\r\n+        if (existingCompany) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+        \r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedCompanyPassword = await bcrypt.hash(senhaEmpresa, salt);\r\n+\r\n+        // 1. Criamos a empresa\r\n+        const newCompany = new Company({\r\n+            nomeEmpresa,\r\n+            cnpj: cleanCnpj,\r\n+            senhaEmpresa: hashedCompanyPassword,\r\n+        });\r\n+        const savedCompany = await newCompany.save();\r\n+\r\n+        // 2. Criamos o usuário 'Proprietário' associado a ela\r\n+        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+        await User.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword,\r\n+            role: 'Proprietário',\r\n+            company: savedCompany._id // Ligação vital\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário cadastrados com sucesso!',\r\n+            company: { _id: savedCompany._id, nomeEmpresa: savedCompany.nomeEmpresa, cnpj: savedCompany.cnpj }\r\n+        });\r\n+    } catch (error) {\r\n+        // Se algo der errado, é uma boa prática remover a empresa que pode ter sido criada.\r\n+        if (error.code === 11000) { // Erro de duplicado no usuário\r\n+             await Company.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n+             return res.status(400).json({ message: 'Este nome de usuário para proprietário já existe.' });\r\n+        }\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR UMA EMPRESA (nome e/ou senha)\r\n+router.patch('/:id', protect, async (req, res) => {\r\n+    try {\r\n+        // MUDANÇA: Extraímos também o campo de e-mail.\r\n+        const { nomeEmpresa, newPassword, telefoneFixo, telefoneWhatsapp, email } = req.body;\r\n+        \r\n+        const company = await Company.findById(req.params.id);\r\n+        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+\r\n+        if (nomeEmpresa) {\r\n+            company.nomeEmpresa = nomeEmpresa;\r\n+        }\r\n+        if (newPassword) {\r\n+            const salt = await bcrypt.genSalt(10);\r\n+            company.senhaEmpresa = await bcrypt.hash(newPassword, salt);\r\n+        }\r\n+        if (telefoneFixo !== undefined) {\r\n+            company.telefoneFixo = telefoneFixo;\r\n+        }\r\n+        if (telefoneWhatsapp !== undefined) {\r\n+            company.telefoneWhatsapp = telefoneWhatsapp;\r\n+        }\r\n+        // MUDANÇA: Lógica para atualizar o e-mail, se foi enviado.\r\n+        if (email !== undefined) {\r\n+            company.email = email;\r\n+        }\r\n+        \r\n+        await company.save();\r\n+        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company });\r\n+\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para ATUALIZAR O PAPEL (ROLE) de um usuário\r\n+// MUDANÇA: Lógica muito mais simples e direta.\r\n+router.patch('/:companyId/users/:userId/role', protect, async (req, res) => {\r\n+    try {\r\n+        const { userId } = req.params;\r\n+        const { role } = req.body;\r\n+\r\n+        if (!['Proprietário', 'Gerente', 'Funcionário'].includes(role)) {\r\n+            return res.status(400).json({ message: 'Papel (Role) inválido.' });\r\n+        }\r\n+        \r\n+        // ANTES: Procurávamos o usuário dentro da empresa.\r\n+        // AGORA: Atualizamos o usuário diretamente na coleção 'User'.\r\n+        const updatedUser = await User.findByIdAndUpdate(userId, { role }, { new: true });\r\n+\r\n+        if (!updatedUser) return res.status(404).json({ message: \"Usuário não encontrado.\" });\r\n+\r\n+        res.status(200).json({ message: `Papel do usuário ${updatedUser.username} atualizado para ${role}!` });\r\n+\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para REMOVER um usuário de uma empresa\r\n+// MUDANÇA: Agora também remove os boletos do usuário.\r\n+router.delete('/:companyId/users/:userId', protect, async (req, res) => {\r\n+    try {\r\n+        const { userId } = req.params;\r\n+        \r\n+        // 1. Removemos todos os boletos que pertencem a este usuário.\r\n+        await Boleto.deleteMany({ user: userId });\r\n+        \r\n+        // 2. Removemos o usuário.\r\n+        const deletedUser = await User.findByIdAndDelete(userId);\r\n+\r\n+        if (!deletedUser) return res.status(404).json({ message: \"Usuário não encontrado.\" });\r\n+\r\n+        res.status(200).json({ message: 'Usuário e todos os seus boletos foram removidos com sucesso!' });\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira\r\n+// MUDANÇA: Agora faz uma \"limpeza em cascata\".\r\n+router.delete('/:id', protect, async (req, res) => {\r\n+    try {\r\n+        const companyId = req.params.id;\r\n+\r\n+        // 1. Excluímos a empresa.\r\n+        const deletedCompany = await Company.findByIdAndDelete(companyId);\r\n+        if (!deletedCompany) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        \r\n+        // 2. Excluímos todos os usuários associados a essa empresa.\r\n+        await User.deleteMany({ company: companyId });\r\n+\r\n+        // 3. Excluímos todos os boletos associados a essa empresa.\r\n+        await Boleto.deleteMany({ company: companyId });\r\n+\r\n+        res.status(200).json({ message: 'Empresa, seus usuários e boletos foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n+router.patch('/:id/subscription', protect, async (req, res) => {\r\n+    // 1. Verifica se quem faz a requisição é o SuperAdmin\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado. Apenas o administrador mestre pode realizar esta ação.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const { daysToAdd } = req.body;\r\n+        const days = parseInt(daysToAdd, 10);\r\n+\r\n+        if (!days || days <= 0) {\r\n+            return res.status(400).json({ message: 'Por favor, forneça um número de dias válido.' });\r\n+        }\r\n+\r\n+        const company = await Company.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        const today = new Date();\r\n+        // Se a data de expiração atual for no passado ou não existir, a nova assinatura começa hoje.\r\n+        // Se a assinatura ainda estiver ativa, adicionamos os dias à data de expiração existente.\r\n+        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n+            ? company.subscription.endDate\r\n+            : today;\r\n+        \r\n+        const newEndDate = new Date(currentEndDate);\r\n+        newEndDate.setDate(newEndDate.getDate() + days);\r\n+\r\n+        // Atualiza os dados da assinatura para 'ativa' e define a nova data de expiração\r\n+        company.subscription.status = 'active';\r\n+        company.subscription.endDate = newEndDate;\r\n+\r\n+        await company.save();\r\n+\r\n+        // Retorna a empresa com os dados atualizados para o frontend\r\n+        const updatedCompanyData = await Company.findById(req.params.id).select('-senhaEmpresa');\r\n+        const users = await User.find({ company: req.params.id }).select('-password');\r\n+\r\n+        res.status(200).json({ \r\n+            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n+            company: updatedCompanyData,\r\n+            users: users\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n+router.delete('/:id/subscription', protect, async (req, res) => {\r\n+    // 1. Verifica se quem faz a requisição é o SuperAdmin\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado. Apenas o administrador mestre pode realizar esta ação.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const company = await Company.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        // 2. Reseta a assinatura para o estado padrão\r\n+        company.subscription.status = 'inactive';\r\n+        company.subscription.endDate = undefined; // Remove a data de expiração\r\n+\r\n+        await company.save();\r\n+\r\n+        // 3. Retorna a empresa com os dados atualizados para o frontend\r\n+        const updatedCompanyData = await Company.findById(req.params.id).select('-senhaEmpresa');\r\n+        const users = await User.find({ company: req.params.id }).select('-password');\r\n+\r\n+        res.status(200).json({\r\n+            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida com sucesso.`,\r\n+            company: updatedCompanyData,\r\n+            users: users\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753140479137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,107 @@\n const express = require('express');\r\n const router = express.Router();\r\n const bcrypt = require('bcryptjs');\r\n \r\n+const { body, validationResult } = require('express-validator');\r\n+\r\n // MUDANÇA: Importamos todos os nossos novos modelos\r\n const Company = require('../models/Company');\r\n const User = require('../models/User');\r\n const Boleto = require('../models/Boleto');\r\n \r\n const { protect } = require('../middleware/authMiddleware');\r\n \r\n+\r\n+// =================================================================================\r\n+// ROTA PÚBLICA: CADASTRO DE NOVA EMPRESA (SELF-SERVICE)\r\n+// =================================================================================\r\n+\r\n+// NOVO: Define as regras de validação para o formulário de cadastro\r\n+const registerValidationRules = [\r\n+    // Validações da Empresa\r\n+    body('nomeEmpresa', 'O nome da empresa é obrigatório.').trim().notEmpty().escape(),\r\n+    body('cnpj', 'O CNPJ é obrigatório e deve ter 14 dígitos.').isLength({ min: 14, max: 14 }).custom(async (cnpj) => {\r\n+        const existingCompany = await Company.findOne({ cnpj });\r\n+        if (existingCompany) {\r\n+            return Promise.reject('Este CNPJ já está cadastrado.');\r\n+        }\r\n+    }),\r\n+    body('email', 'O e-mail da empresa é inválido.').isEmail().normalizeEmail().custom(async (email) => {\r\n+        const existingCompany = await Company.findOne({ email });\r\n+        if (existingCompany) {\r\n+            return Promise.reject('Este e-mail já está em uso por outra empresa.');\r\n+        }\r\n+    }),\r\n+    body('telefoneWhatsapp', 'O número de WhatsApp é obrigatório.').isLength({ min: 11, max: 11 }),\r\n+\r\n+    // Validações do Proprietário\r\n+    body('username', 'O nome de usuário do proprietário é obrigatório.').trim().notEmpty().escape(),\r\n+    body('ownerEmail', 'O e-mail do proprietário é inválido.').isEmail().normalizeEmail().custom(async (email) => {\r\n+        const existingUser = await User.findOne({ email });\r\n+        if (existingUser) {\r\n+            return Promise.reject('Este e-mail já está em uso por outro usuário.');\r\n+        }\r\n+    }),\r\n+    body('password', 'A senha do proprietário deve ter no mínimo 6 caracteres.').isLength({ min: 6 }),\r\n+];\r\n+\r\n+// Rota POST /api/companies/register\r\n+router.post('/register', registerValidationRules, async (req, res) => {\r\n+    // Verifica se houve erros de validação\r\n+    const errors = validationResult(req);\r\n+    if (!errors.isEmpty()) {\r\n+        // Pega a primeira mensagem de erro para ser mais amigável no front-end\r\n+        const firstError = errors.array({ onlyFirstError: true })[0].msg;\r\n+        return res.status(400).json({ message: firstError, errors: errors.array() });\r\n+    }\r\n+\r\n+    try {\r\n+        const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n+        \r\n+        // 1. Criptografa a senha do proprietário\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedPassword = await bcrypt.hash(password, salt);\r\n+\r\n+        // 2. Cria a nova empresa no banco de dados\r\n+        const newCompany = await Company.create({\r\n+            nomeEmpresa,\r\n+            cnpj,\r\n+            email,\r\n+            telefoneWhatsapp,\r\n+            // A senha da empresa não é mais necessária para o login do usuário,\r\n+            // mas podemos gerar uma senha padrão caso você queira usá-la para outra finalidade.\r\n+            // Por segurança, não usaremos a mesma senha do proprietário.\r\n+            senhaEmpresa: await bcrypt.hash(crypto.randomBytes(10).toString('hex'), salt) \r\n+        });\r\n+\r\n+        // 3. Cria o usuário Proprietário, associando-o à empresa recém-criada\r\n+        await User.create({\r\n+            username,\r\n+            email: ownerEmail,\r\n+            password: hashedPassword,\r\n+            role: 'Proprietário',\r\n+            company: newCompany._id // Link vital entre usuário e empresa\r\n+        });\r\n+\r\n+        res.status(201).json({ message: 'Empresa e usuário proprietário cadastrados com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no cadastro:\", error);\r\n+        // Lógica de limpeza: Se algo der errado, especialmente na criação do usuário,\r\n+        // removemos a empresa que pode ter sido criada para evitar dados órfãos.\r\n+        await Company.deleteOne({ cnpj: req.body.cnpj });\r\n+        res.status(500).json({ message: 'Ocorreu um erro interno no servidor durante o cadastro.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// =================================================================================\r\n+// ROTAS PROTEGIDAS (PARA ADMINS E USUÁRIOS LOGADOS)\r\n+// O restante do seu arquivo continua aqui...\r\n+// =================================================================================\r\n+\r\n+\r\n // Rota para LER TODAS as empresas (sem grandes mudanças)\r\n router.get('/', protect, async (req, res) => {\r\n     try {\r\n         // ANTES: O select já era bom, mas agora não há senhas de usuário para remover aqui.\r\n@@ -277,251 +369,5 @@\n     }\r\n });\r\n \r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-\r\n-// MUDANÇA: Importamos todos os nossos novos modelos\r\n-const Company = require('../models/Company');\r\n-const User = require('../models/User');\r\n-const Boleto = require('../models/Boleto');\r\n-\r\n-const { protect } = require('../middleware/authMiddleware');\r\n-\r\n-// Rota para LER TODAS as empresas (sem grandes mudanças)\r\n-router.get('/', protect, async (req, res) => {\r\n-    try {\r\n-        // ANTES: O select já era bom, mas agora não há senhas de usuário para remover aqui.\r\n-        // AGORA: A lógica permanece, mas o modelo Company é mais simples.\r\n-        const companies = await Company.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER os detalhes de UMA empresa\r\n-router.get('/:id', protect, async (req, res) => {\r\n-    try {\r\n-        const company = await Company.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-\r\n-        // MUDANÇA: Para ser mais útil, agora também buscamos os usuários associados a esta empresa.\r\n-        const users = await User.find({ company: req.params.id }).select('-password');\r\n-        \r\n-        res.status(200).json({ company, users });\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para CRIAR uma nova empresa\r\n-// GRANDE MUDANÇA: Agora também cria o usuário 'Proprietário'.\r\n-router.post('/register', protect, async (req, res) => {\r\n-    try {\r\n-        // MUDANÇA: A rota agora espera os dados do proprietário junto com os da empresa.\r\n-        // O frontend (painel de admin) precisará ser atualizado para enviar estes dados.\r\n-        const { nomeEmpresa, cnpj, senhaEmpresa, ownerUsername, ownerPassword } = req.body;\r\n-\r\n-        if (!nomeEmpresa || !cnpj || !senhaEmpresa || !ownerUsername || !ownerPassword) {\r\n-            return res.status(400).json({ message: 'Todos os campos são obrigatórios, incluindo os do usuário proprietário.' });\r\n-        }\r\n-        \r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await Company.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-        \r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedCompanyPassword = await bcrypt.hash(senhaEmpresa, salt);\r\n-\r\n-        // 1. Criamos a empresa\r\n-        const newCompany = new Company({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            senhaEmpresa: hashedCompanyPassword,\r\n-        });\r\n-        const savedCompany = await newCompany.save();\r\n-\r\n-        // 2. Criamos o usuário 'Proprietário' associado a ela\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-        await User.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n-            role: 'Proprietário',\r\n-            company: savedCompany._id // Ligação vital\r\n-        });\r\n-\r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário cadastrados com sucesso!',\r\n-            company: { _id: savedCompany._id, nomeEmpresa: savedCompany.nomeEmpresa, cnpj: savedCompany.cnpj }\r\n-        });\r\n-    } catch (error) {\r\n-        // Se algo der errado, é uma boa prática remover a empresa que pode ter sido criada.\r\n-        if (error.code === 11000) { // Erro de duplicado no usuário\r\n-             await Company.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n-             return res.status(400).json({ message: 'Este nome de usuário para proprietário já existe.' });\r\n-        }\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR UMA EMPRESA (nome e/ou senha)\r\n-router.patch('/:id', protect, async (req, res) => {\r\n-    try {\r\n-        // MUDANÇA: Extraímos também o campo de e-mail.\r\n-        const { nomeEmpresa, newPassword, telefoneFixo, telefoneWhatsapp, email } = req.body;\r\n-        \r\n-        const company = await Company.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-\r\n-        if (nomeEmpresa) {\r\n-            company.nomeEmpresa = nomeEmpresa;\r\n-        }\r\n-        if (newPassword) {\r\n-            const salt = await bcrypt.genSalt(10);\r\n-            company.senhaEmpresa = await bcrypt.hash(newPassword, salt);\r\n-        }\r\n-        if (telefoneFixo !== undefined) {\r\n-            company.telefoneFixo = telefoneFixo;\r\n-        }\r\n-        if (telefoneWhatsapp !== undefined) {\r\n-            company.telefoneWhatsapp = telefoneWhatsapp;\r\n-        }\r\n-        // MUDANÇA: Lógica para atualizar o e-mail, se foi enviado.\r\n-        if (email !== undefined) {\r\n-            company.email = email;\r\n-        }\r\n-        \r\n-        await company.save();\r\n-        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company });\r\n-\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para ATUALIZAR O PAPEL (ROLE) de um usuário\r\n-// MUDANÇA: Lógica muito mais simples e direta.\r\n-router.patch('/:companyId/users/:userId/role', protect, async (req, res) => {\r\n-    try {\r\n-        const { userId } = req.params;\r\n-        const { role } = req.body;\r\n-\r\n-        if (!['Proprietário', 'Gerente', 'Funcionário'].includes(role)) {\r\n-            return res.status(400).json({ message: 'Papel (Role) inválido.' });\r\n-        }\r\n-        \r\n-        // ANTES: Procurávamos o usuário dentro da empresa.\r\n-        // AGORA: Atualizamos o usuário diretamente na coleção 'User'.\r\n-        const updatedUser = await User.findByIdAndUpdate(userId, { role }, { new: true });\r\n-\r\n-        if (!updatedUser) return res.status(404).json({ message: \"Usuário não encontrado.\" });\r\n-\r\n-        res.status(200).json({ message: `Papel do usuário ${updatedUser.username} atualizado para ${role}!` });\r\n-\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para REMOVER um usuário de uma empresa\r\n-// MUDANÇA: Agora também remove os boletos do usuário.\r\n-router.delete('/:companyId/users/:userId', protect, async (req, res) => {\r\n-    try {\r\n-        const { userId } = req.params;\r\n-        \r\n-        // 1. Removemos todos os boletos que pertencem a este usuário.\r\n-        await Boleto.deleteMany({ user: userId });\r\n-        \r\n-        // 2. Removemos o usuário.\r\n-        const deletedUser = await User.findByIdAndDelete(userId);\r\n-\r\n-        if (!deletedUser) return res.status(404).json({ message: \"Usuário não encontrado.\" });\r\n-\r\n-        res.status(200).json({ message: 'Usuário e todos os seus boletos foram removidos com sucesso!' });\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR uma empresa inteira\r\n-// MUDANÇA: Agora faz uma \"limpeza em cascata\".\r\n-router.delete('/:id', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = req.params.id;\r\n-\r\n-        // 1. Excluímos a empresa.\r\n-        const deletedCompany = await Company.findByIdAndDelete(companyId);\r\n-        if (!deletedCompany) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        \r\n-        // 2. Excluímos todos os usuários associados a essa empresa.\r\n-        await User.deleteMany({ company: companyId });\r\n-\r\n-        // 3. Excluímos todos os boletos associados a essa empresa.\r\n-        await Boleto.deleteMany({ company: companyId });\r\n-\r\n-        res.status(200).json({ message: 'Empresa, seus usuários e boletos foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n-router.patch('/:id/subscription', protect, async (req, res) => {\r\n-    // 1. Verifica se quem faz a requisição é o SuperAdmin\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado. Apenas o administrador mestre pode realizar esta ação.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const { daysToAdd } = req.body;\r\n-        const days = parseInt(daysToAdd, 10);\r\n-\r\n-        if (!days || days <= 0) {\r\n-            return res.status(400).json({ message: 'Por favor, forneça um número de dias válido.' });\r\n-        }\r\n-\r\n-        const company = await Company.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        const today = new Date();\r\n-        // Se a data de expiração atual for no passado ou não existir, a nova assinatura começa hoje.\r\n-        // Se a assinatura ainda estiver ativa, adicionamos os dias à data de expiração existente.\r\n-        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n-            ? company.subscription.endDate\r\n-            : today;\r\n-        \r\n-        const newEndDate = new Date(currentEndDate);\r\n-        newEndDate.setDate(newEndDate.getDate() + days);\r\n-\r\n-        // Atualiza os dados da assinatura para 'ativa' e define a nova data de expiração\r\n-        company.subscription.status = 'active';\r\n-        company.subscription.endDate = newEndDate;\r\n-\r\n-        await company.save();\r\n-\r\n-        // Retorna a empresa com os dados atualizados para o frontend\r\n-        const updatedCompanyData = await Company.findById(req.params.id).select('-senhaEmpresa');\r\n-        const users = await User.find({ company: req.params.id }).select('-password');\r\n-\r\n-        res.status(200).json({ \r\n-            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n-            company: updatedCompanyData,\r\n-            users: users\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753144555256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n const express = require('express');\r\n const router = express.Router();\r\n const bcrypt = require('bcryptjs');\r\n+const crypto = require('crypto');\r\n \r\n const { body, validationResult } = require('express-validator');\r\n \r\n // MUDANÇA: Importamos todos os nossos novos modelos\r\n"
                },
                {
                    "date": 1753533329817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,374 +1,101 @@\n+// D:\\SCripts\\SiteLobos\\Servidor\\routes\\company.js\r\n+\r\n const express = require('express');\r\n const router = express.Router();\r\n const bcrypt = require('bcryptjs');\r\n-const crypto = require('crypto');\r\n-\r\n const { body, validationResult } = require('express-validator');\r\n \r\n-// MUDANÇA: Importamos todos os nossos novos modelos\r\n-const Company = require('../models/Company');\r\n-const User = require('../models/User');\r\n-const Boleto = require('../models/Boleto');\r\n+// Importamos os modelos do banco MESTRE\r\n+const MasterCompany = require('../models/MasterCompany');\r\n+const MasterUser = require('../models/MasterUser');\r\n \r\n-const { protect } = require('../middleware/authMiddleware');\r\n+// Função para obter a conexão do tenant - precisaremos dela aqui\r\n+// NOTA: Esta é uma referência à função em server.js. Em uma refatoração maior,\r\n+// moveríamos a lógica de conexão para um arquivo separado (ex: config/db.js).\r\n+// Por enquanto, esta abordagem funcionará.\r\n+const { getTenantConnection } = require('../server'); // Precisamos exportar a função do server.js\r\n \r\n \r\n-// =================================================================================\r\n-// ROTA PÚBLICA: CADASTRO DE NOVA EMPRESA (SELF-SERVICE)\r\n-// =================================================================================\r\n-\r\n-// NOVO: Define as regras de validação para o formulário de cadastro\r\n-const registerValidationRules = [\r\n-    // Validações da Empresa\r\n-    body('nomeEmpresa', 'O nome da empresa é obrigatório.').trim().notEmpty().escape(),\r\n-    body('cnpj', 'O CNPJ é obrigatório e deve ter 14 dígitos.').isLength({ min: 14, max: 14 }).custom(async (cnpj) => {\r\n-        const existingCompany = await Company.findOne({ cnpj });\r\n-        if (existingCompany) {\r\n-            return Promise.reject('Este CNPJ já está cadastrado.');\r\n-        }\r\n-    }),\r\n-    body('email', 'O e-mail da empresa é inválido.').isEmail().normalizeEmail().custom(async (email) => {\r\n-        const existingCompany = await Company.findOne({ email });\r\n-        if (existingCompany) {\r\n-            return Promise.reject('Este e-mail já está em uso por outra empresa.');\r\n-        }\r\n-    }),\r\n-    body('telefoneWhatsapp', 'O número de WhatsApp é obrigatório.').isLength({ min: 11, max: 11 }),\r\n-\r\n-    // Validações do Proprietário\r\n-    body('username', 'O nome de usuário do proprietário é obrigatório.').trim().notEmpty().escape(),\r\n-    body('ownerEmail', 'O e-mail do proprietário é inválido.').isEmail().normalizeEmail().custom(async (email) => {\r\n-        const existingUser = await User.findOne({ email });\r\n-        if (existingUser) {\r\n-            return Promise.reject('Este e-mail já está em uso por outro usuário.');\r\n-        }\r\n-    }),\r\n-    body('password', 'A senha do proprietário deve ter no mínimo 6 caracteres.').isLength({ min: 6 }),\r\n-];\r\n-\r\n-// Rota POST /api/companies/register\r\n-router.post('/register', registerValidationRules, async (req, res) => {\r\n-    // Verifica se houve erros de validação\r\n-    const errors = validationResult(req);\r\n-    if (!errors.isEmpty()) {\r\n-        // Pega a primeira mensagem de erro para ser mais amigável no front-end\r\n-        const firstError = errors.array({ onlyFirstError: true })[0].msg;\r\n-        return res.status(400).json({ message: firstError, errors: errors.array() });\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+// Esta é a rota mais complexa e importante deste arquivo.\r\n+router.post('/', async (req, res) => {\r\n+    // Verificação de segurança: Apenas o SuperAdmin pode criar empresas\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n     }\r\n \r\n     try {\r\n-        const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n-        \r\n-        // 1. Criptografa a senha do proprietário\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedPassword = await bcrypt.hash(password, salt);\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword } = req.body;\r\n+        const masterDb = req.masterDb; // Conexão com o banco Mestre\r\n \r\n-        // 2. Cria a nova empresa no banco de dados\r\n-        const newCompany = await Company.create({\r\n-            nomeEmpresa,\r\n-            cnpj,\r\n-            email,\r\n-            telefoneWhatsapp,\r\n-            // A senha da empresa não é mais necessária para o login do usuário,\r\n-            // mas podemos gerar uma senha padrão caso você queira usá-la para outra finalidade.\r\n-            // Por segurança, não usaremos a mesma senha do proprietário.\r\n-            senhaEmpresa: await bcrypt.hash(crypto.randomBytes(10).toString('hex'), salt) \r\n-        });\r\n-\r\n-        // 3. Cria o usuário Proprietário, associando-o à empresa recém-criada\r\n-        await User.create({\r\n-            username,\r\n-            email: ownerEmail,\r\n-            password: hashedPassword,\r\n-            role: 'Proprietário',\r\n-            company: newCompany._id // Link vital entre usuário e empresa\r\n-        });\r\n-\r\n-        res.status(201).json({ message: 'Empresa e usuário proprietário cadastrados com sucesso!' });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro no cadastro:\", error);\r\n-        // Lógica de limpeza: Se algo der errado, especialmente na criação do usuário,\r\n-        // removemos a empresa que pode ter sido criada para evitar dados órfãos.\r\n-        await Company.deleteOne({ cnpj: req.body.cnpj });\r\n-        res.status(500).json({ message: 'Ocorreu um erro interno no servidor durante o cadastro.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// =================================================================================\r\n-// ROTAS PROTEGIDAS (PARA ADMINS E USUÁRIOS LOGADOS)\r\n-// O restante do seu arquivo continua aqui...\r\n-// =================================================================================\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (sem grandes mudanças)\r\n-router.get('/', protect, async (req, res) => {\r\n-    try {\r\n-        // ANTES: O select já era bom, mas agora não há senhas de usuário para remover aqui.\r\n-        // AGORA: A lógica permanece, mas o modelo Company é mais simples.\r\n-        const companies = await Company.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER os detalhes de UMA empresa\r\n-router.get('/:id', protect, async (req, res) => {\r\n-    try {\r\n-        const company = await Company.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-\r\n-        // MUDANÇA: Para ser mais útil, agora também buscamos os usuários associados a esta empresa.\r\n-        const users = await User.find({ company: req.params.id }).select('-password');\r\n-        \r\n-        res.status(200).json({ company, users });\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para CRIAR uma nova empresa\r\n-// GRANDE MUDANÇA: Agora também cria o usuário 'Proprietário'.\r\n-router.post('/register', protect, async (req, res) => {\r\n-    try {\r\n-        // MUDANÇA: A rota agora espera os dados do proprietário junto com os da empresa.\r\n-        // O frontend (painel de admin) precisará ser atualizado para enviar estes dados.\r\n-        const { nomeEmpresa, cnpj, senhaEmpresa, ownerUsername, ownerPassword } = req.body;\r\n-\r\n-        if (!nomeEmpresa || !cnpj || !senhaEmpresa || !ownerUsername || !ownerPassword) {\r\n-            return res.status(400).json({ message: 'Todos os campos são obrigatórios, incluindo os do usuário proprietário.' });\r\n-        }\r\n-        \r\n+        // 1. Verifica se a empresa já existe no banco Mestre\r\n         const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await Company.findOne({ cnpj: cleanCnpj });\r\n+        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n         if (existingCompany) {\r\n             return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n         }\r\n-        \r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedCompanyPassword = await bcrypt.hash(senhaEmpresa, salt);\r\n \r\n-        // 1. Criamos a empresa\r\n-        const newCompany = new Company({\r\n+        // 2. Cria um nome único para o novo banco de dados da empresa\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+\r\n+        // 3. Cria a nova empresa na coleção 'mastercompanies' do banco Mestre\r\n+        const newMasterCompany = await MasterCompany.create({\r\n             nomeEmpresa,\r\n             cnpj: cleanCnpj,\r\n-            senhaEmpresa: hashedCompanyPassword,\r\n+            dbName: dbName,\r\n         });\r\n-        const savedCompany = await newCompany.save();\r\n \r\n-        // 2. Criamos o usuário 'Proprietário' associado a ela\r\n+        // 4. Cria o usuário 'Proprietário' na coleção 'masterusers' do banco Mestre\r\n+        const salt = await bcrypt.genSalt(10);\r\n         const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-        await User.create({\r\n+        await MasterUser.create({\r\n             username: ownerUsername,\r\n             password: hashedOwnerPassword,\r\n-            role: 'Proprietário',\r\n-            company: savedCompany._id // Ligação vital\r\n+            company: newMasterCompany._id // Link para a MasterCompany\r\n         });\r\n \r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário cadastrados com sucesso!',\r\n-            company: { _id: savedCompany._id, nomeEmpresa: savedCompany.nomeEmpresa, cnpj: savedCompany.cnpj }\r\n-        });\r\n-    } catch (error) {\r\n-        // Se algo der errado, é uma boa prática remover a empresa que pode ter sido criada.\r\n-        if (error.code === 11000) { // Erro de duplicado no usuário\r\n-             await Company.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n-             return res.status(400).json({ message: 'Este nome de usuário para proprietário já existe.' });\r\n-        }\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR UMA EMPRESA (nome e/ou senha)\r\n-router.patch('/:id', protect, async (req, res) => {\r\n-    try {\r\n-        // MUDANÇA: Extraímos também o campo de e-mail.\r\n-        const { nomeEmpresa, newPassword, telefoneFixo, telefoneWhatsapp, email } = req.body;\r\n+        // 5. Conecta-se ao novo banco de dados da empresa (que será criado automaticamente na primeira conexão)\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n         \r\n-        const company = await Company.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        // 6. Importa o modelo User e o compila usando a conexão da empresa\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n \r\n-        if (nomeEmpresa) {\r\n-            company.nomeEmpresa = nomeEmpresa;\r\n-        }\r\n-        if (newPassword) {\r\n-            const salt = await bcrypt.genSalt(10);\r\n-            company.senhaEmpresa = await bcrypt.hash(newPassword, salt);\r\n-        }\r\n-        if (telefoneFixo !== undefined) {\r\n-            company.telefoneFixo = telefoneFixo;\r\n-        }\r\n-        if (telefoneWhatsapp !== undefined) {\r\n-            company.telefoneWhatsapp = telefoneWhatsapp;\r\n-        }\r\n-        // MUDANÇA: Lógica para atualizar o e-mail, se foi enviado.\r\n-        if (email !== undefined) {\r\n-            company.email = email;\r\n-        }\r\n-        \r\n-        await company.save();\r\n-        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company });\r\n+        // 7. Cria o primeiro usuário (Proprietário) DENTRO do banco de dados da empresa\r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            // A senha e outros dados sensíveis ficam apenas no banco da empresa\r\n+            password: hashedOwnerPassword, \r\n+            role: 'Proprietário',\r\n+            email: 'email@padrao.com' // Adicione um campo de e-mail se necessário\r\n+        });\r\n \r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para ATUALIZAR O PAPEL (ROLE) de um usuário\r\n-// MUDANÇA: Lógica muito mais simples e direta.\r\n-router.patch('/:companyId/users/:userId/role', protect, async (req, res) => {\r\n-    try {\r\n-        const { userId } = req.params;\r\n-        const { role } = req.body;\r\n-\r\n-        if (!['Proprietário', 'Gerente', 'Funcionário'].includes(role)) {\r\n-            return res.status(400).json({ message: 'Papel (Role) inválido.' });\r\n-        }\r\n-        \r\n-        // ANTES: Procurávamos o usuário dentro da empresa.\r\n-        // AGORA: Atualizamos o usuário diretamente na coleção 'User'.\r\n-        const updatedUser = await User.findByIdAndUpdate(userId, { role }, { new: true });\r\n-\r\n-        if (!updatedUser) return res.status(404).json({ message: \"Usuário não encontrado.\" });\r\n-\r\n-        res.status(200).json({ message: `Papel do usuário ${updatedUser.username} atualizado para ${role}!` });\r\n-\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para REMOVER um usuário de uma empresa\r\n-// MUDANÇA: Agora também remove os boletos do usuário.\r\n-router.delete('/:companyId/users/:userId', protect, async (req, res) => {\r\n-    try {\r\n-        const { userId } = req.params;\r\n-        \r\n-        // 1. Removemos todos os boletos que pertencem a este usuário.\r\n-        await Boleto.deleteMany({ user: userId });\r\n-        \r\n-        // 2. Removemos o usuário.\r\n-        const deletedUser = await User.findByIdAndDelete(userId);\r\n-\r\n-        if (!deletedUser) return res.status(404).json({ message: \"Usuário não encontrado.\" });\r\n-\r\n-        res.status(200).json({ message: 'Usuário e todos os seus boletos foram removidos com sucesso!' });\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR uma empresa inteira\r\n-// MUDANÇA: Agora faz uma \"limpeza em cascata\".\r\n-router.delete('/:id', protect, async (req, res) => {\r\n-    try {\r\n-        const companyId = req.params.id;\r\n-\r\n-        // 1. Excluímos a empresa.\r\n-        const deletedCompany = await Company.findByIdAndDelete(companyId);\r\n-        if (!deletedCompany) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        \r\n-        // 2. Excluímos todos os usuários associados a essa empresa.\r\n-        await User.deleteMany({ company: companyId });\r\n-\r\n-        // 3. Excluímos todos os boletos associados a essa empresa.\r\n-        await Boleto.deleteMany({ company: companyId });\r\n-\r\n-        res.status(200).json({ message: 'Empresa, seus usuários e boletos foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n-router.patch('/:id/subscription', protect, async (req, res) => {\r\n-    // 1. Verifica se quem faz a requisição é o SuperAdmin\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado. Apenas o administrador mestre pode realizar esta ação.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const { daysToAdd } = req.body;\r\n-        const days = parseInt(daysToAdd, 10);\r\n-\r\n-        if (!days || days <= 0) {\r\n-            return res.status(400).json({ message: 'Por favor, forneça um número de dias válido.' });\r\n-        }\r\n-\r\n-        const company = await Company.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        const today = new Date();\r\n-        // Se a data de expiração atual for no passado ou não existir, a nova assinatura começa hoje.\r\n-        // Se a assinatura ainda estiver ativa, adicionamos os dias à data de expiração existente.\r\n-        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n-            ? company.subscription.endDate\r\n-            : today;\r\n-        \r\n-        const newEndDate = new Date(currentEndDate);\r\n-        newEndDate.setDate(newEndDate.getDate() + days);\r\n-\r\n-        // Atualiza os dados da assinatura para 'ativa' e define a nova data de expiração\r\n-        company.subscription.status = 'active';\r\n-        company.subscription.endDate = newEndDate;\r\n-\r\n-        await company.save();\r\n-\r\n-        // Retorna a empresa com os dados atualizados para o frontend\r\n-        const updatedCompanyData = await Company.findById(req.params.id).select('-senhaEmpresa');\r\n-        const users = await User.find({ company: req.params.id }).select('-password');\r\n-\r\n-        res.status(200).json({ \r\n-            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n-            company: updatedCompanyData,\r\n-            users: users\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n         });\r\n \r\n     } catch (error) {\r\n-        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+        console.error(\"Erro ao criar nova empresa:\", error);\r\n+        // Lógica de limpeza em caso de erro\r\n+        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n     }\r\n });\r\n \r\n-// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n-router.delete('/:id/subscription', protect, async (req, res) => {\r\n-    // 1. Verifica se quem faz a requisição é o SuperAdmin\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado. Apenas o administrador mestre pode realizar esta ação.' });\r\n-    }\r\n \r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n     try {\r\n-        const company = await Company.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        // 2. Reseta a assinatura para o estado padrão\r\n-        company.subscription.status = 'inactive';\r\n-        company.subscription.endDate = undefined; // Remove a data de expiração\r\n-\r\n-        await company.save();\r\n-\r\n-        // 3. Retorna a empresa com os dados atualizados para o frontend\r\n-        const updatedCompanyData = await Company.findById(req.params.id).select('-senhaEmpresa');\r\n-        const users = await User.find({ company: req.params.id }).select('-password');\r\n-\r\n-        res.status(200).json({\r\n-            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida com sucesso.`,\r\n-            company: updatedCompanyData,\r\n-            users: users\r\n-        });\r\n-\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n     } catch (error) {\r\n-        console.error(\"Erro ao remover assinatura:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n+// Outras rotas (PATCH, DELETE, etc.) precisariam ser adaptadas de forma similar,\r\n+// operando no MasterCompany para dados da empresa e usando o getTenantConnection\r\n+// para acessar os dados internos (como a lista de usuários).\r\n \r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753535765439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n // Função para obter a conexão do tenant - precisaremos dela aqui\r\n // NOTA: Esta é uma referência à função em server.js. Em uma refatoração maior,\r\n // moveríamos a lógica de conexão para um arquivo separado (ex: config/db.js).\r\n // Por enquanto, esta abordagem funcionará.\r\n-const { getTenantConnection } = require('../server'); // Precisamos exportar a função do server.js\r\n+const { getTenantConnection } = require('../config/db');\r\n \r\n \r\n // ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n // Esta é a rota mais complexa e importante deste arquivo.\r\n"
                },
                {
                    "date": 1753536610752,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,101 @@\n+// D:\\SCripts\\SiteLobos\\Servidor\\routes\\company.js\r\n+\r\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const { body, validationResult } = require('express-validator');\r\n+\r\n+// Importamos os modelos do banco MESTRE\r\n+const MasterCompany = require('../models/MasterCompany');\r\n+const MasterUser = require('../models/MasterUser');\r\n+\r\n+// Função para obter a conexão do tenant - precisaremos dela aqui\r\n+// NOTA: Esta é uma referência à função em server.js. Em uma refatoração maior,\r\n+// moveríamos a lógica de conexão para um arquivo separado (ex: config/db.js).\r\n+// Por enquanto, esta abordagem funcionará.\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+// Esta é a rota mais complexa e importante deste arquivo.\r\n+router.post('/register', async (req, res) => {\r\n+    // Verificação de segurança: Apenas o SuperAdmin pode criar empresas\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword } = req.body;\r\n+        const masterDb = req.masterDb; // Conexão com o banco Mestre\r\n+\r\n+        // 1. Verifica se a empresa já existe no banco Mestre\r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n+        if (existingCompany) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        // 2. Cria um nome único para o novo banco de dados da empresa\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+\r\n+        // 3. Cria a nova empresa na coleção 'mastercompanies' do banco Mestre\r\n+        const newMasterCompany = await MasterCompany.create({\r\n+            nomeEmpresa,\r\n+            cnpj: cleanCnpj,\r\n+            dbName: dbName,\r\n+        });\r\n+\r\n+        // 4. Cria o usuário 'Proprietário' na coleção 'masterusers' do banco Mestre\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword,\r\n+            company: newMasterCompany._id // Link para a MasterCompany\r\n+        });\r\n+\r\n+        // 5. Conecta-se ao novo banco de dados da empresa (que será criado automaticamente na primeira conexão)\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        \r\n+        // 6. Importa o modelo User e o compila usando a conexão da empresa\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        // 7. Cria o primeiro usuário (Proprietário) DENTRO do banco de dados da empresa\r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            // A senha e outros dados sensíveis ficam apenas no banco da empresa\r\n+            password: hashedOwnerPassword, \r\n+            role: 'Proprietário',\r\n+            email: 'email@padrao.com' // Adicione um campo de e-mail se necessário\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa:\", error);\r\n+        // Lógica de limpeza em caso de erro\r\n+        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Outras rotas (PATCH, DELETE, etc.) precisariam ser adaptadas de forma similar,\r\n+// operando no MasterCompany para dados da empresa e usando o getTenantConnection\r\n+// para acessar os dados internos (como a lista de usuários).\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753536807628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,155 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+\r\n+// Importamos a função de conexão do nosso arquivo de configuração\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+router.post('/register', async (req, res) => {\r\n+    // Verificação de segurança: Apenas o SuperAdmin pode criar empresas\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        // Obtemos os modelos a partir da conexão 'masterDb' fornecida pelo middleware\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n+        \r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n+        if (existingCompany) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        // Cria um nome único para o novo banco de dados da empresa\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+\r\n+        // Cria a nova empresa na coleção 'mastercompanies' do banco Mestre\r\n+        const newMasterCompany = await MasterCompany.create({\r\n+            nomeEmpresa,\r\n+            cnpj: cleanCnpj,\r\n+            dbName: dbName,\r\n+            email: email, // Salva o e-mail da empresa no registro mestre\r\n+        });\r\n+\r\n+        // Cria o usuário 'Proprietário' na coleção 'masterusers' do banco Mestre\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+        \r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword,\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        // Conecta-se ao novo banco de dados da empresa (que será criado automaticamente)\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        \r\n+        // Compila o modelo User usando a conexão da empresa\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        // Cria o primeiro usuário (Proprietário) DENTRO do banco de dados da empresa\r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword, \r\n+            role: 'Proprietário',\r\n+            email: email || 'proprietario@email.com' // Usa o e-mail fornecido ou um padrão\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa:\", error);\r\n+        // Lógica de limpeza em caso de erro\r\n+        const cleanCnpj = req.body.cnpj.replace(/\\D/g, '');\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        await MasterCompany.deleteOne({ cnpj: cleanCnpj });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao listar empresas:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n+router.patch('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n+        \r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+\r\n+        // Atualiza apenas os campos fornecidos\r\n+        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n+        if (email) company.email = email;\r\n+        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n+        \r\n+        const updatedCompany = await company.save();\r\n+        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n+router.delete('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const companyId = req.params.id;\r\n+\r\n+        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n+        const companyToDelete = await MasterCompany.findById(companyId);\r\n+        if (!companyToDelete) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+        const dbName = companyToDelete.dbName;\r\n+\r\n+        // 2. Apaga o banco de dados inteiro da empresa\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        await tenantDb.dropDatabase();\r\n+        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n+\r\n+        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n+        await MasterUser.deleteMany({ company: companyId });\r\n+\r\n+        // 4. Exclui a própria empresa do banco Mestre\r\n+        await MasterCompany.findByIdAndDelete(companyId);\r\n+        \r\n+        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753536836093,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,155 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+\r\n+// Importamos a função de conexão do nosso arquivo de configuração\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+router.post('/register', async (req, res) => {\r\n+    // Verificação de segurança: Apenas o SuperAdmin pode criar empresas\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        // Obtemos os modelos a partir da conexão 'masterDb' fornecida pelo middleware\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n+        \r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n+        if (existingCompany) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        // Cria um nome único para o novo banco de dados da empresa\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+\r\n+        // Cria a nova empresa na coleção 'mastercompanies' do banco Mestre\r\n+        const newMasterCompany = await MasterCompany.create({\r\n+            nomeEmpresa,\r\n+            cnpj: cleanCnpj,\r\n+            dbName: dbName,\r\n+            email: email, // Salva o e-mail da empresa no registro mestre\r\n+        });\r\n+\r\n+        // Cria o usuário 'Proprietário' na coleção 'masterusers' do banco Mestre\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+        \r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword,\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        // Conecta-se ao novo banco de dados da empresa (que será criado automaticamente)\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        \r\n+        // Compila o modelo User usando a conexão da empresa\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        // Cria o primeiro usuário (Proprietário) DENTRO do banco de dados da empresa\r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword, \r\n+            role: 'Proprietário',\r\n+            email: email || 'proprietario@email.com' // Usa o e-mail fornecido ou um padrão\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa:\", error);\r\n+        // Lógica de limpeza em caso de erro\r\n+        const cleanCnpj = req.body.cnpj.replace(/\\D/g, '');\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        await MasterCompany.deleteOne({ cnpj: cleanCnpj });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao listar empresas:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n+router.patch('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n+        \r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+\r\n+        // Atualiza apenas os campos fornecidos\r\n+        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n+        if (email) company.email = email;\r\n+        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n+        \r\n+        const updatedCompany = await company.save();\r\n+        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n+router.delete('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const companyId = req.params.id;\r\n+\r\n+        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n+        const companyToDelete = await MasterCompany.findById(companyId);\r\n+        if (!companyToDelete) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+        const dbName = companyToDelete.dbName;\r\n+\r\n+        // 2. Apaga o banco de dados inteiro da empresa\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        await tenantDb.dropDatabase();\r\n+        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n+\r\n+        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n+        await MasterUser.deleteMany({ company: companyId });\r\n+\r\n+        // 4. Exclui a própria empresa do banco Mestre\r\n+        await MasterCompany.findByIdAndDelete(companyId);\r\n+        \r\n+        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753538133826,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,159 +95,29 @@\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n-// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n-router.patch('/:id', async (req, res) => {\r\n+// Rota para LER os detalhes de UMA empresa e seus usuários\r\n+router.get('/:id', async (req, res) => {\r\n     try {\r\n         const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n-        \r\n+\r\n+        // 1. Busca a empresa no banco Mestre pelo ID\r\n         const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-\r\n-        // Atualiza apenas os campos fornecidos\r\n-        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n-        if (email) company.email = email;\r\n-        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n-        \r\n-        const updatedCompany = await company.save();\r\n-        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n-router.delete('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const companyId = req.params.id;\r\n-\r\n-        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n-        const companyToDelete = await MasterCompany.findById(companyId);\r\n-        if (!companyToDelete) {\r\n+        if (!company) {\r\n             return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n         }\r\n-        const dbName = companyToDelete.dbName;\r\n \r\n-        // 2. Apaga o banco de dados inteiro da empresa\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        await tenantDb.dropDatabase();\r\n-        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n-\r\n-        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n-        await MasterUser.deleteMany({ company: companyId });\r\n-\r\n-        // 4. Exclui a própria empresa do banco Mestre\r\n-        await MasterCompany.findByIdAndDelete(companyId);\r\n-        \r\n-        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao excluir empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-\r\n-// Importamos a função de conexão do nosso arquivo de configuração\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-router.post('/register', async (req, res) => {\r\n-    // Verificação de segurança: Apenas o SuperAdmin pode criar empresas\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        // Obtemos os modelos a partir da conexão 'masterDb' fornecida pelo middleware\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n-        \r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        // Cria um nome único para o novo banco de dados da empresa\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-\r\n-        // Cria a nova empresa na coleção 'mastercompanies' do banco Mestre\r\n-        const newMasterCompany = await MasterCompany.create({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            dbName: dbName,\r\n-            email: email, // Salva o e-mail da empresa no registro mestre\r\n-        });\r\n-\r\n-        // Cria o usuário 'Proprietário' na coleção 'masterusers' do banco Mestre\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-        \r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        // Conecta-se ao novo banco de dados da empresa (que será criado automaticamente)\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        \r\n-        // Compila o modelo User usando a conexão da empresa\r\n+        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n         const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const users = await TenantUser.find({}).select('-password'); // Exclui a senha do retorno\r\n \r\n-        // Cria o primeiro usuário (Proprietário) DENTRO do banco de dados da empresa\r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword, \r\n-            role: 'Proprietário',\r\n-            email: email || 'proprietario@email.com' // Usa o e-mail fornecido ou um padrão\r\n-        });\r\n+        // 3. Retorna os dados combinados da empresa e seus usuários\r\n+        res.status(200).json({ company, users });\r\n \r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n     } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa:\", error);\r\n-        // Lógica de limpeza em caso de erro\r\n-        const cleanCnpj = req.body.cnpj.replace(/\\D/g, '');\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        await MasterCompany.deleteOne({ cnpj: cleanCnpj });\r\n-        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao listar empresas:\", error);\r\n+        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n@@ -306,207 +176,5 @@\n     }\r\n });\r\n \r\n \r\n-module.exports = router;\n-// D:\\SCripts\\SiteLobos\\Servidor\\routes\\company.js\r\n-\r\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const { body, validationResult } = require('express-validator');\r\n-\r\n-// Importamos os modelos do banco MESTRE\r\n-const MasterCompany = require('../models/MasterCompany');\r\n-const MasterUser = require('../models/MasterUser');\r\n-\r\n-// Função para obter a conexão do tenant - precisaremos dela aqui\r\n-// NOTA: Esta é uma referência à função em server.js. Em uma refatoração maior,\r\n-// moveríamos a lógica de conexão para um arquivo separado (ex: config/db.js).\r\n-// Por enquanto, esta abordagem funcionará.\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-// Esta é a rota mais complexa e importante deste arquivo.\r\n-router.post('/register', async (req, res) => {\r\n-    // Verificação de segurança: Apenas o SuperAdmin pode criar empresas\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword } = req.body;\r\n-        const masterDb = req.masterDb; // Conexão com o banco Mestre\r\n-\r\n-        // 1. Verifica se a empresa já existe no banco Mestre\r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        // 2. Cria um nome único para o novo banco de dados da empresa\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-\r\n-        // 3. Cria a nova empresa na coleção 'mastercompanies' do banco Mestre\r\n-        const newMasterCompany = await MasterCompany.create({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            dbName: dbName,\r\n-        });\r\n-\r\n-        // 4. Cria o usuário 'Proprietário' na coleção 'masterusers' do banco Mestre\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n-            company: newMasterCompany._id // Link para a MasterCompany\r\n-        });\r\n-\r\n-        // 5. Conecta-se ao novo banco de dados da empresa (que será criado automaticamente na primeira conexão)\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        \r\n-        // 6. Importa o modelo User e o compila usando a conexão da empresa\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        // 7. Cria o primeiro usuário (Proprietário) DENTRO do banco de dados da empresa\r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            // A senha e outros dados sensíveis ficam apenas no banco da empresa\r\n-            password: hashedOwnerPassword, \r\n-            role: 'Proprietário',\r\n-            email: 'email@padrao.com' // Adicione um campo de e-mail se necessário\r\n-        });\r\n-\r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa:\", error);\r\n-        // Lógica de limpeza em caso de erro\r\n-        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n-        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Outras rotas (PATCH, DELETE, etc.) precisariam ser adaptadas de forma similar,\r\n-// operando no MasterCompany para dados da empresa e usando o getTenantConnection\r\n-// para acessar os dados internos (como a lista de usuários).\r\n-\r\n-module.exports = router;\n-// D:\\SCripts\\SiteLobos\\Servidor\\routes\\company.js\r\n-\r\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const { body, validationResult } = require('express-validator');\r\n-\r\n-// Importamos os modelos do banco MESTRE\r\n-const MasterCompany = require('../models/MasterCompany');\r\n-const MasterUser = require('../models/MasterUser');\r\n-\r\n-// Função para obter a conexão do tenant - precisaremos dela aqui\r\n-// NOTA: Esta é uma referência à função em server.js. Em uma refatoração maior,\r\n-// moveríamos a lógica de conexão para um arquivo separado (ex: config/db.js).\r\n-// Por enquanto, esta abordagem funcionará.\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-// Esta é a rota mais complexa e importante deste arquivo.\r\n-router.post('/', async (req, res) => {\r\n-    // Verificação de segurança: Apenas o SuperAdmin pode criar empresas\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword } = req.body;\r\n-        const masterDb = req.masterDb; // Conexão com o banco Mestre\r\n-\r\n-        // 1. Verifica se a empresa já existe no banco Mestre\r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        // 2. Cria um nome único para o novo banco de dados da empresa\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-\r\n-        // 3. Cria a nova empresa na coleção 'mastercompanies' do banco Mestre\r\n-        const newMasterCompany = await MasterCompany.create({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            dbName: dbName,\r\n-        });\r\n-\r\n-        // 4. Cria o usuário 'Proprietário' na coleção 'masterusers' do banco Mestre\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n-            company: newMasterCompany._id // Link para a MasterCompany\r\n-        });\r\n-\r\n-        // 5. Conecta-se ao novo banco de dados da empresa (que será criado automaticamente na primeira conexão)\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        \r\n-        // 6. Importa o modelo User e o compila usando a conexão da empresa\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        // 7. Cria o primeiro usuário (Proprietário) DENTRO do banco de dados da empresa\r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            // A senha e outros dados sensíveis ficam apenas no banco da empresa\r\n-            password: hashedOwnerPassword, \r\n-            role: 'Proprietário',\r\n-            email: 'email@padrao.com' // Adicione um campo de e-mail se necessário\r\n-        });\r\n-\r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa:\", error);\r\n-        // Lógica de limpeza em caso de erro\r\n-        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n-        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Outras rotas (PATCH, DELETE, etc.) precisariam ser adaptadas de forma similar,\r\n-// operando no MasterCompany para dados da empresa e usando o getTenantConnection\r\n-// para acessar os dados internos (como a lista de usuários).\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753538235061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,256 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+\r\n+// Importamos a função de conexão do nosso arquivo de configuração\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+router.post('/register', async (req, res) => {\r\n+    // Verificação de segurança: Apenas o SuperAdmin pode criar empresas\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        // Obtemos os modelos a partir da conexão 'masterDb' fornecida pelo middleware\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n+        \r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n+        if (existingCompany) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        // Cria um nome único para o novo banco de dados da empresa\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+\r\n+        // Cria a nova empresa na coleção 'mastercompanies' do banco Mestre\r\n+        const newMasterCompany = await MasterCompany.create({\r\n+            nomeEmpresa,\r\n+            cnpj: cleanCnpj,\r\n+            dbName: dbName,\r\n+            email: email, // Salva o e-mail da empresa no registro mestre\r\n+        });\r\n+\r\n+        // Cria o usuário 'Proprietário' na coleção 'masterusers' do banco Mestre\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+        \r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword,\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        // Conecta-se ao novo banco de dados da empresa (que será criado automaticamente)\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        \r\n+        // Compila o modelo User usando a conexão da empresa\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        // Cria o primeiro usuário (Proprietário) DENTRO do banco de dados da empresa\r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword, \r\n+            role: 'Proprietário',\r\n+            email: email || 'proprietario@email.com' // Usa o e-mail fornecido ou um padrão\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa:\", error);\r\n+        // Lógica de limpeza em caso de erro\r\n+        const cleanCnpj = req.body.cnpj.replace(/\\D/g, '');\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        await MasterCompany.deleteOne({ cnpj: cleanCnpj });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao listar empresas:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os detalhes de UMA empresa e seus usuários\r\n+router.get('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+\r\n+        // 1. Busca a empresa no banco Mestre pelo ID\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const users = await TenantUser.find({}).select('-password'); // Exclui a senha do retorno\r\n+\r\n+        // 3. Retorna os dados combinados da empresa e seus usuários\r\n+        res.status(200).json({ company, users });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n+router.patch('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n+        \r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+\r\n+        // Atualiza apenas os campos fornecidos\r\n+        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n+        if (email) company.email = email;\r\n+        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n+        \r\n+        const updatedCompany = await company.save();\r\n+        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n+router.delete('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const companyId = req.params.id;\r\n+\r\n+        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n+        const companyToDelete = await MasterCompany.findById(companyId);\r\n+        if (!companyToDelete) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+        const dbName = companyToDelete.dbName;\r\n+\r\n+        // 2. Apaga o banco de dados inteiro da empresa\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        await tenantDb.dropDatabase();\r\n+        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n+\r\n+        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n+        await MasterUser.deleteMany({ company: companyId });\r\n+\r\n+        // 4. Exclui a própria empresa do banco Mestre\r\n+        await MasterCompany.findByIdAndDelete(companyId);\r\n+        \r\n+        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n+router.patch('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { daysToAdd } = req.body;\r\n+        const days = parseInt(daysToAdd, 10);\r\n+\r\n+        if (!days || days <= 0) {\r\n+            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n+        }\r\n+\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        const today = new Date();\r\n+        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n+        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n+        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n+            ? company.subscription.endDate\r\n+            : today;\r\n+\r\n+        const newEndDate = new Date(currentEndDate);\r\n+        newEndDate.setDate(newEndDate.getDate() + days);\r\n+\r\n+        company.subscription.status = 'active';\r\n+        company.subscription.endDate = newEndDate;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({ \r\n+            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n+router.delete('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        // Reseta a assinatura para o estado padrão\r\n+        company.subscription.status = 'inactive';\r\n+        company.subscription.endDate = undefined;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({\r\n+            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753538571486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,23 +99,27 @@\n // Rota para LER os detalhes de UMA empresa e seus usuários\r\n router.get('/:id', async (req, res) => {\r\n     try {\r\n         const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n \r\n-        // 1. Busca a empresa no banco Mestre pelo ID\r\n+        // 1. Busca a empresa no banco Mestre\r\n         const company = await MasterCompany.findById(req.params.id);\r\n         if (!company) {\r\n             return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n         }\r\n \r\n         // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n         const tenantDb = await getTenantConnection(company.dbName);\r\n         const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const users = await TenantUser.find({}).select('-password'); // Exclui a senha do retorno\r\n+        const users = await TenantUser.find({}).select('-password');\r\n \r\n-        // 3. Retorna os dados combinados da empresa e seus usuários\r\n-        res.status(200).json({ company, users });\r\n+        // 3. NOVO: Busca também os usuários no banco Mestre\r\n+        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n \r\n+        // 4. Retorna os dados combinados\r\n+        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n+\r\n     } catch (error) {\r\n         console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n"
                },
                {
                    "date": 1753539281415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,9 @@\n         \r\n         await MasterUser.create({\r\n             username: ownerUsername,\r\n             password: hashedOwnerPassword,\r\n+            role: 'Proprietário',\r\n             company: newMasterCompany._id\r\n         });\r\n \r\n         // Conecta-se ao novo banco de dados da empresa (que será criado automaticamente)\r\n@@ -256,185 +257,5 @@\n     }\r\n });\r\n \r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-\r\n-// Importamos a função de conexão do nosso arquivo de configuração\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-router.post('/register', async (req, res) => {\r\n-    // Verificação de segurança: Apenas o SuperAdmin pode criar empresas\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        // Obtemos os modelos a partir da conexão 'masterDb' fornecida pelo middleware\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n-        \r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        // Cria um nome único para o novo banco de dados da empresa\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-\r\n-        // Cria a nova empresa na coleção 'mastercompanies' do banco Mestre\r\n-        const newMasterCompany = await MasterCompany.create({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            dbName: dbName,\r\n-            email: email, // Salva o e-mail da empresa no registro mestre\r\n-        });\r\n-\r\n-        // Cria o usuário 'Proprietário' na coleção 'masterusers' do banco Mestre\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-        \r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        // Conecta-se ao novo banco de dados da empresa (que será criado automaticamente)\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        \r\n-        // Compila o modelo User usando a conexão da empresa\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        // Cria o primeiro usuário (Proprietário) DENTRO do banco de dados da empresa\r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword, \r\n-            role: 'Proprietário',\r\n-            email: email || 'proprietario@email.com' // Usa o e-mail fornecido ou um padrão\r\n-        });\r\n-\r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa:\", error);\r\n-        // Lógica de limpeza em caso de erro\r\n-        const cleanCnpj = req.body.cnpj.replace(/\\D/g, '');\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        await MasterCompany.deleteOne({ cnpj: cleanCnpj });\r\n-        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao listar empresas:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER os detalhes de UMA empresa e seus usuários\r\n-router.get('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-\r\n-        // 1. Busca a empresa no banco Mestre pelo ID\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const users = await TenantUser.find({}).select('-password'); // Exclui a senha do retorno\r\n-\r\n-        // 3. Retorna os dados combinados da empresa e seus usuários\r\n-        res.status(200).json({ company, users });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n-router.patch('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n-        \r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-\r\n-        // Atualiza apenas os campos fornecidos\r\n-        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n-        if (email) company.email = email;\r\n-        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n-        \r\n-        const updatedCompany = await company.save();\r\n-        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n-router.delete('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const companyId = req.params.id;\r\n-\r\n-        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n-        const companyToDelete = await MasterCompany.findById(companyId);\r\n-        if (!companyToDelete) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-        const dbName = companyToDelete.dbName;\r\n-\r\n-        // 2. Apaga o banco de dados inteiro da empresa\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        await tenantDb.dropDatabase();\r\n-        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n-\r\n-        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n-        await MasterUser.deleteMany({ company: companyId });\r\n-\r\n-        // 4. Exclui a própria empresa do banco Mestre\r\n-        await MasterCompany.findByIdAndDelete(companyId);\r\n-        \r\n-        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao excluir empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753540148790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,250 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+\r\n+// Importamos a função de conexão do nosso arquivo de configuração\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+router.post('/register', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n+        \r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n+        if (existingCompany) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+\r\n+        const newMasterCompany = await MasterCompany.create({\r\n+            nomeEmpresa,\r\n+            cnpj: cleanCnpj,\r\n+            dbName: dbName,\r\n+        });\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+        \r\n+        // --- CORREÇÃO FINAL AQUI ---\r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword,\r\n+            role: 'Proprietário', // <-- ESTA LINHA ESTAVA FALTANDO\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        \r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword, \r\n+            role: 'Proprietário',\r\n+            email: email || 'proprietario@email.com'\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa:\", error);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao listar empresas:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os detalhes de UMA empresa e seus usuários\r\n+router.get('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // 1. Busca a empresa no banco Mestre\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const users = await TenantUser.find({}).select('-password');\r\n+\r\n+        // 3. NOVO: Busca também os usuários no banco Mestre\r\n+        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n+\r\n+        // 4. Retorna os dados combinados\r\n+        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n+router.patch('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n+        \r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+\r\n+        // Atualiza apenas os campos fornecidos\r\n+        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n+        if (email) company.email = email;\r\n+        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n+        \r\n+        const updatedCompany = await company.save();\r\n+        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n+router.delete('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const companyId = req.params.id;\r\n+\r\n+        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n+        const companyToDelete = await MasterCompany.findById(companyId);\r\n+        if (!companyToDelete) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+        const dbName = companyToDelete.dbName;\r\n+\r\n+        // 2. Apaga o banco de dados inteiro da empresa\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        await tenantDb.dropDatabase();\r\n+        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n+\r\n+        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n+        await MasterUser.deleteMany({ company: companyId });\r\n+\r\n+        // 4. Exclui a própria empresa do banco Mestre\r\n+        await MasterCompany.findByIdAndDelete(companyId);\r\n+        \r\n+        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n+router.patch('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { daysToAdd } = req.body;\r\n+        const days = parseInt(daysToAdd, 10);\r\n+\r\n+        if (!days || days <= 0) {\r\n+            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n+        }\r\n+\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        const today = new Date();\r\n+        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n+        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n+        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n+            ? company.subscription.endDate\r\n+            : today;\r\n+\r\n+        const newEndDate = new Date(currentEndDate);\r\n+        newEndDate.setDate(newEndDate.getDate() + days);\r\n+\r\n+        company.subscription.status = 'active';\r\n+        company.subscription.endDate = newEndDate;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({ \r\n+            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n+router.delete('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        // Reseta a assinatura para o estado padrão\r\n+        company.subscription.status = 'inactive';\r\n+        company.subscription.endDate = undefined;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({\r\n+            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753540374282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,250 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+\r\n+// Importamos a função de conexão do nosso arquivo de configuração\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+router.post('/register', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n+        \r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n+        if (existingCompany) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+\r\n+        const newMasterCompany = await MasterCompany.create({\r\n+            nomeEmpresa,\r\n+            cnpj: cleanCnpj,\r\n+            dbName: dbName,\r\n+        });\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+        \r\n+        // --- CORREÇÃO FINAL AQUI ---\r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword,\r\n+            role: 'Proprietário', // <-- ESTA LINHA ESTAVA FALTANDO\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        \r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword, \r\n+            role: 'Proprietário',\r\n+            email: email || 'proprietario@email.com'\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa:\", error);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao listar empresas:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os detalhes de UMA empresa e seus usuários\r\n+router.get('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // 1. Busca a empresa no banco Mestre\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const users = await TenantUser.find({}).select('-password');\r\n+\r\n+        // 3. NOVO: Busca também os usuários no banco Mestre\r\n+        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n+\r\n+        // 4. Retorna os dados combinados\r\n+        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n+router.patch('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n+        \r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+\r\n+        // Atualiza apenas os campos fornecidos\r\n+        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n+        if (email) company.email = email;\r\n+        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n+        \r\n+        const updatedCompany = await company.save();\r\n+        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n+router.delete('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const companyId = req.params.id;\r\n+\r\n+        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n+        const companyToDelete = await MasterCompany.findById(companyId);\r\n+        if (!companyToDelete) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+        const dbName = companyToDelete.dbName;\r\n+\r\n+        // 2. Apaga o banco de dados inteiro da empresa\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        await tenantDb.dropDatabase();\r\n+        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n+\r\n+        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n+        await MasterUser.deleteMany({ company: companyId });\r\n+\r\n+        // 4. Exclui a própria empresa do banco Mestre\r\n+        await MasterCompany.findByIdAndDelete(companyId);\r\n+        \r\n+        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n+router.patch('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { daysToAdd } = req.body;\r\n+        const days = parseInt(daysToAdd, 10);\r\n+\r\n+        if (!days || days <= 0) {\r\n+            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n+        }\r\n+\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        const today = new Date();\r\n+        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n+        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n+        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n+            ? company.subscription.endDate\r\n+            : today;\r\n+\r\n+        const newEndDate = new Date(currentEndDate);\r\n+        newEndDate.setDate(newEndDate.getDate() + days);\r\n+\r\n+        company.subscription.status = 'active';\r\n+        company.subscription.endDate = newEndDate;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({ \r\n+            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n+router.delete('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        // Reseta a assinatura para o estado padrão\r\n+        company.subscription.status = 'inactive';\r\n+        company.subscription.endDate = undefined;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({\r\n+            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753542152896,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n         const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n         const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n \r\n         const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n-        \r\n+\r\n         const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n         const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n         if (existingCompany) {\r\n             return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n@@ -38,10 +38,9 @@\n         });\r\n \r\n         const salt = await bcrypt.genSalt(10);\r\n         const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-        \r\n-        // --- CORREÇÃO FINAL AQUI ---\r\n+\r\n         await MasterUser.create({\r\n             username: ownerUsername,\r\n             password: hashedOwnerPassword,\r\n             role: 'Proprietário', // <-- ESTA LINHA ESTAVA FALTANDO\r\n@@ -49,259 +48,9 @@\n         });\r\n \r\n         const tenantDb = await getTenantConnection(dbName);\r\n         const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        \r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword, \r\n-            role: 'Proprietário',\r\n-            email: email || 'proprietario@email.com'\r\n-        });\r\n \r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa:\", error);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n-        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao listar empresas:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER os detalhes de UMA empresa e seus usuários\r\n-router.get('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // 1. Busca a empresa no banco Mestre\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const users = await TenantUser.find({}).select('-password');\r\n-\r\n-        // 3. NOVO: Busca também os usuários no banco Mestre\r\n-        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n-\r\n-        // 4. Retorna os dados combinados\r\n-        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n-router.patch('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n-        \r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-\r\n-        // Atualiza apenas os campos fornecidos\r\n-        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n-        if (email) company.email = email;\r\n-        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n-        \r\n-        const updatedCompany = await company.save();\r\n-        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n-router.delete('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const companyId = req.params.id;\r\n-\r\n-        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n-        const companyToDelete = await MasterCompany.findById(companyId);\r\n-        if (!companyToDelete) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-        const dbName = companyToDelete.dbName;\r\n-\r\n-        // 2. Apaga o banco de dados inteiro da empresa\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        await tenantDb.dropDatabase();\r\n-        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n-\r\n-        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n-        await MasterUser.deleteMany({ company: companyId });\r\n-\r\n-        // 4. Exclui a própria empresa do banco Mestre\r\n-        await MasterCompany.findByIdAndDelete(companyId);\r\n-        \r\n-        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao excluir empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n-router.patch('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { daysToAdd } = req.body;\r\n-        const days = parseInt(daysToAdd, 10);\r\n-\r\n-        if (!days || days <= 0) {\r\n-            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n-        }\r\n-\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        const today = new Date();\r\n-        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n-        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n-        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n-            ? company.subscription.endDate\r\n-            : today;\r\n-\r\n-        const newEndDate = new Date(currentEndDate);\r\n-        newEndDate.setDate(newEndDate.getDate() + days);\r\n-\r\n-        company.subscription.status = 'active';\r\n-        company.subscription.endDate = newEndDate;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({ \r\n-            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n-router.delete('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        // Reseta a assinatura para o estado padrão\r\n-        company.subscription.status = 'inactive';\r\n-        company.subscription.endDate = undefined;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({\r\n-            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao remover assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-\r\n-// Importamos a função de conexão do nosso arquivo de configuração\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-router.post('/register', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n-        \r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-\r\n-        const newMasterCompany = await MasterCompany.create({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            dbName: dbName,\r\n-        });\r\n-\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-        \r\n-        // --- CORREÇÃO FINAL AQUI ---\r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n-            role: 'Proprietário', // <-- ESTA LINHA ESTAVA FALTANDO\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        \r\n         await TenantUser.create({\r\n             username: ownerUsername,\r\n             password: hashedOwnerPassword, \r\n             role: 'Proprietário',\r\n@@ -496,266 +245,5 @@\n     }\r\n });\r\n \r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-\r\n-// Importamos a função de conexão do nosso arquivo de configuração\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-router.post('/register', async (req, res) => {\r\n-    // Verificação de segurança: Apenas o SuperAdmin pode criar empresas\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        // Obtemos os modelos a partir da conexão 'masterDb' fornecida pelo middleware\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n-        \r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        // Cria um nome único para o novo banco de dados da empresa\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-\r\n-        // Cria a nova empresa na coleção 'mastercompanies' do banco Mestre\r\n-        const newMasterCompany = await MasterCompany.create({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            dbName: dbName,\r\n-            email: email, // Salva o e-mail da empresa no registro mestre\r\n-        });\r\n-\r\n-        // Cria o usuário 'Proprietário' na coleção 'masterusers' do banco Mestre\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-        \r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n-            role: 'Proprietário',\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        // Conecta-se ao novo banco de dados da empresa (que será criado automaticamente)\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        \r\n-        // Compila o modelo User usando a conexão da empresa\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        // Cria o primeiro usuário (Proprietário) DENTRO do banco de dados da empresa\r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword, \r\n-            role: 'Proprietário',\r\n-            email: email || 'proprietario@email.com' // Usa o e-mail fornecido ou um padrão\r\n-        });\r\n-\r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa:\", error);\r\n-        // Lógica de limpeza em caso de erro\r\n-        const cleanCnpj = req.body.cnpj.replace(/\\D/g, '');\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        await MasterCompany.deleteOne({ cnpj: cleanCnpj });\r\n-        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao listar empresas:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER os detalhes de UMA empresa e seus usuários\r\n-router.get('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // 1. Busca a empresa no banco Mestre\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const users = await TenantUser.find({}).select('-password');\r\n-\r\n-        // 3. NOVO: Busca também os usuários no banco Mestre\r\n-        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n-\r\n-        // 4. Retorna os dados combinados\r\n-        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n-router.patch('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n-        \r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-\r\n-        // Atualiza apenas os campos fornecidos\r\n-        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n-        if (email) company.email = email;\r\n-        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n-        \r\n-        const updatedCompany = await company.save();\r\n-        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n-router.delete('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const companyId = req.params.id;\r\n-\r\n-        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n-        const companyToDelete = await MasterCompany.findById(companyId);\r\n-        if (!companyToDelete) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-        const dbName = companyToDelete.dbName;\r\n-\r\n-        // 2. Apaga o banco de dados inteiro da empresa\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        await tenantDb.dropDatabase();\r\n-        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n-\r\n-        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n-        await MasterUser.deleteMany({ company: companyId });\r\n-\r\n-        // 4. Exclui a própria empresa do banco Mestre\r\n-        await MasterCompany.findByIdAndDelete(companyId);\r\n-        \r\n-        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao excluir empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n-router.patch('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { daysToAdd } = req.body;\r\n-        const days = parseInt(daysToAdd, 10);\r\n-\r\n-        if (!days || days <= 0) {\r\n-            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n-        }\r\n-\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        const today = new Date();\r\n-        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n-        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n-        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n-            ? company.subscription.endDate\r\n-            : today;\r\n-\r\n-        const newEndDate = new Date(currentEndDate);\r\n-        newEndDate.setDate(newEndDate.getDate() + days);\r\n-\r\n-        company.subscription.status = 'active';\r\n-        company.subscription.endDate = newEndDate;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({ \r\n-            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n-router.delete('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        // Reseta a assinatura para o estado padrão\r\n-        company.subscription.status = 'inactive';\r\n-        company.subscription.endDate = undefined;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({\r\n-            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao remover assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753542158285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,249 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+\r\n+// Importamos a função de conexão do nosso arquivo de configuração\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+router.post('/register', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n+\r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n+        if (existingCompany) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+\r\n+        const newMasterCompany = await MasterCompany.create({\r\n+            nomeEmpresa,\r\n+            cnpj: cleanCnpj,\r\n+            dbName: dbName,\r\n+        });\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+\r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword,\r\n+            role: 'Proprietário',\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword, \r\n+            role: 'Proprietário',\r\n+            email: email || 'proprietario@email.com'\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa:\", error);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao listar empresas:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os detalhes de UMA empresa e seus usuários\r\n+router.get('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // 1. Busca a empresa no banco Mestre\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const users = await TenantUser.find({}).select('-password');\r\n+\r\n+        // 3. NOVO: Busca também os usuários no banco Mestre\r\n+        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n+\r\n+        // 4. Retorna os dados combinados\r\n+        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n+router.patch('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n+        \r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+\r\n+        // Atualiza apenas os campos fornecidos\r\n+        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n+        if (email) company.email = email;\r\n+        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n+        \r\n+        const updatedCompany = await company.save();\r\n+        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n+router.delete('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const companyId = req.params.id;\r\n+\r\n+        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n+        const companyToDelete = await MasterCompany.findById(companyId);\r\n+        if (!companyToDelete) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+        const dbName = companyToDelete.dbName;\r\n+\r\n+        // 2. Apaga o banco de dados inteiro da empresa\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        await tenantDb.dropDatabase();\r\n+        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n+\r\n+        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n+        await MasterUser.deleteMany({ company: companyId });\r\n+\r\n+        // 4. Exclui a própria empresa do banco Mestre\r\n+        await MasterCompany.findByIdAndDelete(companyId);\r\n+        \r\n+        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n+router.patch('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { daysToAdd } = req.body;\r\n+        const days = parseInt(daysToAdd, 10);\r\n+\r\n+        if (!days || days <= 0) {\r\n+            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n+        }\r\n+\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        const today = new Date();\r\n+        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n+        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n+        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n+            ? company.subscription.endDate\r\n+            : today;\r\n+\r\n+        const newEndDate = new Date(currentEndDate);\r\n+        newEndDate.setDate(newEndDate.getDate() + days);\r\n+\r\n+        company.subscription.status = 'active';\r\n+        company.subscription.endDate = newEndDate;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({ \r\n+            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n+router.delete('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        // Reseta a assinatura para o estado padrão\r\n+        company.subscription.status = 'inactive';\r\n+        company.subscription.endDate = undefined;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({\r\n+            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753545663589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,292 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+\r\n+// Importamos a função de conexão do nosso arquivo de configuração\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+router.post('/register', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n+\r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n+        if (existingCompany) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+\r\n+        const newMasterCompany = await MasterCompany.create({\r\n+            nomeEmpresa,\r\n+            cnpj: cleanCnpj,\r\n+            dbName: dbName,\r\n+        });\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+\r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword,\r\n+            role: 'Proprietário',\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword, \r\n+            role: 'Proprietário',\r\n+            email: email || 'proprietario@email.com'\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa:\", error);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao listar empresas:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os detalhes de UMA empresa e seus usuários\r\n+router.get('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // 1. Busca a empresa no banco Mestre\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const users = await TenantUser.find({}).select('-password');\r\n+\r\n+        // 3. NOVO: Busca também os usuários no banco Mestre\r\n+        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n+\r\n+        // 4. Retorna os dados combinados\r\n+        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n+router.patch('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n+        \r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+\r\n+        // Atualiza apenas os campos fornecidos\r\n+        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n+        if (email) company.email = email;\r\n+        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n+        \r\n+        const updatedCompany = await company.save();\r\n+        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n+router.delete('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const companyId = req.params.id;\r\n+\r\n+        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n+        const companyToDelete = await MasterCompany.findById(companyId);\r\n+        if (!companyToDelete) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+        const dbName = companyToDelete.dbName;\r\n+\r\n+        // 2. Apaga o banco de dados inteiro da empresa\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        await tenantDb.dropDatabase();\r\n+        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n+\r\n+        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n+        await MasterUser.deleteMany({ company: companyId });\r\n+\r\n+        // 4. Exclui a própria empresa do banco Mestre\r\n+        await MasterCompany.findByIdAndDelete(companyId);\r\n+        \r\n+        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n+router.patch('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { daysToAdd } = req.body;\r\n+        const days = parseInt(daysToAdd, 10);\r\n+\r\n+        if (!days || days <= 0) {\r\n+            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n+        }\r\n+\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        const today = new Date();\r\n+        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n+        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n+        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n+            ? company.subscription.endDate\r\n+            : today;\r\n+\r\n+        const newEndDate = new Date(currentEndDate);\r\n+        newEndDate.setDate(newEndDate.getDate() + days);\r\n+\r\n+        company.subscription.status = 'active';\r\n+        company.subscription.endDate = newEndDate;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({ \r\n+            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n+router.delete('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        // Reseta a assinatura para o estado padrão\r\n+        company.subscription.status = 'inactive';\r\n+        company.subscription.endDate = undefined;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({\r\n+            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+router.patch('/:companyId/users/:userId/role', async (req, res) => {\r\n+    try {\r\n+        // Apenas o SuperAdmin (ou futuramente o Proprietário) pode alterar cargos\r\n+        if (req.user.role !== 'SuperAdmin') {\r\n+            // Adicionar lógica aqui se o Proprietário também puder alterar\r\n+            // return res.status(403).json({ message: 'Acesso negado.' });\r\n+        }\r\n+\r\n+        const { companyId, userId } = req.params;\r\n+        const { role } = req.body;\r\n+\r\n+        if (!role || !['Gerente', 'Funcionário'].includes(role)) {\r\n+            return res.status(400).json({ message: 'Cargo inválido.' });\r\n+        }\r\n+\r\n+        // Modelos do banco Mestre\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+\r\n+        // 1. Atualiza o cargo no banco MESTRE\r\n+        // Usamos 'userId' que é o ID do MasterUser\r\n+        const masterUser = await MasterUser.findByIdAndUpdate(userId, { role }, { new: true });\r\n+        if (!masterUser) {\r\n+            return res.status(404).json({ message: 'Usuário não encontrado no registro mestre.' });\r\n+        }\r\n+\r\n+        // 2. Atualiza o cargo no banco da EMPRESA\r\n+        const company = await MasterCompany.findById(companyId);\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        // Encontramos o usuário no banco da empresa pelo username, que é consistente\r\n+        await TenantUser.findOneAndUpdate({ username: masterUser.username }, { role });\r\n+\r\n+        res.status(200).json({ message: `Cargo do usuário ${masterUser.username} atualizado para ${role}!` });\r\n+\r\n+    } catch (error)\r\n+    {\r\n+        console.error(\"Erro ao atualizar cargo do usuário:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753546080162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,24 +116,32 @@\n \r\n // Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n router.patch('/:id', async (req, res) => {\r\n     try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n-        \r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n \r\n-        // Atualiza apenas os campos fornecidos\r\n-        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n-        if (email) company.email = email;\r\n-        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n-        \r\n-        const updatedCompany = await company.save();\r\n-        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n+        // Obtém o modelo a partir da conexão com o banco Mestre\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n \r\n+        // Pega os dados que o frontend enviou para atualização\r\n+        const updateData = req.body;\r\n+\r\n+        const updatedCompany = await MasterCompany.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { $set: updateData }, // Atualiza a empresa com os novos dados\r\n+            { new: true }         // Opção para retornar o documento já atualizado\r\n+        );\r\n+\r\n+        if (!updatedCompany) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        res.status(200).json({\r\n+            message: \"Dados da empresa atualizados com sucesso!\",\r\n+            company: updatedCompany\r\n+        });\r\n+\r\n     } catch (error) {\r\n-        console.error(\"Erro ao atualizar empresa:\", error);\r\n+        console.error(\"Erro ao atualizar dados da empresa:\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor.' });\r\n     }\r\n });\r\n \r\n@@ -288,503 +296,5 @@\n     }\r\n });\r\n \r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-\r\n-// Importamos a função de conexão do nosso arquivo de configuração\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-router.post('/register', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n-\r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-\r\n-        const newMasterCompany = await MasterCompany.create({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            dbName: dbName,\r\n-        });\r\n-\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-\r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n-            role: 'Proprietário',\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword, \r\n-            role: 'Proprietário',\r\n-            email: email || 'proprietario@email.com'\r\n-        });\r\n-\r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa:\", error);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n-        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao listar empresas:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER os detalhes de UMA empresa e seus usuários\r\n-router.get('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // 1. Busca a empresa no banco Mestre\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const users = await TenantUser.find({}).select('-password');\r\n-\r\n-        // 3. NOVO: Busca também os usuários no banco Mestre\r\n-        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n-\r\n-        // 4. Retorna os dados combinados\r\n-        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n-router.patch('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n-        \r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-\r\n-        // Atualiza apenas os campos fornecidos\r\n-        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n-        if (email) company.email = email;\r\n-        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n-        \r\n-        const updatedCompany = await company.save();\r\n-        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n-router.delete('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const companyId = req.params.id;\r\n-\r\n-        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n-        const companyToDelete = await MasterCompany.findById(companyId);\r\n-        if (!companyToDelete) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-        const dbName = companyToDelete.dbName;\r\n-\r\n-        // 2. Apaga o banco de dados inteiro da empresa\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        await tenantDb.dropDatabase();\r\n-        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n-\r\n-        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n-        await MasterUser.deleteMany({ company: companyId });\r\n-\r\n-        // 4. Exclui a própria empresa do banco Mestre\r\n-        await MasterCompany.findByIdAndDelete(companyId);\r\n-        \r\n-        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao excluir empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n-router.patch('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { daysToAdd } = req.body;\r\n-        const days = parseInt(daysToAdd, 10);\r\n-\r\n-        if (!days || days <= 0) {\r\n-            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n-        }\r\n-\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        const today = new Date();\r\n-        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n-        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n-        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n-            ? company.subscription.endDate\r\n-            : today;\r\n-\r\n-        const newEndDate = new Date(currentEndDate);\r\n-        newEndDate.setDate(newEndDate.getDate() + days);\r\n-\r\n-        company.subscription.status = 'active';\r\n-        company.subscription.endDate = newEndDate;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({ \r\n-            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n-router.delete('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        // Reseta a assinatura para o estado padrão\r\n-        company.subscription.status = 'inactive';\r\n-        company.subscription.endDate = undefined;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({\r\n-            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao remover assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-\r\n-// Importamos a função de conexão do nosso arquivo de configuração\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-router.post('/register', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n-\r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-\r\n-        const newMasterCompany = await MasterCompany.create({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            dbName: dbName,\r\n-        });\r\n-\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-\r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n-            role: 'Proprietário', // <-- ESTA LINHA ESTAVA FALTANDO\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword, \r\n-            role: 'Proprietário',\r\n-            email: email || 'proprietario@email.com'\r\n-        });\r\n-\r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa:\", error);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n-        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao listar empresas:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER os detalhes de UMA empresa e seus usuários\r\n-router.get('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // 1. Busca a empresa no banco Mestre\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const users = await TenantUser.find({}).select('-password');\r\n-\r\n-        // 3. NOVO: Busca também os usuários no banco Mestre\r\n-        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n-\r\n-        // 4. Retorna os dados combinados\r\n-        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n-router.patch('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { nomeEmpresa, email, telefoneFixo, telefoneWhatsapp } = req.body;\r\n-        \r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-\r\n-        // Atualiza apenas os campos fornecidos\r\n-        if (nomeEmpresa) company.nomeEmpresa = nomeEmpresa;\r\n-        if (email) company.email = email;\r\n-        // Adicione outros campos da MasterCompany que possam ser atualizados aqui\r\n-        \r\n-        const updatedCompany = await company.save();\r\n-        res.status(200).json({ message: \"Dados da empresa atualizados com sucesso!\", company: updatedCompany });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n-router.delete('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const companyId = req.params.id;\r\n-\r\n-        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n-        const companyToDelete = await MasterCompany.findById(companyId);\r\n-        if (!companyToDelete) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-        const dbName = companyToDelete.dbName;\r\n-\r\n-        // 2. Apaga o banco de dados inteiro da empresa\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        await tenantDb.dropDatabase();\r\n-        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n-\r\n-        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n-        await MasterUser.deleteMany({ company: companyId });\r\n-\r\n-        // 4. Exclui a própria empresa do banco Mestre\r\n-        await MasterCompany.findByIdAndDelete(companyId);\r\n-        \r\n-        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao excluir empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n-router.patch('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { daysToAdd } = req.body;\r\n-        const days = parseInt(daysToAdd, 10);\r\n-\r\n-        if (!days || days <= 0) {\r\n-            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n-        }\r\n-\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        const today = new Date();\r\n-        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n-        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n-        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n-            ? company.subscription.endDate\r\n-            : today;\r\n-\r\n-        const newEndDate = new Date(currentEndDate);\r\n-        newEndDate.setDate(newEndDate.getDate() + days);\r\n-\r\n-        company.subscription.status = 'active';\r\n-        company.subscription.endDate = newEndDate;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({ \r\n-            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n-router.delete('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        // Reseta a assinatura para o estado padrão\r\n-        company.subscription.status = 'inactive';\r\n-        company.subscription.endDate = undefined;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({\r\n-            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao remover assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753546219145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,304 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+\r\n+// Importamos a função de conexão do nosso arquivo de configuração\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+router.post('/register', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n+\r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n+        if (existingCompany) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+\r\n+        const newMasterCompany = await MasterCompany.create({\r\n+            nomeEmpresa,\r\n+            cnpj: cleanCnpj,\r\n+            dbName: dbName,\r\n+        });\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+\r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword,\r\n+            role: 'Proprietário',\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedOwnerPassword, \r\n+            role: 'Proprietário',\r\n+            email: email || 'proprietario@email.com'\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa:\", error);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao listar empresas:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os detalhes de UMA empresa e seus usuários\r\n+router.get('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // 1. Busca a empresa no banco Mestre\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const users = await TenantUser.find({}).select('-password');\r\n+\r\n+        // 3. NOVO: Busca também os usuários no banco Mestre\r\n+        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n+\r\n+        // 4. Retorna os dados combinados\r\n+        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n+router.patch('/:id', async (req, res) => {\r\n+    try {\r\n+        // Verificação de Segurança: Garante que um Proprietário só pode editar sua própria empresa.\r\n+        // O SuperAdmin pode editar qualquer uma.\r\n+        if (req.user.role !== 'SuperAdmin' && req.user.companyId !== req.params.id) {\r\n+            return res.status(403).json({ message: 'Acesso negado. Você só pode editar sua própria empresa.' });\r\n+        }\r\n+\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+\r\n+        // Pega os dados que o frontend enviou para atualização\r\n+        const updateData = req.body;\r\n+\r\n+        const updatedCompany = await MasterCompany.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { $set: updateData }, // Atualiza a empresa com os novos dados\r\n+            { new: true }         // Opção para retornar o documento já atualizado\r\n+        );\r\n+\r\n+        if (!updatedCompany) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        res.status(200).json({\r\n+            message: \"Dados da empresa atualizados com sucesso!\",\r\n+            company: updatedCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar dados da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n+router.delete('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const companyId = req.params.id;\r\n+\r\n+        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n+        const companyToDelete = await MasterCompany.findById(companyId);\r\n+        if (!companyToDelete) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+        const dbName = companyToDelete.dbName;\r\n+\r\n+        // 2. Apaga o banco de dados inteiro da empresa\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        await tenantDb.dropDatabase();\r\n+        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n+\r\n+        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n+        await MasterUser.deleteMany({ company: companyId });\r\n+\r\n+        // 4. Exclui a própria empresa do banco Mestre\r\n+        await MasterCompany.findByIdAndDelete(companyId);\r\n+        \r\n+        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n+router.patch('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { daysToAdd } = req.body;\r\n+        const days = parseInt(daysToAdd, 10);\r\n+\r\n+        if (!days || days <= 0) {\r\n+            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n+        }\r\n+\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        const today = new Date();\r\n+        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n+        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n+        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n+            ? company.subscription.endDate\r\n+            : today;\r\n+\r\n+        const newEndDate = new Date(currentEndDate);\r\n+        newEndDate.setDate(newEndDate.getDate() + days);\r\n+\r\n+        company.subscription.status = 'active';\r\n+        company.subscription.endDate = newEndDate;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({ \r\n+            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n+router.delete('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        // Reseta a assinatura para o estado padrão\r\n+        company.subscription.status = 'inactive';\r\n+        company.subscription.endDate = undefined;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({\r\n+            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+router.patch('/:companyId/users/:userId/role', async (req, res) => {\r\n+    try {\r\n+        // Apenas o SuperAdmin (ou futuramente o Proprietário) pode alterar cargos\r\n+        if (req.user.role !== 'SuperAdmin') {\r\n+            // Adicionar lógica aqui se o Proprietário também puder alterar\r\n+            // return res.status(403).json({ message: 'Acesso negado.' });\r\n+        }\r\n+\r\n+        const { companyId, userId } = req.params;\r\n+        const { role } = req.body;\r\n+\r\n+        if (!role || !['Gerente', 'Funcionário'].includes(role)) {\r\n+            return res.status(400).json({ message: 'Cargo inválido.' });\r\n+        }\r\n+\r\n+        // Modelos do banco Mestre\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+\r\n+        // 1. Atualiza o cargo no banco MESTRE\r\n+        // Usamos 'userId' que é o ID do MasterUser\r\n+        const masterUser = await MasterUser.findByIdAndUpdate(userId, { role }, { new: true });\r\n+        if (!masterUser) {\r\n+            return res.status(404).json({ message: 'Usuário não encontrado no registro mestre.' });\r\n+        }\r\n+\r\n+        // 2. Atualiza o cargo no banco da EMPRESA\r\n+        const company = await MasterCompany.findById(companyId);\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        // Encontramos o usuário no banco da empresa pelo username, que é consistente\r\n+        await TenantUser.findOneAndUpdate({ username: masterUser.username }, { role });\r\n+\r\n+        res.status(200).json({ message: `Cargo do usuário ${masterUser.username} atualizado para ${role}!` });\r\n+\r\n+    } catch (error)\r\n+    {\r\n+        console.error(\"Erro ao atualizar cargo do usuário:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753546703357,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,39 +11,35 @@\n const { getTenantConnection } = require('../config/db');\r\n \r\n \r\n // ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-router.post('/register', async (req, res) => {\r\n+router.post('/', async (req, res) => {\r\n+    // A proteção já é garantida pelo middleware no server.js\r\n     if (req.user.role !== 'SuperAdmin') {\r\n         return res.status(403).json({ message: 'Acesso negado.' });\r\n     }\r\n \r\n     try {\r\n         const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n         const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n \r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n+        // Dados vêm do modal de admin\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword } = req.body;\r\n \r\n         const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n+        if (await MasterCompany.findOne({ cnpj: cleanCnpj })) {\r\n             return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n         }\r\n \r\n         const dbName = `empresa_${cleanCnpj}`;\r\n+        const newMasterCompany = await MasterCompany.create({ nomeEmpresa, cnpj: cleanCnpj, dbName });\r\n \r\n-        const newMasterCompany = await MasterCompany.create({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            dbName: dbName,\r\n-        });\r\n-\r\n         const salt = await bcrypt.genSalt(10);\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n+        const hashedPassword = await bcrypt.hash(ownerPassword, salt);\r\n \r\n         await MasterUser.create({\r\n             username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n+            password: hashedPassword,\r\n             role: 'Proprietário',\r\n             company: newMasterCompany._id\r\n         });\r\n \r\n@@ -51,24 +47,20 @@\n         const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n \r\n         await TenantUser.create({\r\n             username: ownerUsername,\r\n-            password: hashedOwnerPassword, \r\n+            password: hashedPassword, \r\n             role: 'Proprietário',\r\n-            email: email || 'proprietario@email.com'\r\n+            email: 'proprietario@email.com' // Pode ser pego do formulário no futuro\r\n         });\r\n \r\n         res.status(201).json({ \r\n             message: 'Empresa e usuário proprietário criados com sucesso!',\r\n             company: newMasterCompany\r\n         });\r\n \r\n     } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa:\", error);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n-        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        console.error(\"Erro ao criar nova empresa (admin):\", error);\r\n         res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n     }\r\n });\r\n \r\n@@ -300,305 +292,5 @@\n     }\r\n });\r\n \r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-\r\n-// Importamos a função de conexão do nosso arquivo de configuração\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-router.post('/register', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n-\r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        const existingCompany = await MasterCompany.findOne({ cnpj: cleanCnpj });\r\n-        if (existingCompany) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-\r\n-        const newMasterCompany = await MasterCompany.create({\r\n-            nomeEmpresa,\r\n-            cnpj: cleanCnpj,\r\n-            dbName: dbName,\r\n-        });\r\n-\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n-\r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword,\r\n-            role: 'Proprietário',\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedOwnerPassword, \r\n-            role: 'Proprietário',\r\n-            email: email || 'proprietario@email.com'\r\n-        });\r\n-\r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa:\", error);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-        await MasterCompany.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n-        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao listar empresas:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER os detalhes de UMA empresa e seus usuários\r\n-router.get('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // 1. Busca a empresa no banco Mestre\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const users = await TenantUser.find({}).select('-password');\r\n-\r\n-        // 3. NOVO: Busca também os usuários no banco Mestre\r\n-        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n-\r\n-        // 4. Retorna os dados combinados\r\n-        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n-router.patch('/:id', async (req, res) => {\r\n-    try {\r\n-\r\n-        // Obtém o modelo a partir da conexão com o banco Mestre\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-\r\n-        // Pega os dados que o frontend enviou para atualização\r\n-        const updateData = req.body;\r\n-\r\n-        const updatedCompany = await MasterCompany.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { $set: updateData }, // Atualiza a empresa com os novos dados\r\n-            { new: true }         // Opção para retornar o documento já atualizado\r\n-        );\r\n-\r\n-        if (!updatedCompany) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        res.status(200).json({\r\n-            message: \"Dados da empresa atualizados com sucesso!\",\r\n-            company: updatedCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar dados da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n-router.delete('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const companyId = req.params.id;\r\n-\r\n-        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n-        const companyToDelete = await MasterCompany.findById(companyId);\r\n-        if (!companyToDelete) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-        const dbName = companyToDelete.dbName;\r\n-\r\n-        // 2. Apaga o banco de dados inteiro da empresa\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        await tenantDb.dropDatabase();\r\n-        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n-\r\n-        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n-        await MasterUser.deleteMany({ company: companyId });\r\n-\r\n-        // 4. Exclui a própria empresa do banco Mestre\r\n-        await MasterCompany.findByIdAndDelete(companyId);\r\n-        \r\n-        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao excluir empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n-router.patch('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { daysToAdd } = req.body;\r\n-        const days = parseInt(daysToAdd, 10);\r\n-\r\n-        if (!days || days <= 0) {\r\n-            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n-        }\r\n-\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        const today = new Date();\r\n-        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n-        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n-        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n-            ? company.subscription.endDate\r\n-            : today;\r\n-\r\n-        const newEndDate = new Date(currentEndDate);\r\n-        newEndDate.setDate(newEndDate.getDate() + days);\r\n-\r\n-        company.subscription.status = 'active';\r\n-        company.subscription.endDate = newEndDate;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({ \r\n-            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n-router.delete('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        // Reseta a assinatura para o estado padrão\r\n-        company.subscription.status = 'inactive';\r\n-        company.subscription.endDate = undefined;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({\r\n-            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao remover assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-router.patch('/:companyId/users/:userId/role', async (req, res) => {\r\n-    try {\r\n-        // Apenas o SuperAdmin (ou futuramente o Proprietário) pode alterar cargos\r\n-        if (req.user.role !== 'SuperAdmin') {\r\n-            // Adicionar lógica aqui se o Proprietário também puder alterar\r\n-            // return res.status(403).json({ message: 'Acesso negado.' });\r\n-        }\r\n-\r\n-        const { companyId, userId } = req.params;\r\n-        const { role } = req.body;\r\n-\r\n-        if (!role || !['Gerente', 'Funcionário'].includes(role)) {\r\n-            return res.status(400).json({ message: 'Cargo inválido.' });\r\n-        }\r\n-\r\n-        // Modelos do banco Mestre\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-\r\n-        // 1. Atualiza o cargo no banco MESTRE\r\n-        // Usamos 'userId' que é o ID do MasterUser\r\n-        const masterUser = await MasterUser.findByIdAndUpdate(userId, { role }, { new: true });\r\n-        if (!masterUser) {\r\n-            return res.status(404).json({ message: 'Usuário não encontrado no registro mestre.' });\r\n-        }\r\n-\r\n-        // 2. Atualiza o cargo no banco da EMPRESA\r\n-        const company = await MasterCompany.findById(companyId);\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        // Encontramos o usuário no banco da empresa pelo username, que é consistente\r\n-        await TenantUser.findOneAndUpdate({ username: masterUser.username }, { role });\r\n-\r\n-        res.status(200).json({ message: `Cargo do usuário ${masterUser.username} atualizado para ${role}!` });\r\n-\r\n-    } catch (error)\r\n-    {\r\n-        console.error(\"Erro ao atualizar cargo do usuário:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753546739280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,347 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+\r\n+// Importamos a função de conexão do nosso arquivo de configuração\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n+router.post('/', async (req, res) => {\r\n+    // A proteção já é garantida pelo middleware no server.js\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        // Dados vêm do modal de admin\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword } = req.body;\r\n+\r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        if (await MasterCompany.findOne({ cnpj: cleanCnpj })) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+        const newMasterCompany = await MasterCompany.create({ nomeEmpresa, cnpj: cleanCnpj, dbName });\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedPassword = await bcrypt.hash(ownerPassword, salt);\r\n+\r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedPassword,\r\n+            role: 'Proprietário',\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedPassword, \r\n+            role: 'Proprietário',\r\n+            email: 'proprietario@email.com' // Pode ser pego do formulário no futuro\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa (admin):\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao listar empresas:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os detalhes de UMA empresa e seus usuários\r\n+router.get('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        // 1. Busca a empresa no banco Mestre\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const users = await TenantUser.find({}).select('-password');\r\n+\r\n+        // 3. NOVO: Busca também os usuários no banco Mestre\r\n+        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n+\r\n+        // 4. Retorna os dados combinados\r\n+        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n+router.patch('/:id', async (req, res) => {\r\n+    try {\r\n+        // Verificação de Segurança: Garante que um Proprietário só pode editar sua própria empresa.\r\n+        // O SuperAdmin pode editar qualquer uma.\r\n+        if (req.user.role !== 'SuperAdmin' && req.user.companyId !== req.params.id) {\r\n+            return res.status(403).json({ message: 'Acesso negado. Você só pode editar sua própria empresa.' });\r\n+        }\r\n+\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+\r\n+        // Pega os dados que o frontend enviou para atualização\r\n+        const updateData = req.body;\r\n+\r\n+        const updatedCompany = await MasterCompany.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { $set: updateData }, // Atualiza a empresa com os novos dados\r\n+            { new: true }         // Opção para retornar o documento já atualizado\r\n+        );\r\n+\r\n+        if (!updatedCompany) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        res.status(200).json({\r\n+            message: \"Dados da empresa atualizados com sucesso!\",\r\n+            company: updatedCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar dados da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n+router.delete('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const companyId = req.params.id;\r\n+\r\n+        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n+        const companyToDelete = await MasterCompany.findById(companyId);\r\n+        if (!companyToDelete) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+        const dbName = companyToDelete.dbName;\r\n+\r\n+        // 2. Apaga o banco de dados inteiro da empresa\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        await tenantDb.dropDatabase();\r\n+        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n+\r\n+        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n+        await MasterUser.deleteMany({ company: companyId });\r\n+\r\n+        // 4. Exclui a própria empresa do banco Mestre\r\n+        await MasterCompany.findByIdAndDelete(companyId);\r\n+        \r\n+        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n+router.patch('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { daysToAdd } = req.body;\r\n+        const days = parseInt(daysToAdd, 10);\r\n+\r\n+        if (!days || days <= 0) {\r\n+            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n+        }\r\n+\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        const today = new Date();\r\n+        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n+        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n+        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n+            ? company.subscription.endDate\r\n+            : today;\r\n+\r\n+        const newEndDate = new Date(currentEndDate);\r\n+        newEndDate.setDate(newEndDate.getDate() + days);\r\n+\r\n+        company.subscription.status = 'active';\r\n+        company.subscription.endDate = newEndDate;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({ \r\n+            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n+router.delete('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        // Reseta a assinatura para o estado padrão\r\n+        company.subscription.status = 'inactive';\r\n+        company.subscription.endDate = undefined;\r\n+\r\n+        await company.save();\r\n+\r\n+        res.status(200).json({\r\n+            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n+            company: company // Retorna a empresa atualizada\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+router.patch('/:companyId/users/:userId/role', async (req, res) => {\r\n+    try {\r\n+        // Apenas o SuperAdmin (ou futuramente o Proprietário) pode alterar cargos\r\n+        if (req.user.role !== 'SuperAdmin') {\r\n+            // Adicionar lógica aqui se o Proprietário também puder alterar\r\n+            // return res.status(403).json({ message: 'Acesso negado.' });\r\n+        }\r\n+\r\n+        const { companyId, userId } = req.params;\r\n+        const { role } = req.body;\r\n+\r\n+        if (!role || !['Gerente', 'Funcionário'].includes(role)) {\r\n+            return res.status(400).json({ message: 'Cargo inválido.' });\r\n+        }\r\n+\r\n+        // Modelos do banco Mestre\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+\r\n+        // 1. Atualiza o cargo no banco MESTRE\r\n+        // Usamos 'userId' que é o ID do MasterUser\r\n+        const masterUser = await MasterUser.findByIdAndUpdate(userId, { role }, { new: true });\r\n+        if (!masterUser) {\r\n+            return res.status(404).json({ message: 'Usuário não encontrado no registro mestre.' });\r\n+        }\r\n+\r\n+        // 2. Atualiza o cargo no banco da EMPRESA\r\n+        const company = await MasterCompany.findById(companyId);\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        // Encontramos o usuário no banco da empresa pelo username, que é consistente\r\n+        await TenantUser.findOneAndUpdate({ username: masterUser.username }, { role });\r\n+\r\n+        res.status(200).json({ message: `Cargo do usuário ${masterUser.username} atualizado para ${role}!` });\r\n+\r\n+    } catch (error)\r\n+    {\r\n+        console.error(\"Erro ao atualizar cargo do usuário:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// ROTA PÚBLICA DE CADASTRO (SELF-SERVICE)\r\n+router.post('/register-company', async (req, res) => {\r\n+    try {\r\n+        // Esta rota usa o masterDbMiddleware, então req.masterDb está disponível\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n+\r\n+        // Validações\r\n+        if (!nomeEmpresa || !cnpj || !email || !username || !password) {\r\n+            return res.status(400).json({ message: \"Todos os campos são obrigatórios.\" });\r\n+        }\r\n+        if (await MasterCompany.findOne({ cnpj })) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+        if (await MasterUser.findOne({ email: ownerEmail })) {\r\n+            return res.status(400).json({ message: 'Este e-mail de proprietário já está em uso.' });\r\n+        }\r\n+\r\n+        const dbName = `empresa_${cnpj}`;\r\n+        const newMasterCompany = await MasterCompany.create({ nomeEmpresa, cnpj, dbName, email, telefoneWhatsapp });\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedPassword = await bcrypt.hash(password, salt);\r\n+\r\n+        await MasterUser.create({\r\n+            username: username,\r\n+            password: hashedPassword,\r\n+            role: 'Proprietário',\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        await TenantUser.create({\r\n+            username,\r\n+            password: hashedPassword, \r\n+            role: 'Proprietário',\r\n+            email: ownerEmail\r\n+        });\r\n+\r\n+        res.status(201).json({ message: 'Empresa e usuário proprietário cadastrados com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no cadastro self-service:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor durante o cadastro.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753567618040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -342,302 +342,69 @@\n         res.status(500).json({ message: 'Erro interno no servidor durante o cadastro.' });\r\n     }\r\n });\r\n \r\n+// Rota para EXCLUIR um usuário de uma empresa (SuperAdmin ou Proprietário)\r\n+router.delete('/:companyId/users/:userId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, userId } = req.params;\r\n+        const { role: requesterRole, companyId: requesterCompanyId } = req.user;\r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-\r\n-// Importamos a função de conexão do nosso arquivo de configuração\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-router.post('/', async (req, res) => {\r\n-    // A proteção já é garantida pelo middleware no server.js\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n+        // Modelos do banco Mestre\r\n         const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema); // Usa o schema importado\r\n \r\n-        // Dados vêm do modal de admin\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword } = req.body;\r\n-\r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        if (await MasterCompany.findOne({ cnpj: cleanCnpj })) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        // 1. Verificação de Autorização:\r\n+        // - Apenas SuperAdmin pode excluir qualquer usuário de qualquer empresa.\r\n+        // - Proprietário pode excluir usuários da SUA PRÓPRIA empresa, exceto a si mesmo.\r\n+        if (requesterRole !== 'SuperAdmin') {\r\n+            if (requesterRole === 'Proprietário' && requesterCompanyId.toString() === companyId) {\r\n+                // Proprietário tentando excluir usuário da própria empresa\r\n+                const userToDelete = await MasterUser.findById(userId);\r\n+                if (!userToDelete) {\r\n+                    return res.status(404).json({ message: 'Usuário não encontrado.' });\r\n+                }\r\n+                if (userToDelete.role === 'Proprietário') {\r\n+                    // Proprietário não pode excluir outro proprietário (para evitar ficar sem acesso)\r\n+                    // ou a si mesmo (se for o único proprietário).\r\n+                    // Esta lógica pode ser mais complexa se houver vários proprietários.\r\n+                    return res.status(403).json({ message: 'Proprietários não podem excluir outros proprietários ou a si mesmos.' });\r\n+                }\r\n+            } else {\r\n+                return res.status(403).json({ message: 'Acesso negado. Você não tem permissão para remover usuários de outras empresas.' });\r\n+            }\r\n         }\r\n \r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-        const newMasterCompany = await MasterCompany.create({ nomeEmpresa, cnpj: cleanCnpj, dbName });\r\n-\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedPassword = await bcrypt.hash(ownerPassword, salt);\r\n-\r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedPassword,\r\n-            role: 'Proprietário',\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedPassword, \r\n-            role: 'Proprietário',\r\n-            email: 'proprietario@email.com' // Pode ser pego do formulário no futuro\r\n-        });\r\n-\r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa (admin):\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao listar empresas:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER os detalhes de UMA empresa e seus usuários\r\n-router.get('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-\r\n-        // 1. Busca a empresa no banco Mestre\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n+        // 2. Encontra a empresa no banco Mestre para obter o nome do seu DB Tenant\r\n+        const company = await MasterCompany.findById(companyId);\r\n         if (!company) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+            return res.status(404).json({ message: \"Empresa não encontrada no registro mestre.\" });\r\n         }\r\n \r\n-        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const users = await TenantUser.find({}).select('-password');\r\n-\r\n-        // 3. NOVO: Busca também os usuários no banco Mestre\r\n-        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n-\r\n-        // 4. Retorna os dados combinados\r\n-        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n-router.patch('/:id', async (req, res) => {\r\n-    try {\r\n-        // Verificação de Segurança: Garante que um Proprietário só pode editar sua própria empresa.\r\n-        // O SuperAdmin pode editar qualquer uma.\r\n-        if (req.user.role !== 'SuperAdmin' && req.user.companyId !== req.params.id) {\r\n-            return res.status(403).json({ message: 'Acesso negado. Você só pode editar sua própria empresa.' });\r\n+        // 3. Exclui o usuário do banco Mestre\r\n+        const masterUserDeleted = await MasterUser.findByIdAndDelete(userId);\r\n+        if (!masterUserDeleted) {\r\n+            return res.status(404).json({ message: 'Usuário não encontrado no registro mestre para exclusão.' });\r\n         }\r\n+        console.log(`[COMPANY ROUTE] Usuário ${masterUserDeleted.username} (${masterUserDeleted._id}) excluído do Master DB.`);\r\n \r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        // 4. Exclui o usuário do banco de dados da empresa (Tenant)\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', UserSchema); // Usa o schema importado\r\n \r\n-        // Pega os dados que o frontend enviou para atualização\r\n-        const updateData = req.body;\r\n-\r\n-        const updatedCompany = await MasterCompany.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { $set: updateData }, // Atualiza a empresa com os novos dados\r\n-            { new: true }         // Opção para retornar o documento já atualizado\r\n-        );\r\n-\r\n-        if (!updatedCompany) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        const tenantUserDeleted = await TenantUser.findOneAndDelete({ username: masterUserDeleted.username }); // Exclui pelo username\r\n+        if (tenantUserDeleted) {\r\n+            console.log(`[COMPANY ROUTE] Usuário ${tenantUserDeleted.username} (${tenantUserDeleted._id}) excluído do DB do tenant ${company.dbName}.`);\r\n+        } else {\r\n+            console.log(`[COMPANY ROUTE] Aviso: Usuário ${masterUserDeleted.username} não encontrado no DB do tenant ${company.dbName} para exclusão (já havia sido removido?).`);\r\n         }\r\n \r\n-        res.status(200).json({\r\n-            message: \"Dados da empresa atualizados com sucesso!\",\r\n-            company: updatedCompany\r\n-        });\r\n+        res.status(200).json({ message: 'Usuário removido com sucesso!' });\r\n \r\n     } catch (error) {\r\n-        console.error(\"Erro ao atualizar dados da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+        console.error(\"Erro ao remover usuário da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao remover o usuário.' });\r\n     }\r\n });\r\n \r\n-// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n-router.delete('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const companyId = req.params.id;\r\n \r\n-        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n-        const companyToDelete = await MasterCompany.findById(companyId);\r\n-        if (!companyToDelete) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-        const dbName = companyToDelete.dbName;\r\n-\r\n-        // 2. Apaga o banco de dados inteiro da empresa\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        await tenantDb.dropDatabase();\r\n-        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n-\r\n-        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n-        await MasterUser.deleteMany({ company: companyId });\r\n-\r\n-        // 4. Exclui a própria empresa do banco Mestre\r\n-        await MasterCompany.findByIdAndDelete(companyId);\r\n-        \r\n-        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao excluir empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n-router.patch('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { daysToAdd } = req.body;\r\n-        const days = parseInt(daysToAdd, 10);\r\n-\r\n-        if (!days || days <= 0) {\r\n-            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n-        }\r\n-\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        const today = new Date();\r\n-        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n-        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n-        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n-            ? company.subscription.endDate\r\n-            : today;\r\n-\r\n-        const newEndDate = new Date(currentEndDate);\r\n-        newEndDate.setDate(newEndDate.getDate() + days);\r\n-\r\n-        company.subscription.status = 'active';\r\n-        company.subscription.endDate = newEndDate;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({ \r\n-            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n-router.delete('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        // Reseta a assinatura para o estado padrão\r\n-        company.subscription.status = 'inactive';\r\n-        company.subscription.endDate = undefined;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({\r\n-            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao remover assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-router.patch('/:companyId/users/:userId/role', async (req, res) => {\r\n-    try {\r\n-        // Apenas o SuperAdmin (ou futuramente o Proprietário) pode alterar cargos\r\n-        if (req.user.role !== 'SuperAdmin') {\r\n-            // Adicionar lógica aqui se o Proprietário também puder alterar\r\n-            // return res.status(403).json({ message: 'Acesso negado.' });\r\n-        }\r\n-\r\n-        const { companyId, userId } = req.params;\r\n-        const { role } = req.body;\r\n-\r\n-        if (!role || !['Gerente', 'Funcionário'].includes(role)) {\r\n-            return res.status(400).json({ message: 'Cargo inválido.' });\r\n-        }\r\n-\r\n-        // Modelos do banco Mestre\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-\r\n-        // 1. Atualiza o cargo no banco MESTRE\r\n-        // Usamos 'userId' que é o ID do MasterUser\r\n-        const masterUser = await MasterUser.findByIdAndUpdate(userId, { role }, { new: true });\r\n-        if (!masterUser) {\r\n-            return res.status(404).json({ message: 'Usuário não encontrado no registro mestre.' });\r\n-        }\r\n-\r\n-        // 2. Atualiza o cargo no banco da EMPRESA\r\n-        const company = await MasterCompany.findById(companyId);\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        // Encontramos o usuário no banco da empresa pelo username, que é consistente\r\n-        await TenantUser.findOneAndUpdate({ username: masterUser.username }, { role });\r\n-\r\n-        res.status(200).json({ message: `Cargo do usuário ${masterUser.username} atualizado para ${role}!` });\r\n-\r\n-    } catch (error)\r\n-    {\r\n-        console.error(\"Erro ao atualizar cargo do usuário:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753567652224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,9 @@\n \r\n // CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const UserSchema = require('../models/User').schema;\r\n \r\n // Importamos a função de conexão do nosso arquivo de configuração\r\n const { getTenantConnection } = require('../config/db');\r\n \r\n"
                },
                {
                    "date": 1753703952026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,23 +80,23 @@\n \r\n // Rota para LER os detalhes de UMA empresa e seus usuários\r\n router.get('/:id', async (req, res) => {\r\n     try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n \r\n         // 1. Busca a empresa no banco Mestre\r\n         const company = await MasterCompany.findById(req.params.id);\r\n         if (!company) {\r\n             return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n         }\r\n \r\n-        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela\r\n+        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela (pode ser útil para outras infos)\r\n         const tenantDb = await getTenantConnection(company.dbName);\r\n         const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n         const users = await TenantUser.find({}).select('-password');\r\n \r\n-        // 3. NOVO: Busca também os usuários no banco Mestre\r\n+        // 3. NOVO E CRUCIAL: Busca também os usuários no banco Mestre\r\n         const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n \r\n         // 4. Retorna os dados combinados\r\n         res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n"
                },
                {
                    "date": 1753704476265,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,369 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const mongoose = require('mongoose');\r\n+\r\n+// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n+const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n+const MasterUserSchema = require('../models/MasterUser').schema;\r\n+const UserSchema = require('../models/User').schema;\r\n+\r\n+// Importamos a função de conexão do nosso arquivo de configuração\r\n+const { getTenantConnection } = require('../config/db');\r\n+\r\n+\r\n+// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin, via painel)\r\n+// Corresponde a POST /api/companies/\r\n+router.post('/', async (req, res) => {\r\n+    // A proteção já é garantida pelo middleware no server.js\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword, email } = req.body;\r\n+        \r\n+        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n+        if (await MasterCompany.findOne({ cnpj: cleanCnpj })) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+\r\n+        const dbName = `empresa_${cleanCnpj}`;\r\n+        const newMasterCompany = await MasterCompany.create({ nomeEmpresa, cnpj: cleanCnpj, dbName, email });\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedPassword = await bcrypt.hash(ownerPassword, salt);\r\n+        \r\n+        await MasterUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedPassword,\r\n+            role: 'Proprietário',\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        \r\n+        await TenantUser.create({\r\n+            username: ownerUsername,\r\n+            password: hashedPassword, \r\n+            role: 'Proprietário',\r\n+            email: email || 'proprietario@email.com'\r\n+        });\r\n+\r\n+        res.status(201).json({ \r\n+            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n+            company: newMasterCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao criar nova empresa (admin):\", error);\r\n+        const cleanCnpj = req.body.cnpj.replace(/\\D/g, '');\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        await MasterCompany.deleteOne({ cnpj: cleanCnpj });\r\n+        await MasterUser.deleteOne({ username: req.body.ownerUsername });\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+// Rota para LER TODAS as empresas\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const companies = await MasterCompany.find({});\r\n+        res.status(200).json(companies);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao listar empresas:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para LER os detalhes de UMA empresa e seus usuários\r\n+router.get('/:id', async (req, res) => {\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        \r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        const users = await TenantUser.find({}).select('-password');\r\n+        \r\n+        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n+        \r\n+        res.status(200).json({ company, users, masterUsers });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR OS DADOS de uma empresa\r\n+router.patch('/:id', async (req, res) => {\r\n+    try {\r\n+        if (req.user.role !== 'SuperAdmin' && req.user.companyId !== req.params.id) {\r\n+            return res.status(403).json({ message: 'Acesso negado.' });\r\n+        }\r\n+\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const updateData = req.body;\r\n+\r\n+        const updatedCompany = await MasterCompany.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { $set: updateData },\r\n+            { new: true }\r\n+        );\r\n+\r\n+        if (!updatedCompany) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+\r\n+        res.status(200).json({\r\n+            message: \"Dados da empresa atualizados com sucesso!\",\r\n+            company: updatedCompany\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar dados da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR uma empresa inteira\r\n+router.delete('/:id', async (req, res) => {\r\n+    try {\r\n+        if (req.user.role !== 'SuperAdmin') {\r\n+            return res.status(403).json({ message: 'Acesso negado.' });\r\n+        }\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const companyId = req.params.id;\r\n+\r\n+        const companyToDelete = await MasterCompany.findById(companyId);\r\n+        if (!companyToDelete) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n+        }\r\n+        const dbName = companyToDelete.dbName;\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        await tenantDb.dropDatabase();\r\n+        \r\n+        await MasterUser.deleteMany({ company: companyId });\r\n+        await MasterCompany.findByIdAndDelete(companyId);\r\n+        \r\n+        res.status(200).json({ message: 'Empresa e todos os seus dados foram excluídos com sucesso!' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao excluir empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ADICIONAR tempo de assinatura\r\n+router.patch('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const { daysToAdd } = req.body;\r\n+        const days = parseInt(daysToAdd, 10);\r\n+        if (!days || days <= 0) {\r\n+            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n+        }\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+        const today = new Date();\r\n+        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n+            ? company.subscription.endDate\r\n+            : today;\r\n+        const newEndDate = new Date(currentEndDate);\r\n+        newEndDate.setDate(newEndDate.getDate() + days);\r\n+        company.subscription.status = 'active';\r\n+        company.subscription.endDate = newEndDate;\r\n+        await company.save();\r\n+        res.status(200).json({ message: `${days} dias de assinatura adicionados!`, company });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para REMOVER a assinatura\r\n+router.delete('/:id/subscription', async (req, res) => {\r\n+    if (req.user.role !== 'SuperAdmin') {\r\n+        return res.status(403).json({ message: 'Acesso negado.' });\r\n+    }\r\n+    try {\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const company = await MasterCompany.findById(req.params.id);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n+        }\r\n+        company.subscription.status = 'inactive';\r\n+        company.subscription.endDate = undefined;\r\n+        await company.save();\r\n+        res.status(200).json({ message: `Assinatura removida.`, company });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover assinatura:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para ATUALIZAR O CARGO (ROLE) de um usuário\r\n+router.patch('/:companyId/users/:userId/role', async (req, res) => {\r\n+    try {\r\n+        const { companyId, userId } = req.params;\r\n+        const { role } = req.body;\r\n+        if (!role || !['Proprietário', 'Gerente', 'Funcionário'].includes(role)) {\r\n+            return res.status(400).json({ message: 'Cargo inválido.' });\r\n+        }\r\n+        \r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        \r\n+        const masterUser = await MasterUser.findByIdAndUpdate(userId, { role }, { new: true });\r\n+        if (!masterUser) {\r\n+            return res.status(404).json({ message: 'Usuário não encontrado no registro mestre.' });\r\n+        }\r\n+\r\n+        const company = await MasterCompany.findById(companyId);\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+        \r\n+        await TenantUser.findOneAndUpdate({ username: masterUser.username }, { role });\r\n+\r\n+        res.status(200).json({ message: `Cargo do usuário ${masterUser.username} atualizado para ${role}!` });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar cargo do usuário:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// ROTA PÚBLICA DE CADASTRO (SELF-SERVICE)\r\n+router.post('/register-company', async (req, res) => {\r\n+    try {\r\n+        // Esta rota usa o masterDbMiddleware, então req.masterDb está disponível\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n+\r\n+        const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n+\r\n+        // Validações\r\n+        if (!nomeEmpresa || !cnpj || !email || !username || !password) {\r\n+            return res.status(400).json({ message: \"Todos os campos são obrigatórios.\" });\r\n+        }\r\n+        if (await MasterCompany.findOne({ cnpj })) {\r\n+            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n+        }\r\n+        if (await MasterUser.findOne({ email: ownerEmail })) {\r\n+            return res.status(400).json({ message: 'Este e-mail de proprietário já está em uso.' });\r\n+        }\r\n+\r\n+        const dbName = `empresa_${cnpj}`;\r\n+        const newMasterCompany = await MasterCompany.create({ nomeEmpresa, cnpj, dbName, email, telefoneWhatsapp });\r\n+\r\n+        const salt = await bcrypt.genSalt(10);\r\n+        const hashedPassword = await bcrypt.hash(password, salt);\r\n+\r\n+        await MasterUser.create({\r\n+            username: username,\r\n+            password: hashedPassword,\r\n+            role: 'Proprietário',\r\n+            company: newMasterCompany._id\r\n+        });\r\n+\r\n+        const tenantDb = await getTenantConnection(dbName);\r\n+        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n+\r\n+        await TenantUser.create({\r\n+            username,\r\n+            password: hashedPassword, \r\n+            role: 'Proprietário',\r\n+            email: ownerEmail\r\n+        });\r\n+\r\n+        res.status(201).json({ message: 'Empresa e usuário proprietário cadastrados com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro no cadastro self-service:\", error);\r\n+        res.status(500).json({ message: 'Erro interno no servidor durante o cadastro.' });\r\n+    }\r\n+});\r\n+\r\n+// Rota para EXCLUIR um usuário de uma empresa (SuperAdmin ou Proprietário)\r\n+router.delete('/:companyId/users/:userId', async (req, res) => {\r\n+    try {\r\n+        const { companyId, userId } = req.params;\r\n+        const { role: requesterRole, companyId: requesterCompanyId } = req.user;\r\n+\r\n+        // Modelos do banco Mestre\r\n+        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n+        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema); // Usa o schema importado\r\n+\r\n+        // 1. Verificação de Autorização:\r\n+        // - Apenas SuperAdmin pode excluir qualquer usuário de qualquer empresa.\r\n+        // - Proprietário pode excluir usuários da SUA PRÓPRIA empresa, exceto a si mesmo.\r\n+        if (requesterRole !== 'SuperAdmin') {\r\n+            if (requesterRole === 'Proprietário' && requesterCompanyId.toString() === companyId) {\r\n+                // Proprietário tentando excluir usuário da própria empresa\r\n+                const userToDelete = await MasterUser.findById(userId);\r\n+                if (!userToDelete) {\r\n+                    return res.status(404).json({ message: 'Usuário não encontrado.' });\r\n+                }\r\n+                if (userToDelete.role === 'Proprietário') {\r\n+                    // Proprietário não pode excluir outro proprietário (para evitar ficar sem acesso)\r\n+                    // ou a si mesmo (se for o único proprietário).\r\n+                    // Esta lógica pode ser mais complexa se houver vários proprietários.\r\n+                    return res.status(403).json({ message: 'Proprietários não podem excluir outros proprietários ou a si mesmos.' });\r\n+                }\r\n+            } else {\r\n+                return res.status(403).json({ message: 'Acesso negado. Você não tem permissão para remover usuários de outras empresas.' });\r\n+            }\r\n+        }\r\n+\r\n+        // 2. Encontra a empresa no banco Mestre para obter o nome do seu DB Tenant\r\n+        const company = await MasterCompany.findById(companyId);\r\n+        if (!company) {\r\n+            return res.status(404).json({ message: \"Empresa não encontrada no registro mestre.\" });\r\n+        }\r\n+\r\n+        // 3. Exclui o usuário do banco Mestre\r\n+        const masterUserDeleted = await MasterUser.findByIdAndDelete(userId);\r\n+        if (!masterUserDeleted) {\r\n+            return res.status(404).json({ message: 'Usuário não encontrado no registro mestre para exclusão.' });\r\n+        }\r\n+        console.log(`[COMPANY ROUTE] Usuário ${masterUserDeleted.username} (${masterUserDeleted._id}) excluído do Master DB.`);\r\n+\r\n+        // 4. Exclui o usuário do banco de dados da empresa (Tenant)\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n+        const TenantUser = tenantDb.model('User', UserSchema); // Usa o schema importado\r\n+\r\n+        const tenantUserDeleted = await TenantUser.findOneAndDelete({ username: masterUserDeleted.username }); // Exclui pelo username\r\n+        if (tenantUserDeleted) {\r\n+            console.log(`[COMPANY ROUTE] Usuário ${tenantUserDeleted.username} (${tenantUserDeleted._id}) excluído do DB do tenant ${company.dbName}.`);\r\n+        } else {\r\n+            console.log(`[COMPANY ROUTE] Aviso: Usuário ${masterUserDeleted.username} não encontrado no DB do tenant ${company.dbName} para exclusão (já havia sido removido?).`);\r\n+        }\r\n+\r\n+        res.status(200).json({ message: 'Usuário removido com sucesso!' });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao remover usuário da empresa:\", error);\r\n+        res.status(500).json({ message: 'Erro interno do servidor ao remover o usuário.' });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753738107250,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,8 +38,9 @@\n         const hashedPassword = await bcrypt.hash(ownerPassword, salt);\r\n         \r\n         await MasterUser.create({\r\n             username: ownerUsername,\r\n+            email: email,\r\n             password: hashedPassword,\r\n             role: 'Proprietário',\r\n             company: newMasterCompany._id\r\n         });\r\n@@ -365,416 +366,5 @@\n     }\r\n });\r\n \r\n \r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const mongoose = require('mongoose');\r\n-\r\n-// CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-const UserSchema = require('../models/User').schema;\r\n-\r\n-// Importamos a função de conexão do nosso arquivo de configuração\r\n-const { getTenantConnection } = require('../config/db');\r\n-\r\n-\r\n-// ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin)\r\n-router.post('/', async (req, res) => {\r\n-    // A proteção já é garantida pelo middleware no server.js\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-\r\n-        // Dados vêm do modal de admin\r\n-        const { nomeEmpresa, cnpj, ownerUsername, ownerPassword } = req.body;\r\n-\r\n-        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n-        if (await MasterCompany.findOne({ cnpj: cleanCnpj })) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-\r\n-        const dbName = `empresa_${cleanCnpj}`;\r\n-        const newMasterCompany = await MasterCompany.create({ nomeEmpresa, cnpj: cleanCnpj, dbName });\r\n-\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedPassword = await bcrypt.hash(ownerPassword, salt);\r\n-\r\n-        await MasterUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedPassword,\r\n-            role: 'Proprietário',\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        await TenantUser.create({\r\n-            username: ownerUsername,\r\n-            password: hashedPassword, \r\n-            role: 'Proprietário',\r\n-            email: 'proprietario@email.com' // Pode ser pego do formulário no futuro\r\n-        });\r\n-\r\n-        res.status(201).json({ \r\n-            message: 'Empresa e usuário proprietário criados com sucesso!',\r\n-            company: newMasterCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao criar nova empresa (admin):\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao criar empresa.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n-// Rota para LER TODAS as empresas (operando no banco Mestre)\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const companies = await MasterCompany.find({});\r\n-        res.status(200).json(companies);\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao listar empresas:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para LER os detalhes de UMA empresa e seus usuários\r\n-router.get('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-\r\n-        // 1. Busca a empresa no banco Mestre\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-\r\n-        // 2. Conecta-se ao banco de dados da empresa para buscar os usuários dela (pode ser útil para outras infos)\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-        const users = await TenantUser.find({}).select('-password');\r\n-\r\n-        // 3. NOVO E CRUCIAL: Busca também os usuários no banco Mestre\r\n-        const masterUsers = await MasterUser.find({ company: req.params.id }).select('-password');\r\n-\r\n-        // 4. Retorna os dados combinados\r\n-        res.status(200).json({ company, users, masterUsers }); // Adiciona masterUsers à resposta\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar detalhes da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ATUALIZAR UMA EMPRESA (nome, etc., no banco Mestre)\r\n-router.patch('/:id', async (req, res) => {\r\n-    try {\r\n-        // Verificação de Segurança: Garante que um Proprietário só pode editar sua própria empresa.\r\n-        // O SuperAdmin pode editar qualquer uma.\r\n-        if (req.user.role !== 'SuperAdmin' && req.user.companyId !== req.params.id) {\r\n-            return res.status(403).json({ message: 'Acesso negado. Você só pode editar sua própria empresa.' });\r\n-        }\r\n-\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-\r\n-        // Pega os dados que o frontend enviou para atualização\r\n-        const updateData = req.body;\r\n-\r\n-        const updatedCompany = await MasterCompany.findByIdAndUpdate(\r\n-            req.params.id,\r\n-            { $set: updateData }, // Atualiza a empresa com os novos dados\r\n-            { new: true }         // Opção para retornar o documento já atualizado\r\n-        );\r\n-\r\n-        if (!updatedCompany) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        res.status(200).json({\r\n-            message: \"Dados da empresa atualizados com sucesso!\",\r\n-            company: updatedCompany\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao atualizar dados da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR uma empresa inteira (operação complexa e destrutiva)\r\n-router.delete('/:id', async (req, res) => {\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema);\r\n-        const companyId = req.params.id;\r\n-\r\n-        // 1. Encontra a empresa no banco Mestre para obter o nome do seu banco de dados\r\n-        const companyToDelete = await MasterCompany.findById(companyId);\r\n-        if (!companyToDelete) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n-        }\r\n-        const dbName = companyToDelete.dbName;\r\n-\r\n-        // 2. Apaga o banco de dados inteiro da empresa\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        await tenantDb.dropDatabase();\r\n-        console.log(`Banco de dados do tenant ${dbName} foi apagado.`);\r\n-\r\n-        // 3. Exclui todos os usuários associados a essa empresa no banco Mestre\r\n-        await MasterUser.deleteMany({ company: companyId });\r\n-\r\n-        // 4. Exclui a própria empresa do banco Mestre\r\n-        await MasterCompany.findByIdAndDelete(companyId);\r\n-        \r\n-        res.status(200).json({ message: 'Empresa, seu banco de dados e todos os seus dados foram excluídos com sucesso!' });\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao excluir empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para ADICIONAR tempo de assinatura a uma empresa (Apenas SuperAdmin)\r\n-router.patch('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const { daysToAdd } = req.body;\r\n-        const days = parseInt(daysToAdd, 10);\r\n-\r\n-        if (!days || days <= 0) {\r\n-            return res.status(400).json({ message: 'Forneça um número de dias válido.' });\r\n-        }\r\n-\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        const today = new Date();\r\n-        // Se a assinatura estiver vencida ou inativa, começa a contar de hoje.\r\n-        // Se ainda estiver ativa, adiciona os dias à data de expiração existente.\r\n-        const currentEndDate = company.subscription.endDate && company.subscription.endDate > today\r\n-            ? company.subscription.endDate\r\n-            : today;\r\n-\r\n-        const newEndDate = new Date(currentEndDate);\r\n-        newEndDate.setDate(newEndDate.getDate() + days);\r\n-\r\n-        company.subscription.status = 'active';\r\n-        company.subscription.endDate = newEndDate;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({ \r\n-            message: `${days} dias de assinatura adicionados com sucesso!`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao adicionar tempo de assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para REMOVER a assinatura de uma empresa (Apenas SuperAdmin)\r\n-router.delete('/:id/subscription', async (req, res) => {\r\n-    if (req.user.role !== 'SuperAdmin') {\r\n-        return res.status(403).json({ message: 'Acesso negado.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const company = await MasterCompany.findById(req.params.id);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada.' });\r\n-        }\r\n-\r\n-        // Reseta a assinatura para o estado padrão\r\n-        company.subscription.status = 'inactive';\r\n-        company.subscription.endDate = undefined;\r\n-\r\n-        await company.save();\r\n-\r\n-        res.status(200).json({\r\n-            message: `Assinatura da empresa ${company.nomeEmpresa} foi removida.`,\r\n-            company: company // Retorna a empresa atualizada\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao remover assinatura:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-router.patch('/:companyId/users/:userId/role', async (req, res) => {\r\n-    try {\r\n-        // Apenas o SuperAdmin (ou futuramente o Proprietário) pode alterar cargos\r\n-        if (req.user.role !== 'SuperAdmin') {\r\n-            // Adicionar lógica aqui se o Proprietário também puder alterar\r\n-            // return res.status(403).json({ message: 'Acesso negado.' });\r\n-        }\r\n-\r\n-        const { companyId, userId } = req.params;\r\n-        const { role } = req.body;\r\n-\r\n-        if (!role || !['Gerente', 'Funcionário'].includes(role)) {\r\n-            return res.status(400).json({ message: 'Cargo inválido.' });\r\n-        }\r\n-\r\n-        // Modelos do banco Mestre\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-\r\n-        // 1. Atualiza o cargo no banco MESTRE\r\n-        // Usamos 'userId' que é o ID do MasterUser\r\n-        const masterUser = await MasterUser.findByIdAndUpdate(userId, { role }, { new: true });\r\n-        if (!masterUser) {\r\n-            return res.status(404).json({ message: 'Usuário não encontrado no registro mestre.' });\r\n-        }\r\n-\r\n-        // 2. Atualiza o cargo no banco da EMPRESA\r\n-        const company = await MasterCompany.findById(companyId);\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        // Encontramos o usuário no banco da empresa pelo username, que é consistente\r\n-        await TenantUser.findOneAndUpdate({ username: masterUser.username }, { role });\r\n-\r\n-        res.status(200).json({ message: `Cargo do usuário ${masterUser.username} atualizado para ${role}!` });\r\n-\r\n-    } catch (error)\r\n-    {\r\n-        console.error(\"Erro ao atualizar cargo do usuário:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// ROTA PÚBLICA DE CADASTRO (SELF-SERVICE)\r\n-router.post('/register-company', async (req, res) => {\r\n-    try {\r\n-        // Esta rota usa o masterDbMiddleware, então req.masterDb está disponível\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', require('../models/MasterUser').schema);\r\n-\r\n-        const { nomeEmpresa, cnpj, email, telefoneWhatsapp, username, ownerEmail, password } = req.body;\r\n-\r\n-        // Validações\r\n-        if (!nomeEmpresa || !cnpj || !email || !username || !password) {\r\n-            return res.status(400).json({ message: \"Todos os campos são obrigatórios.\" });\r\n-        }\r\n-        if (await MasterCompany.findOne({ cnpj })) {\r\n-            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n-        }\r\n-        if (await MasterUser.findOne({ email: ownerEmail })) {\r\n-            return res.status(400).json({ message: 'Este e-mail de proprietário já está em uso.' });\r\n-        }\r\n-\r\n-        const dbName = `empresa_${cnpj}`;\r\n-        const newMasterCompany = await MasterCompany.create({ nomeEmpresa, cnpj, dbName, email, telefoneWhatsapp });\r\n-\r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedPassword = await bcrypt.hash(password, salt);\r\n-\r\n-        await MasterUser.create({\r\n-            username: username,\r\n-            password: hashedPassword,\r\n-            role: 'Proprietário',\r\n-            company: newMasterCompany._id\r\n-        });\r\n-\r\n-        const tenantDb = await getTenantConnection(dbName);\r\n-        const TenantUser = tenantDb.model('User', require('../models/User').schema);\r\n-\r\n-        await TenantUser.create({\r\n-            username,\r\n-            password: hashedPassword, \r\n-            role: 'Proprietário',\r\n-            email: ownerEmail\r\n-        });\r\n-\r\n-        res.status(201).json({ message: 'Empresa e usuário proprietário cadastrados com sucesso!' });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro no cadastro self-service:\", error);\r\n-        res.status(500).json({ message: 'Erro interno no servidor durante o cadastro.' });\r\n-    }\r\n-});\r\n-\r\n-// Rota para EXCLUIR um usuário de uma empresa (SuperAdmin ou Proprietário)\r\n-router.delete('/:companyId/users/:userId', async (req, res) => {\r\n-    try {\r\n-        const { companyId, userId } = req.params;\r\n-        const { role: requesterRole, companyId: requesterCompanyId } = req.user;\r\n-\r\n-        // Modelos do banco Mestre\r\n-        const MasterCompany = req.masterDb.model('MasterCompany', require('../models/MasterCompany').schema);\r\n-        const MasterUser = req.masterDb.model('MasterUser', MasterUserSchema); // Usa o schema importado\r\n-\r\n-        // 1. Verificação de Autorização:\r\n-        // - Apenas SuperAdmin pode excluir qualquer usuário de qualquer empresa.\r\n-        // - Proprietário pode excluir usuários da SUA PRÓPRIA empresa, exceto a si mesmo.\r\n-        if (requesterRole !== 'SuperAdmin') {\r\n-            if (requesterRole === 'Proprietário' && requesterCompanyId.toString() === companyId) {\r\n-                // Proprietário tentando excluir usuário da própria empresa\r\n-                const userToDelete = await MasterUser.findById(userId);\r\n-                if (!userToDelete) {\r\n-                    return res.status(404).json({ message: 'Usuário não encontrado.' });\r\n-                }\r\n-                if (userToDelete.role === 'Proprietário') {\r\n-                    // Proprietário não pode excluir outro proprietário (para evitar ficar sem acesso)\r\n-                    // ou a si mesmo (se for o único proprietário).\r\n-                    // Esta lógica pode ser mais complexa se houver vários proprietários.\r\n-                    return res.status(403).json({ message: 'Proprietários não podem excluir outros proprietários ou a si mesmos.' });\r\n-                }\r\n-            } else {\r\n-                return res.status(403).json({ message: 'Acesso negado. Você não tem permissão para remover usuários de outras empresas.' });\r\n-            }\r\n-        }\r\n-\r\n-        // 2. Encontra a empresa no banco Mestre para obter o nome do seu DB Tenant\r\n-        const company = await MasterCompany.findById(companyId);\r\n-        if (!company) {\r\n-            return res.status(404).json({ message: \"Empresa não encontrada no registro mestre.\" });\r\n-        }\r\n-\r\n-        // 3. Exclui o usuário do banco Mestre\r\n-        const masterUserDeleted = await MasterUser.findByIdAndDelete(userId);\r\n-        if (!masterUserDeleted) {\r\n-            return res.status(404).json({ message: 'Usuário não encontrado no registro mestre para exclusão.' });\r\n-        }\r\n-        console.log(`[COMPANY ROUTE] Usuário ${masterUserDeleted.username} (${masterUserDeleted._id}) excluído do Master DB.`);\r\n-\r\n-        // 4. Exclui o usuário do banco de dados da empresa (Tenant)\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        const TenantUser = tenantDb.model('User', UserSchema); // Usa o schema importado\r\n-\r\n-        const tenantUserDeleted = await TenantUser.findOneAndDelete({ username: masterUserDeleted.username }); // Exclui pelo username\r\n-        if (tenantUserDeleted) {\r\n-            console.log(`[COMPANY ROUTE] Usuário ${tenantUserDeleted.username} (${tenantUserDeleted._id}) excluído do DB do tenant ${company.dbName}.`);\r\n-        } else {\r\n-            console.log(`[COMPANY ROUTE] Aviso: Usuário ${masterUserDeleted.username} não encontrado no DB do tenant ${company.dbName} para exclusão (já havia sido removido?).`);\r\n-        }\r\n-\r\n-        res.status(200).json({ message: 'Usuário removido com sucesso!' });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao remover usuário da empresa:\", error);\r\n-        res.status(500).json({ message: 'Erro interno do servidor ao remover o usuário.' });\r\n-    }\r\n-});\r\n-\r\n-\r\n module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753812542145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n \r\n \r\n // ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin, via painel)\r\n // Corresponde a POST /api/companies/\r\n-router.post('/', async (req, res) => {\r\n+router.post('/register', async (req, res) => {\r\n     // A proteção já é garantida pelo middleware no server.js\r\n     if (req.user.role !== 'SuperAdmin') {\r\n         return res.status(403).json({ message: 'Acesso negado.' });\r\n     }\r\n"
                },
                {
                    "date": 1753812610541,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,9 @@\n \r\n \r\n // ROTA DE CRIAÇÃO DE EMPRESA (Apenas SuperAdmin, via painel)\r\n // Corresponde a POST /api/companies/\r\n-router.post('/register', async (req, res) => {\r\n+router.post('/', async (req, res) => {\r\n     // A proteção já é garantida pelo middleware no server.js\r\n     if (req.user.role !== 'SuperAdmin') {\r\n         return res.status(403).json({ message: 'Acesso negado.' });\r\n     }\r\n"
                },
                {
                    "date": 1754505421913,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,11 +3,11 @@\n const bcrypt = require('bcryptjs');\r\n const mongoose = require('mongoose');\r\n \r\n // CORREÇÃO: Importamos os ESQUEMAS, e não os modelos compilados\r\n-const MasterCompanySchema = require('../models/MasterCompany').schema;\r\n-const MasterUserSchema = require('../models/MasterUser').schema;\r\n-const UserSchema = require('../models/User').schema;\r\n+const { schema: MasterCompanySchema } = require('../models/MasterCompany');\r\n+const { schema: MasterUserSchema } = require('../models/MasterUser');\r\n+const { schema: UserSchema } = require('../models/User');\r\n \r\n // Importamos a função de conexão do nosso arquivo de configuração\r\n const { getTenantConnection } = require('../config/db');\r\n \r\n"
                }
            ],
            "date": 1752269540606,
            "name": "Commit-0",
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst bcrypt = require('bcryptjs');\r\n\r\n// MUDANÇA: Importamos todos os nossos novos modelos\r\nconst Company = require('../models/Company');\r\nconst User = require('../models/User');\r\nconst Boleto = require('../models/Boleto');\r\n\r\nconst { protect } = require('../middleware/authMiddleware');\r\n\r\n// Rota para LER TODAS as empresas (sem grandes mudanças)\r\nrouter.get('/', protect, async (req, res) => {\r\n    try {\r\n        // ANTES: O select já era bom, mas agora não há senhas de usuário para remover aqui.\r\n        // AGORA: A lógica permanece, mas o modelo Company é mais simples.\r\n        const companies = await Company.find({});\r\n        res.status(200).json(companies);\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\n// Rota para LER os detalhes de UMA empresa\r\nrouter.get('/:id', protect, async (req, res) => {\r\n    try {\r\n        const company = await Company.findById(req.params.id);\r\n        if (!company) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n\r\n        // MUDANÇA: Para ser mais útil, agora também buscamos os usuários associados a esta empresa.\r\n        const users = await User.find({ company: req.params.id }).select('-password');\r\n        \r\n        res.status(200).json({ company, users });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\n// Rota para CRIAR uma nova empresa\r\n// GRANDE MUDANÇA: Agora também cria o usuário 'Proprietário'.\r\nrouter.post('/register', protect, async (req, res) => {\r\n    try {\r\n        // MUDANÇA: A rota agora espera os dados do proprietário junto com os da empresa.\r\n        // O frontend (painel de admin) precisará ser atualizado para enviar estes dados.\r\n        const { nomeEmpresa, cnpj, senhaEmpresa, ownerUsername, ownerPassword } = req.body;\r\n\r\n        if (!nomeEmpresa || !cnpj || !senhaEmpresa || !ownerUsername || !ownerPassword) {\r\n            return res.status(400).json({ message: 'Todos os campos são obrigatórios, incluindo os do usuário proprietário.' });\r\n        }\r\n        \r\n        const cleanCnpj = cnpj.replace(/\\D/g, '');\r\n        const existingCompany = await Company.findOne({ cnpj: cleanCnpj });\r\n        if (existingCompany) {\r\n            return res.status(400).json({ message: 'Este CNPJ já está cadastrado.' });\r\n        }\r\n        \r\n        const salt = await bcrypt.genSalt(10);\r\n        const hashedCompanyPassword = await bcrypt.hash(senhaEmpresa, salt);\r\n\r\n        // 1. Criamos a empresa\r\n        const newCompany = new Company({\r\n            nomeEmpresa,\r\n            cnpj: cleanCnpj,\r\n            senhaEmpresa: hashedCompanyPassword,\r\n        });\r\n        const savedCompany = await newCompany.save();\r\n\r\n        // 2. Criamos o usuário 'Proprietário' associado a ela\r\n        const hashedOwnerPassword = await bcrypt.hash(ownerPassword, salt);\r\n        await User.create({\r\n            username: ownerUsername,\r\n            password: hashedOwnerPassword,\r\n            role: 'Proprietário',\r\n            company: savedCompany._id // Ligação vital\r\n        });\r\n\r\n        res.status(201).json({ \r\n            message: 'Empresa e usuário proprietário cadastrados com sucesso!',\r\n            company: { _id: savedCompany._id, nomeEmpresa: savedCompany.nomeEmpresa, cnpj: savedCompany.cnpj }\r\n        });\r\n    } catch (error) {\r\n        // Se algo der errado, é uma boa prática remover a empresa que pode ter sido criada.\r\n        if (error.code === 11000) { // Erro de duplicado no usuário\r\n             await Company.deleteOne({ cnpj: req.body.cnpj.replace(/\\D/g, '') });\r\n             return res.status(400).json({ message: 'Este nome de usuário para proprietário já existe.' });\r\n        }\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\n\r\n// Rota para ATUALIZAR O PAPEL (ROLE) de um usuário\r\n// MUDANÇA: Lógica muito mais simples e direta.\r\nrouter.patch('/:companyId/users/:userId/role', protect, async (req, res) => {\r\n    try {\r\n        const { userId } = req.params;\r\n        const { role } = req.body;\r\n\r\n        if (!['Proprietário', 'Gerente', 'Funcionário'].includes(role)) {\r\n            return res.status(400).json({ message: 'Papel (Role) inválido.' });\r\n        }\r\n        \r\n        // ANTES: Procurávamos o usuário dentro da empresa.\r\n        // AGORA: Atualizamos o usuário diretamente na coleção 'User'.\r\n        const updatedUser = await User.findByIdAndUpdate(userId, { role }, { new: true });\r\n\r\n        if (!updatedUser) return res.status(404).json({ message: \"Usuário não encontrado.\" });\r\n\r\n        res.status(200).json({ message: `Papel do usuário ${updatedUser.username} atualizado para ${role}!` });\r\n\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\n// Rota para REMOVER um usuário de uma empresa\r\n// MUDANÇA: Agora também remove os boletos do usuário.\r\nrouter.delete('/:companyId/users/:userId', protect, async (req, res) => {\r\n    try {\r\n        const { userId } = req.params;\r\n        \r\n        // 1. Removemos todos os boletos que pertencem a este usuário.\r\n        await Boleto.deleteMany({ user: userId });\r\n        \r\n        // 2. Removemos o usuário.\r\n        const deletedUser = await User.findByIdAndDelete(userId);\r\n\r\n        if (!deletedUser) return res.status(404).json({ message: \"Usuário não encontrado.\" });\r\n\r\n        res.status(200).json({ message: 'Usuário e todos os seus boletos foram removidos com sucesso!' });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\n// Rota para EXCLUIR uma empresa inteira\r\n// MUDANÇA: Agora faz uma \"limpeza em cascata\".\r\nrouter.delete('/:id', protect, async (req, res) => {\r\n    try {\r\n        const companyId = req.params.id;\r\n\r\n        // 1. Excluímos a empresa.\r\n        const deletedCompany = await Company.findByIdAndDelete(companyId);\r\n        if (!deletedCompany) return res.status(404).json({ message: \"Empresa não encontrada.\" });\r\n        \r\n        // 2. Excluímos todos os usuários associados a essa empresa.\r\n        await User.deleteMany({ company: companyId });\r\n\r\n        // 3. Excluímos todos os boletos associados a essa empresa.\r\n        await Boleto.deleteMany({ company: companyId });\r\n\r\n        res.status(200).json({ message: 'Empresa, seus usuários e boletos foram excluídos com sucesso!' });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro interno do servidor.' });\r\n    }\r\n});\r\n\r\n\r\nmodule.exports = router;"
        }
    ]
}