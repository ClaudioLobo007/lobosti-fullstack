{
    "sourceFile": "Servidor/server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 69,
            "patches": [
                {
                    "date": 1752253945740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752345836427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,53 @@\n // 11. Importar e usar as rotas de AdminMaster\r\n const adminRoutes = require('./routes/admin');\r\n app.use('/api/admin', adminRoutes);\r\n \r\n-// 12. Define a porta e inicia o servidor\r\n+// 12. Importa e usa o Bravo emailService\r\n+const cron = require('node-cron');\r\n+const { sendOverdueReportEmail } = require('./services/emailService');\r\n+const Company = require('./models/Company'); // Precisamos do modelo Company\r\n+const Boleto = require('./models/Boleto');   // E do modelo Boleto\r\n+\r\n+// Agenda a tarefa para rodar todo dia às 9h da manhã\r\n+// A expressão cron '0 9 * * *' significa: 0 minutos, 9 horas, todos os dias, todos os meses, todos os dias da semana.\r\n+cron.schedule('0 9 * * *', async () => {\r\n+    console.log('Executando verificação diária de boletos vencidos...');\r\n+\r\n+    try {\r\n+        const today = new Date();\r\n+        today.setHours(0, 0, 0, 0);\r\n+\r\n+        const companies = await Company.find({ email: { $ne: '' } }); // Pega todas as empresas que têm e-mail cadastrado\r\n+\r\n+        for (const company of companies) {\r\n+            const allBoletos = await Boleto.find({ company: company._id });\r\n+            let overdueCount = 0;\r\n+\r\n+            for (const boleto of allBoletos) {\r\n+                const overdueParcels = boleto.parcels.filter(parcel => {\r\n+                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n+                    return !parcel.paid && dueDate < today;\r\n+                });\r\n+                overdueCount += overdueParcels.length;\r\n+            }\r\n+\r\n+            // Se a empresa tiver boletos vencidos, envia o e-mail\r\n+            if (overdueCount > 0) {\r\n+                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n+            }\r\n+        }\r\n+        console.log('Verificação diária concluída.');\r\n+    } catch (error) {\r\n+        console.error('Erro durante a execução da tarefa agendada:', error);\r\n+    }\r\n+}, {\r\n+    scheduled: true,\r\n+    timezone: \"America/Sao_Paulo\"\r\n+});\r\n+\r\n+// 13. Define a porta e inicia o servidor\r\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n     console.log(`Servidor rodando na porta ${PORT}`);\r\n });\r\n+\r\n"
                },
                {
                    "date": 1752346450522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,49 +46,27 @@\n // 11. Importar e usar as rotas de AdminMaster\r\n const adminRoutes = require('./routes/admin');\r\n app.use('/api/admin', adminRoutes);\r\n \r\n-// 12. Importa e usa o Bravo emailService\r\n-const cron = require('node-cron');\r\n+// 12. emailService\r\n+// Importa a nossa nova função de envio de e-mail\r\n const { sendOverdueReportEmail } = require('./services/emailService');\r\n-const Company = require('./models/Company'); // Precisamos do modelo Company\r\n-const Boleto = require('./models/Boleto');   // E do modelo Boleto\r\n \r\n-// Agenda a tarefa para rodar todo dia às 9h da manhã\r\n-// A expressão cron '0 9 * * *' significa: 0 minutos, 9 horas, todos os dias, todos os meses, todos os dias da semana.\r\n-cron.schedule('0 9 * * *', async () => {\r\n-    console.log('Executando verificação diária de boletos vencidos...');\r\n-\r\n+// Rota temporária para testar o envio de e-mail\r\n+app.get('/api/test-email', async (req, res) => {\r\n+    console.log(\"Recebida requisição para testar e-mail...\");\r\n     try {\r\n-        const today = new Date();\r\n-        today.setHours(0, 0, 0, 0);\r\n+        // Preencha com um e-mail seu para receber o teste\r\n+        const testRecipientEmail = \"lobosti@outlook.com\";\r\n \r\n-        const companies = await Company.find({ email: { $ne: '' } }); // Pega todas as empresas que têm e-mail cadastrado\r\n+        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n \r\n-        for (const company of companies) {\r\n-            const allBoletos = await Boleto.find({ company: company._id });\r\n-            let overdueCount = 0;\r\n+        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n \r\n-            for (const boleto of allBoletos) {\r\n-                const overdueParcels = boleto.parcels.filter(parcel => {\r\n-                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n-                    return !parcel.paid && dueDate < today;\r\n-                });\r\n-                overdueCount += overdueParcels.length;\r\n-            }\r\n-\r\n-            // Se a empresa tiver boletos vencidos, envia o e-mail\r\n-            if (overdueCount > 0) {\r\n-                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n-            }\r\n-        }\r\n-        console.log('Verificação diária concluída.');\r\n     } catch (error) {\r\n-        console.error('Erro durante a execução da tarefa agendada:', error);\r\n+        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n+        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n     }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\"\r\n });\r\n \r\n // 13. Define a porta e inicia o servidor\r\n const PORT = process.env.PORT || 5000;\r\n"
                },
                {
                    "date": 1752348361677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,104 @@\n+// 1. Carrega as variáveis de ambiente do arquivo .env\r\n+require('dotenv').config();\r\n+\r\n+// 2. Importa as dependências\r\n+const express = require('express');\r\n+const mongoose = require('mongoose');\r\n+const cors = require('cors');\r\n+\r\n+// 3. Inicializa o servidor express\r\n+const app = express();\r\n+\r\n+// 4. Middlewares essenciais\r\n+app.use(cors());\r\n+app.use(express.json());\r\n+\r\n+// 5. Conexão com o Banco de Dados MongoDB\r\n+const dbURI = process.env.MONGODB_URI;\r\n+mongoose.connect(dbURI)\r\n+    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n+    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n+\r\n+\r\n+// --- ROTAS DA API ---\r\n+\r\n+// 6. Rota principal de \"saúde\" da API\r\n+app.get('/', (req, res) => {\r\n+    res.send('API do Organizador de Boletos está no ar!');\r\n+});\r\n+\r\n+// 7. Importar e usar as rotas de autenticação\r\n+const authRoutes = require('./routes/auth');\r\n+app.use('/api/auth', authRoutes);\r\n+\r\n+// 8. Importar e usar as rotas de empresa\r\n+const companyRoutes = require('./routes/company');\r\n+app.use('/api/companies', companyRoutes);\r\n+\r\n+// 9. Importar e usar as rotas de boletos\r\n+const boletoRoutes = require('./routes/boletos');\r\n+app.use('/api/boletos', boletoRoutes);\r\n+\r\n+// 10. Importar e usar as rotas de permissões (NOVO)\r\n+const permissionsRoutes = require('./routes/permissions');\r\n+app.use('/api/permissions', permissionsRoutes);\r\n+\r\n+// 11. Importar e usar as rotas de AdminMaster\r\n+const adminRoutes = require('./routes/admin');\r\n+app.use('/api/admin', adminRoutes);\r\n+\r\n+// 12. emailService\r\n+// Importa a nossa nova função de envio de e-mail\r\n+const { sendOverdueReportEmail } = require('./services/emailService');\r\n+\r\n+// Rota definitiva para o envio de e-mail\r\n+const cron = require('node-cron');\r\n+const { sendOverdueReportEmail } = require('./services/emailService');\r\n+const Company = require('./models/Company');\r\n+const Boleto = require('./models/Boleto');\r\n+\r\n+cron.schedule('0 19 * * *', async () => {\r\n+    console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n+    \r\n+    try {\r\n+        const today = new Date();\r\n+        today.setHours(0, 0, 0, 0);\r\n+\r\n+        // MUDANÇA 2: Esta query já estava correta, mas vamos reforçar.\r\n+        // Ela busca apenas empresas onde o campo 'email' não é nulo e não é uma string vazia.\r\n+        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n+\r\n+        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n+\r\n+        for (const company of companies) {\r\n+            const allBoletos = await Boleto.find({ company: company._id });\r\n+            let overdueCount = 0;\r\n+\r\n+            for (const boleto of allBoletos) {\r\n+                const overdueParcels = boleto.parcels.filter(parcel => {\r\n+                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n+                    return !parcel.paid && dueDate < today;\r\n+                });\r\n+                overdueCount += overdueParcels.length;\r\n+            }\r\n+\r\n+            if (overdueCount > 0) {\r\n+                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n+                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n+            }\r\n+        }\r\n+        console.log('Verificação diária concluída.');\r\n+    } catch (error) {\r\n+        console.error('Erro durante a execução da tarefa agendada:', error);\r\n+    }\r\n+}, {\r\n+    scheduled: true,\r\n+    timezone: \"America/Sao_Paulo\"\r\n+});\r\n+\r\n+// 13. Define a porta e inicia o servidor\r\n+const PORT = process.env.PORT || 5000;\r\n+app.listen(PORT, () => {\r\n+    console.log(`Servidor rodando na porta ${PORT}`);\r\n+});\r\n+\r\n"
                },
                {
                    "date": 1752348532463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,121 @@\n+// 1. Carrega as variáveis de ambiente do arquivo .env\r\n+require('dotenv').config();\r\n+\r\n+// 2. Importa as dependências\r\n+const express = require('express');\r\n+const mongoose = require('mongoose');\r\n+const cors = require('cors');\r\n+\r\n+// 3. Inicializa o servidor express\r\n+const app = express();\r\n+\r\n+// 4. Middlewares essenciais\r\n+app.use(cors());\r\n+app.use(express.json());\r\n+\r\n+// 5. Conexão com o Banco de Dados MongoDB\r\n+const dbURI = process.env.MONGODB_URI;\r\n+mongoose.connect(dbURI)\r\n+    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n+    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n+\r\n+\r\n+// --- ROTAS DA API ---\r\n+\r\n+// 6. Rota principal de \"saúde\" da API\r\n+app.get('/', (req, res) => {\r\n+    res.send('API do Organizador de Boletos está no ar!');\r\n+});\r\n+\r\n+// 7. Importar e usar as rotas de autenticação\r\n+const authRoutes = require('./routes/auth');\r\n+app.use('/api/auth', authRoutes);\r\n+\r\n+// 8. Importar e usar as rotas de empresa\r\n+const companyRoutes = require('./routes/company');\r\n+app.use('/api/companies', companyRoutes);\r\n+\r\n+// 9. Importar e usar as rotas de boletos\r\n+const boletoRoutes = require('./routes/boletos');\r\n+app.use('/api/boletos', boletoRoutes);\r\n+\r\n+// 10. Importar e usar as rotas de permissões (NOVO)\r\n+const permissionsRoutes = require('./routes/permissions');\r\n+app.use('/api/permissions', permissionsRoutes);\r\n+\r\n+// 11. Importar e usar as rotas de AdminMaster\r\n+const adminRoutes = require('./routes/admin');\r\n+app.use('/api/admin', adminRoutes);\r\n+\r\n+// 12. emailService\r\n+// Importa a nossa nova função de envio de e-mail\r\n+const { sendOverdueReportEmail } = require('./services/emailService');\r\n+\r\n+// Rota temporária para testar o envio de e-mail\r\n+app.get('/api/test-email', async (req, res) => {\r\n+    console.log(\"Recebida requisição para testar e-mail...\");\r\n+    try {\r\n+        // Preencha com um e-mail seu para receber o teste\r\n+        const testRecipientEmail = \"lobosti@outlook.com\";\r\n+\r\n+        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n+\r\n+        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n+        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n+    }\r\n+});\r\n+\r\n+// // Rota definitiva para o envio de e-mail\r\n+const cron = require('node-cron');\r\n+const Company = require('./models/Company');\r\n+const Boleto = require('./models/Boleto');\r\n+\r\n+cron.schedule('0 19 * * *', async () => {\r\n+    console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n+    \r\n+    try {\r\n+        const today = new Date();\r\n+        today.setHours(0, 0, 0, 0);\r\n+\r\n+        // Busca apenas empresas que têm um e-mail cadastrado e válido.\r\n+        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n+\r\n+        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n+\r\n+        for (const company of companies) {\r\n+            const allBoletos = await Boleto.find({ company: company._id });\r\n+            let overdueCount = 0;\r\n+\r\n+            for (const boleto of allBoletos) {\r\n+                const overdueParcels = boleto.parcels.filter(parcel => {\r\n+                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n+                    return !parcel.paid && dueDate < today;\r\n+                });\r\n+                overdueCount += overdueParcels.length;\r\n+            }\r\n+\r\n+            // Se a empresa tiver boletos vencidos, envia o e-mail\r\n+            if (overdueCount > 0) {\r\n+                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n+                // A função sendOverdueReportEmail já está importada no seu arquivo\r\n+                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n+            }\r\n+        }\r\n+        console.log('Verificação diária concluída.');\r\n+    } catch (error) {\r\n+        console.error('Erro durante a execução da tarefa agendada:', error);\r\n+    }\r\n+}, {\r\n+    scheduled: true,\r\n+    timezone: \"America/Sao_Paulo\"\r\n+});\r\n+\r\n+// 13. Define a porta e inicia o servidor\r\n+const PORT = process.env.PORT || 5000;\r\n+app.listen(PORT, () => {\r\n+    console.log(`Servidor rodando na porta ${PORT}`);\r\n+});\r\n+\r\n"
                },
                {
                    "date": 1752349665413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,120 @@\n+// 1. Carrega as variáveis de ambiente do arquivo .env\r\n+require('dotenv').config();\r\n+\r\n+// 2. Importa as dependências\r\n+const express = require('express');\r\n+const mongoose = require('mongoose');\r\n+const cors = require('cors');\r\n+\r\n+// 3. Inicializa o servidor express\r\n+const app = express();\r\n+\r\n+// 4. Middlewares essenciais\r\n+app.use(cors());\r\n+app.use(express.json());\r\n+\r\n+// 5. Conexão com o Banco de Dados MongoDB\r\n+const dbURI = process.env.MONGODB_URI;\r\n+mongoose.connect(dbURI)\r\n+    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n+    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n+\r\n+\r\n+// --- ROTAS DA API ---\r\n+\r\n+// 6. Rota principal de \"saúde\" da API\r\n+app.get('/', (req, res) => {\r\n+    res.send('API do Organizador de Boletos está no ar!');\r\n+});\r\n+\r\n+// 7. Importar e usar as rotas de autenticação\r\n+const authRoutes = require('./routes/auth');\r\n+app.use('/api/auth', authRoutes);\r\n+\r\n+// 8. Importar e usar as rotas de empresa\r\n+const companyRoutes = require('./routes/company');\r\n+app.use('/api/companies', companyRoutes);\r\n+\r\n+// 9. Importar e usar as rotas de boletos\r\n+const boletoRoutes = require('./routes/boletos');\r\n+app.use('/api/boletos', boletoRoutes);\r\n+\r\n+// 10. Importar e usar as rotas de permissões (NOVO)\r\n+const permissionsRoutes = require('./routes/permissions');\r\n+app.use('/api/permissions', permissionsRoutes);\r\n+\r\n+// 11. Importar e usar as rotas de AdminMaster\r\n+const adminRoutes = require('./routes/admin');\r\n+app.use('/api/admin', adminRoutes);\r\n+\r\n+// 12. emailService\r\n+// Importa a nossa nova função de envio de e-mail\r\n+const { sendOverdueReportEmail } = require('./services/emailService');\r\n+\r\n+// Rota temporária para testar o envio de e-mail\r\n+app.get('/api/test-email', async (req, res) => {\r\n+    console.log(\"Recebida requisição para testar e-mail...\");\r\n+    try {\r\n+        // Preencha com um e-mail seu para receber o teste\r\n+        const testRecipientEmail = \"lobosti@outlook.com\";\r\n+\r\n+        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n+\r\n+        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n+        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n+    }\r\n+});\r\n+\r\n+// 13. Rota definitiva para o envio de e-mail\r\n+const cron = require('node-cron');\r\n+const Company = require('./models/Company');\r\n+const Boleto = require('./models/Boleto');\r\n+\r\n+cron.schedule('0 19 * * *', async () => {\r\n+    console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n+    \r\n+    try {\r\n+        const today = new Date();\r\n+        today.setHours(0, 0, 0, 0);\r\n+\r\n+        // Busca apenas empresas que têm um e-mail cadastrado e válido.\r\n+        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n+\r\n+        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n+\r\n+        for (const company of companies) {\r\n+            const allBoletos = await Boleto.find({ company: company._id });\r\n+            let overdueCount = 0;\r\n+\r\n+            for (const boleto of allBoletos) {\r\n+                const overdueParcels = boleto.parcels.filter(parcel => {\r\n+                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n+                    return !parcel.paid && dueDate < today;\r\n+                });\r\n+                overdueCount += overdueParcels.length;\r\n+            }\r\n+\r\n+            // Se a empresa tiver boletos vencidos, envia o e-mail\r\n+            if (overdueCount > 0) {\r\n+                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n+                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n+            }\r\n+        }\r\n+        console.log('Verificação diária concluída.');\r\n+    } catch (error) {\r\n+        console.error('Erro durante a execução da tarefa agendada:', error);\r\n+    }\r\n+}, {\r\n+    scheduled: true,\r\n+    timezone: \"America/Sao_Paulo\"\r\n+});\r\n+\r\n+// 14. Define a porta e inicia o servidor\r\n+const PORT = process.env.PORT || 5000;\r\n+app.listen(PORT, () => {\r\n+    console.log(`Servidor rodando na porta ${PORT}`);\r\n+});\r\n+\r\n"
                },
                {
                    "date": 1752349866872,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,120 @@\n+// 1. Carrega as variáveis de ambiente do arquivo .env\r\n+require('dotenv').config();\r\n+\r\n+// 2. Importa as dependências\r\n+const express = require('express');\r\n+const mongoose = require('mongoose');\r\n+const cors = require('cors');\r\n+\r\n+// 3. Inicializa o servidor express\r\n+const app = express();\r\n+\r\n+// 4. Middlewares essenciais\r\n+app.use(cors());\r\n+app.use(express.json());\r\n+\r\n+// 5. Conexão com o Banco de Dados MongoDB\r\n+const dbURI = process.env.MONGODB_URI;\r\n+mongoose.connect(dbURI)\r\n+    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n+    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n+\r\n+\r\n+// --- ROTAS DA API ---\r\n+\r\n+// 6. Rota principal de \"saúde\" da API\r\n+app.get('/', (req, res) => {\r\n+    res.send('API do Organizador de Boletos está no ar!');\r\n+});\r\n+\r\n+// 7. Importar e usar as rotas de autenticação\r\n+const authRoutes = require('./routes/auth');\r\n+app.use('/api/auth', authRoutes);\r\n+\r\n+// 8. Importar e usar as rotas de empresa\r\n+const companyRoutes = require('./routes/company');\r\n+app.use('/api/companies', companyRoutes);\r\n+\r\n+// 9. Importar e usar as rotas de boletos\r\n+const boletoRoutes = require('./routes/boletos');\r\n+app.use('/api/boletos', boletoRoutes);\r\n+\r\n+// 10. Importar e usar as rotas de permissões (NOVO)\r\n+const permissionsRoutes = require('./routes/permissions');\r\n+app.use('/api/permissions', permissionsRoutes);\r\n+\r\n+// 11. Importar e usar as rotas de AdminMaster\r\n+const adminRoutes = require('./routes/admin');\r\n+app.use('/api/admin', adminRoutes);\r\n+\r\n+// 12. emailService\r\n+// Importa a nossa nova função de envio de e-mail\r\n+const { sendOverdueReportEmail } = require('./services/emailService');\r\n+\r\n+// Rota temporária para testar o envio de e-mail\r\n+app.get('/api/test-email', async (req, res) => {\r\n+    console.log(\"Recebida requisição para testar e-mail...\");\r\n+    try {\r\n+        // Preencha com um e-mail seu para receber o teste\r\n+        const testRecipientEmail = \"lobosti@outlook.com\";\r\n+\r\n+        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n+\r\n+        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n+        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n+    }\r\n+});\r\n+\r\n+// 13. Rota definitiva para o envio de e-mail\r\n+const cron = require('node-cron');\r\n+const Company = require('./models/Company');\r\n+const Boleto = require('./models/Boleto');\r\n+\r\n+cron.schedule('0 19 * * *', async () => {\r\n+    console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n+    \r\n+    try {\r\n+        const today = new Date();\r\n+        today.setHours(0, 0, 0, 0);\r\n+\r\n+        // Busca apenas empresas que têm um e-mail cadastrado e válido.\r\n+        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n+\r\n+        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n+\r\n+        for (const company of companies) {\r\n+            const allBoletos = await Boleto.find({ company: company._id });\r\n+            let overdueCount = 0;\r\n+\r\n+            for (const boleto of allBoletos) {\r\n+                const overdueParcels = boleto.parcels.filter(parcel => {\r\n+                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n+                    return !parcel.paid && dueDate < today;\r\n+                });\r\n+                overdueCount += overdueParcels.length;\r\n+            }\r\n+\r\n+            // Se a empresa tiver boletos vencidos, envia o e-mail\r\n+            if (overdueCount > 0) {\r\n+                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n+                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n+            }\r\n+        }\r\n+        console.log('Verificação diária concluída.');\r\n+    } catch (error) {\r\n+        console.error('Erro durante a execução da tarefa agendada:', error);\r\n+    }\r\n+}, {\r\n+    scheduled: true,\r\n+    timezone: \"America/Sao_Paulo\"\r\n+});\r\n+\r\n+// 14. Define a porta e inicia o servidor\r\n+const PORT = process.env.PORT || 5000;\r\n+app.listen(PORT, () => {\r\n+    console.log(`Servidor rodando na porta ${PORT}`);\r\n+});\r\n+\r\n"
                },
                {
                    "date": 1752350132938,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,252 +1,28 @@\n // 1. Carrega as variáveis de ambiente do arquivo .env\r\n require('dotenv').config();\r\n \r\n-// 2. Importa as dependências\r\n+// 2. Importa TODAS as dependências em um só lugar\r\n const express = require('express');\r\n const mongoose = require('mongoose');\r\n const cors = require('cors');\r\n+const cron = require('node-cron');\r\n \r\n-// 3. Inicializa o servidor express\r\n-const app = express();\r\n-\r\n-// 4. Middlewares essenciais\r\n-app.use(cors());\r\n-app.use(express.json());\r\n-\r\n-// 5. Conexão com o Banco de Dados MongoDB\r\n-const dbURI = process.env.MONGODB_URI;\r\n-mongoose.connect(dbURI)\r\n-    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n-    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n-\r\n-\r\n-// --- ROTAS DA API ---\r\n-\r\n-// 6. Rota principal de \"saúde\" da API\r\n-app.get('/', (req, res) => {\r\n-    res.send('API do Organizador de Boletos está no ar!');\r\n-});\r\n-\r\n-// 7. Importar e usar as rotas de autenticação\r\n-const authRoutes = require('./routes/auth');\r\n-app.use('/api/auth', authRoutes);\r\n-\r\n-// 8. Importar e usar as rotas de empresa\r\n-const companyRoutes = require('./routes/company');\r\n-app.use('/api/companies', companyRoutes);\r\n-\r\n-// 9. Importar e usar as rotas de boletos\r\n-const boletoRoutes = require('./routes/boletos');\r\n-app.use('/api/boletos', boletoRoutes);\r\n-\r\n-// 10. Importar e usar as rotas de permissões (NOVO)\r\n-const permissionsRoutes = require('./routes/permissions');\r\n-app.use('/api/permissions', permissionsRoutes);\r\n-\r\n-// 11. Importar e usar as rotas de AdminMaster\r\n-const adminRoutes = require('./routes/admin');\r\n-app.use('/api/admin', adminRoutes);\r\n-\r\n-// 12. emailService\r\n-// Importa a nossa nova função de envio de e-mail\r\n-const { sendOverdueReportEmail } = require('./services/emailService');\r\n-\r\n-// Rota temporária para testar o envio de e-mail\r\n-app.get('/api/test-email', async (req, res) => {\r\n-    console.log(\"Recebida requisição para testar e-mail...\");\r\n-    try {\r\n-        // Preencha com um e-mail seu para receber o teste\r\n-        const testRecipientEmail = \"lobosti@outlook.com\";\r\n-\r\n-        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n-\r\n-        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n-        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n-    }\r\n-});\r\n-\r\n-// 13. Rota definitiva para o envio de e-mail\r\n-const cron = require('node-cron');\r\n+// Importa os modelos\r\n const Company = require('./models/Company');\r\n const Boleto = require('./models/Boleto');\r\n+const User = require('./models/User'); // Importação do User é necessária para a rota /me\r\n \r\n-cron.schedule('0 19 * * *', async () => {\r\n-    console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n-    \r\n-    try {\r\n-        const today = new Date();\r\n-        today.setHours(0, 0, 0, 0);\r\n-\r\n-        // Busca apenas empresas que têm um e-mail cadastrado e válido.\r\n-        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n-\r\n-        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n-\r\n-        for (const company of companies) {\r\n-            const allBoletos = await Boleto.find({ company: company._id });\r\n-            let overdueCount = 0;\r\n-\r\n-            for (const boleto of allBoletos) {\r\n-                const overdueParcels = boleto.parcels.filter(parcel => {\r\n-                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n-                    return !parcel.paid && dueDate < today;\r\n-                });\r\n-                overdueCount += overdueParcels.length;\r\n-            }\r\n-\r\n-            // Se a empresa tiver boletos vencidos, envia o e-mail\r\n-            if (overdueCount > 0) {\r\n-                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n-                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n-            }\r\n-        }\r\n-        console.log('Verificação diária concluída.');\r\n-    } catch (error) {\r\n-        console.error('Erro durante a execução da tarefa agendada:', error);\r\n-    }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\"\r\n-});\r\n-\r\n-// 14. Define a porta e inicia o servidor\r\n-const PORT = process.env.PORT || 5000;\r\n-app.listen(PORT, () => {\r\n-    console.log(`Servidor rodando na porta ${PORT}`);\r\n-});\r\n-\r\n-// 1. Carrega as variáveis de ambiente do arquivo .env\r\n-require('dotenv').config();\r\n-\r\n-// 2. Importa as dependências\r\n-const express = require('express');\r\n-const mongoose = require('mongoose');\r\n-const cors = require('cors');\r\n-\r\n-// 3. Inicializa o servidor express\r\n-const app = express();\r\n-\r\n-// 4. Middlewares essenciais\r\n-app.use(cors());\r\n-app.use(express.json());\r\n-\r\n-// 5. Conexão com o Banco de Dados MongoDB\r\n-const dbURI = process.env.MONGODB_URI;\r\n-mongoose.connect(dbURI)\r\n-    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n-    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n-\r\n-\r\n-// --- ROTAS DA API ---\r\n-\r\n-// 6. Rota principal de \"saúde\" da API\r\n-app.get('/', (req, res) => {\r\n-    res.send('API do Organizador de Boletos está no ar!');\r\n-});\r\n-\r\n-// 7. Importar e usar as rotas de autenticação\r\n+// Importa as rotas\r\n const authRoutes = require('./routes/auth');\r\n-app.use('/api/auth', authRoutes);\r\n-\r\n-// 8. Importar e usar as rotas de empresa\r\n const companyRoutes = require('./routes/company');\r\n-app.use('/api/companies', companyRoutes);\r\n-\r\n-// 9. Importar e usar as rotas de boletos\r\n const boletoRoutes = require('./routes/boletos');\r\n-app.use('/api/boletos', boletoRoutes);\r\n-\r\n-// 10. Importar e usar as rotas de permissões (NOVO)\r\n const permissionsRoutes = require('./routes/permissions');\r\n-app.use('/api/permissions', permissionsRoutes);\r\n-\r\n-// 11. Importar e usar as rotas de AdminMaster\r\n const adminRoutes = require('./routes/admin');\r\n-app.use('/api/admin', adminRoutes);\r\n \r\n-// 12. emailService\r\n-// Importa a nossa nova função de envio de e-mail\r\n+// Importa os serviços\r\n const { sendOverdueReportEmail } = require('./services/emailService');\r\n \r\n-// Rota temporária para testar o envio de e-mail\r\n-app.get('/api/test-email', async (req, res) => {\r\n-    console.log(\"Recebida requisição para testar e-mail...\");\r\n-    try {\r\n-        // Preencha com um e-mail seu para receber o teste\r\n-        const testRecipientEmail = \"lobosti@outlook.com\";\r\n-\r\n-        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n-\r\n-        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n-        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n-    }\r\n-});\r\n-\r\n-// 13. Rota definitiva para o envio de e-mail\r\n-const cron = require('node-cron');\r\n-const Company = require('./models/Company');\r\n-const Boleto = require('./models/Boleto');\r\n-\r\n-cron.schedule('0 19 * * *', async () => {\r\n-    console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n-    \r\n-    try {\r\n-        const today = new Date();\r\n-        today.setHours(0, 0, 0, 0);\r\n-\r\n-        // Busca apenas empresas que têm um e-mail cadastrado e válido.\r\n-        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n-\r\n-        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n-\r\n-        for (const company of companies) {\r\n-            const allBoletos = await Boleto.find({ company: company._id });\r\n-            let overdueCount = 0;\r\n-\r\n-            for (const boleto of allBoletos) {\r\n-                const overdueParcels = boleto.parcels.filter(parcel => {\r\n-                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n-                    return !parcel.paid && dueDate < today;\r\n-                });\r\n-                overdueCount += overdueParcels.length;\r\n-            }\r\n-\r\n-            // Se a empresa tiver boletos vencidos, envia o e-mail\r\n-            if (overdueCount > 0) {\r\n-                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n-                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n-            }\r\n-        }\r\n-        console.log('Verificação diária concluída.');\r\n-    } catch (error) {\r\n-        console.error('Erro durante a execução da tarefa agendada:', error);\r\n-    }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\"\r\n-});\r\n-\r\n-// 14. Define a porta e inicia o servidor\r\n-const PORT = process.env.PORT || 5000;\r\n-app.listen(PORT, () => {\r\n-    console.log(`Servidor rodando na porta ${PORT}`);\r\n-});\r\n-\r\n-// 1. Carrega as variáveis de ambiente do arquivo .env\r\n-require('dotenv').config();\r\n-\r\n-// 2. Importa as dependências\r\n-const express = require('express');\r\n-const mongoose = require('mongoose');\r\n-const cors = require('cors');\r\n-\r\n // 3. Inicializa o servidor express\r\n const app = express();\r\n \r\n // 4. Middlewares essenciais\r\n@@ -258,62 +34,25 @@\n mongoose.connect(dbURI)\r\n     .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n     .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n \r\n-\r\n // --- ROTAS DA API ---\r\n \r\n // 6. Rota principal de \"saúde\" da API\r\n app.get('/', (req, res) => {\r\n     res.send('API do Organizador de Boletos está no ar!');\r\n });\r\n \r\n-// 7. Importar e usar as rotas de autenticação\r\n-const authRoutes = require('./routes/auth');\r\n+// 7. Configuração e uso das rotas\r\n app.use('/api/auth', authRoutes);\r\n-\r\n-// 8. Importar e usar as rotas de empresa\r\n-const companyRoutes = require('./routes/company');\r\n app.use('/api/companies', companyRoutes);\r\n-\r\n-// 9. Importar e usar as rotas de boletos\r\n-const boletoRoutes = require('./routes/boletos');\r\n app.use('/api/boletos', boletoRoutes);\r\n-\r\n-// 10. Importar e usar as rotas de permissões (NOVO)\r\n-const permissionsRoutes = require('./routes/permissions');\r\n app.use('/api/permissions', permissionsRoutes);\r\n-\r\n-// 11. Importar e usar as rotas de AdminMaster\r\n-const adminRoutes = require('./routes/admin');\r\n app.use('/api/admin', adminRoutes);\r\n \r\n-// 12. emailService\r\n-// Importa a nossa nova função de envio de e-mail\r\n-const { sendOverdueReportEmail } = require('./services/emailService');\r\n+// --- TAREFAS AGENDADAS (CRON JOBS) ---\r\n \r\n-// Rota temporária para testar o envio de e-mail\r\n-app.get('/api/test-email', async (req, res) => {\r\n-    console.log(\"Recebida requisição para testar e-mail...\");\r\n-    try {\r\n-        // Preencha com um e-mail seu para receber o teste\r\n-        const testRecipientEmail = \"lobosti@outlook.com\";\r\n-\r\n-        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n-\r\n-        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n-        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n-    }\r\n-});\r\n-\r\n-// // Rota definitiva para o envio de e-mail\r\n-const cron = require('node-cron');\r\n-const Company = require('./models/Company');\r\n-const Boleto = require('./models/Boleto');\r\n-\r\n+// 8. Automação de envio de e-mail para boletos vencidos\r\n cron.schedule('0 19 * * *', async () => {\r\n     console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n     \r\n     try {\r\n@@ -339,9 +78,8 @@\n \r\n             // Se a empresa tiver boletos vencidos, envia o e-mail\r\n             if (overdueCount > 0) {\r\n                 console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n-                // A função sendOverdueReportEmail já está importada no seu arquivo\r\n                 await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n             }\r\n         }\r\n         console.log('Verificação diária concluída.');\r\n@@ -352,190 +90,9 @@\n     scheduled: true,\r\n     timezone: \"America/Sao_Paulo\"\r\n });\r\n \r\n-// 13. Define a porta e inicia o servidor\r\n+// 9. Define a porta e inicia o servidor\r\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n     console.log(`Servidor rodando na porta ${PORT}`);\r\n-});\r\n-\r\n-// 1. Carrega as variáveis de ambiente do arquivo .env\r\n-require('dotenv').config();\r\n-\r\n-// 2. Importa as dependências\r\n-const express = require('express');\r\n-const mongoose = require('mongoose');\r\n-const cors = require('cors');\r\n-\r\n-// 3. Inicializa o servidor express\r\n-const app = express();\r\n-\r\n-// 4. Middlewares essenciais\r\n-app.use(cors());\r\n-app.use(express.json());\r\n-\r\n-// 5. Conexão com o Banco de Dados MongoDB\r\n-const dbURI = process.env.MONGODB_URI;\r\n-mongoose.connect(dbURI)\r\n-    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n-    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n-\r\n-\r\n-// --- ROTAS DA API ---\r\n-\r\n-// 6. Rota principal de \"saúde\" da API\r\n-app.get('/', (req, res) => {\r\n-    res.send('API do Organizador de Boletos está no ar!');\r\n-});\r\n-\r\n-// 7. Importar e usar as rotas de autenticação\r\n-const authRoutes = require('./routes/auth');\r\n-app.use('/api/auth', authRoutes);\r\n-\r\n-// 8. Importar e usar as rotas de empresa\r\n-const companyRoutes = require('./routes/company');\r\n-app.use('/api/companies', companyRoutes);\r\n-\r\n-// 9. Importar e usar as rotas de boletos\r\n-const boletoRoutes = require('./routes/boletos');\r\n-app.use('/api/boletos', boletoRoutes);\r\n-\r\n-// 10. Importar e usar as rotas de permissões (NOVO)\r\n-const permissionsRoutes = require('./routes/permissions');\r\n-app.use('/api/permissions', permissionsRoutes);\r\n-\r\n-// 11. Importar e usar as rotas de AdminMaster\r\n-const adminRoutes = require('./routes/admin');\r\n-app.use('/api/admin', adminRoutes);\r\n-\r\n-// 12. emailService\r\n-// Importa a nossa nova função de envio de e-mail\r\n-const { sendOverdueReportEmail } = require('./services/emailService');\r\n-\r\n-// Rota definitiva para o envio de e-mail\r\n-const cron = require('node-cron');\r\n-const { sendOverdueReportEmail } = require('./services/emailService');\r\n-const Company = require('./models/Company');\r\n-const Boleto = require('./models/Boleto');\r\n-\r\n-cron.schedule('0 19 * * *', async () => {\r\n-    console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n-    \r\n-    try {\r\n-        const today = new Date();\r\n-        today.setHours(0, 0, 0, 0);\r\n-\r\n-        // MUDANÇA 2: Esta query já estava correta, mas vamos reforçar.\r\n-        // Ela busca apenas empresas onde o campo 'email' não é nulo e não é uma string vazia.\r\n-        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n-\r\n-        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n-\r\n-        for (const company of companies) {\r\n-            const allBoletos = await Boleto.find({ company: company._id });\r\n-            let overdueCount = 0;\r\n-\r\n-            for (const boleto of allBoletos) {\r\n-                const overdueParcels = boleto.parcels.filter(parcel => {\r\n-                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n-                    return !parcel.paid && dueDate < today;\r\n-                });\r\n-                overdueCount += overdueParcels.length;\r\n-            }\r\n-\r\n-            if (overdueCount > 0) {\r\n-                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n-                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n-            }\r\n-        }\r\n-        console.log('Verificação diária concluída.');\r\n-    } catch (error) {\r\n-        console.error('Erro durante a execução da tarefa agendada:', error);\r\n-    }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\"\r\n-});\r\n-\r\n-// 13. Define a porta e inicia o servidor\r\n-const PORT = process.env.PORT || 5000;\r\n-app.listen(PORT, () => {\r\n-    console.log(`Servidor rodando na porta ${PORT}`);\r\n-});\r\n-\r\n-// 1. Carrega as variáveis de ambiente do arquivo .env\r\n-require('dotenv').config();\r\n-\r\n-// 2. Importa as dependências\r\n-const express = require('express');\r\n-const mongoose = require('mongoose');\r\n-const cors = require('cors');\r\n-\r\n-// 3. Inicializa o servidor express\r\n-const app = express();\r\n-\r\n-// 4. Middlewares essenciais\r\n-app.use(cors());\r\n-app.use(express.json());\r\n-\r\n-// 5. Conexão com o Banco de Dados MongoDB\r\n-const dbURI = process.env.MONGODB_URI;\r\n-mongoose.connect(dbURI)\r\n-    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n-    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n-\r\n-\r\n-// --- ROTAS DA API ---\r\n-\r\n-// 6. Rota principal de \"saúde\" da API\r\n-app.get('/', (req, res) => {\r\n-    res.send('API do Organizador de Boletos está no ar!');\r\n-});\r\n-\r\n-// 7. Importar e usar as rotas de autenticação\r\n-const authRoutes = require('./routes/auth');\r\n-app.use('/api/auth', authRoutes);\r\n-\r\n-// 8. Importar e usar as rotas de empresa\r\n-const companyRoutes = require('./routes/company');\r\n-app.use('/api/companies', companyRoutes);\r\n-\r\n-// 9. Importar e usar as rotas de boletos\r\n-const boletoRoutes = require('./routes/boletos');\r\n-app.use('/api/boletos', boletoRoutes);\r\n-\r\n-// 10. Importar e usar as rotas de permissões (NOVO)\r\n-const permissionsRoutes = require('./routes/permissions');\r\n-app.use('/api/permissions', permissionsRoutes);\r\n-\r\n-// 11. Importar e usar as rotas de AdminMaster\r\n-const adminRoutes = require('./routes/admin');\r\n-app.use('/api/admin', adminRoutes);\r\n-\r\n-// 12. emailService\r\n-// Importa a nossa nova função de envio de e-mail\r\n-const { sendOverdueReportEmail } = require('./services/emailService');\r\n-\r\n-// Rota temporária para testar o envio de e-mail\r\n-app.get('/api/test-email', async (req, res) => {\r\n-    console.log(\"Recebida requisição para testar e-mail...\");\r\n-    try {\r\n-        // Preencha com um e-mail seu para receber o teste\r\n-        const testRecipientEmail = \"lobosti@outlook.com\";\r\n-\r\n-        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n-\r\n-        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n-        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n-    }\r\n-});\r\n-\r\n-// 13. Define a porta e inicia o servidor\r\n-const PORT = process.env.PORT || 5000;\r\n-app.listen(PORT, () => {\r\n-    console.log(`Servidor rodando na porta ${PORT}`);\r\n-});\r\n-\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752350230531,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,28 +1,23 @@\n // 1. Carrega as variáveis de ambiente do arquivo .env\r\n require('dotenv').config();\r\n \r\n-// 2. Importa TODAS as dependências em um só lugar\r\n+// 2. Importa TODAS as dependências e modelos em um só lugar\r\n const express = require('express');\r\n const mongoose = require('mongoose');\r\n const cors = require('cors');\r\n const cron = require('node-cron');\r\n-\r\n-// Importa os modelos\r\n const Company = require('./models/Company');\r\n const Boleto = require('./models/Boleto');\r\n-const User = require('./models/User'); // Importação do User é necessária para a rota /me\r\n+const { sendOverdueReportEmail } = require('./services/emailService');\r\n \r\n // Importa as rotas\r\n const authRoutes = require('./routes/auth');\r\n const companyRoutes = require('./routes/company');\r\n const boletoRoutes = require('./routes/boletos');\r\n const permissionsRoutes = require('./routes/permissions');\r\n const adminRoutes = require('./routes/admin');\r\n \r\n-// Importa os serviços\r\n-const { sendOverdueReportEmail } = require('./services/emailService');\r\n-\r\n // 3. Inicializa o servidor express\r\n const app = express();\r\n \r\n // 4. Middlewares essenciais\r\n@@ -41,28 +36,37 @@\n app.get('/', (req, res) => {\r\n     res.send('API do Organizador de Boletos está no ar!');\r\n });\r\n \r\n-// 7. Configuração e uso das rotas\r\n+// 7. Uso das rotas importadas\r\n app.use('/api/auth', authRoutes);\r\n app.use('/api/companies', companyRoutes);\r\n app.use('/api/boletos', boletoRoutes);\r\n app.use('/api/permissions', permissionsRoutes);\r\n app.use('/api/admin', adminRoutes);\r\n \r\n-// --- TAREFAS AGENDADAS (CRON JOBS) ---\r\n+// 8. Rota temporária para testar o envio de e-mail (se ainda quiser mantê-la)\r\n+app.get('/api/test-email', async (req, res) => {\r\n+    console.log(\"Recebida requisição para testar e-mail...\");\r\n+    try {\r\n+        const testRecipientEmail = \"lobosti@outlook.com\";\r\n+        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n+        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n+    } catch (error) {\r\n+        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n+        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n+    }\r\n+});\r\n \r\n-// 8. Automação de envio de e-mail para boletos vencidos\r\n+// 9. Automação de envio de e-mail\r\n cron.schedule('0 19 * * *', async () => {\r\n     console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n     \r\n     try {\r\n         const today = new Date();\r\n         today.setHours(0, 0, 0, 0);\r\n \r\n-        // Busca apenas empresas que têm um e-mail cadastrado e válido.\r\n         const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n-\r\n         console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n \r\n         for (const company of companies) {\r\n             const allBoletos = await Boleto.find({ company: company._id });\r\n@@ -75,9 +79,8 @@\n                 });\r\n                 overdueCount += overdueParcels.length;\r\n             }\r\n \r\n-            // Se a empresa tiver boletos vencidos, envia o e-mail\r\n             if (overdueCount > 0) {\r\n                 console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n                 await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n             }\r\n@@ -90,9 +93,9 @@\n     scheduled: true,\r\n     timezone: \"America/Sao_Paulo\"\r\n });\r\n \r\n-// 9. Define a porta e inicia o servidor\r\n+// 10. Define a porta e inicia o servidor\r\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n     console.log(`Servidor rodando na porta ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752498863081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,103 @@\n+// 1. Carrega as variáveis de ambiente do arquivo .env\r\n+require('dotenv').config();\r\n+\r\n+// 2. Importa TODAS as dependências e modelos em um só lugar\r\n+const express = require('express');\r\n+const mongoose = require('mongoose');\r\n+const cors = require('cors');\r\n+const cron = require('node-cron');\r\n+const Company = require('./models/Company');\r\n+const Boleto = require('./models/Boleto');\r\n+const { sendOverdueReportEmail } = require('./services/emailService');\r\n+\r\n+// Importa as rotas\r\n+const authRoutes = require('./routes/auth');\r\n+const companyRoutes = require('./routes/company');\r\n+const boletoRoutes = require('./routes/boletos');\r\n+const permissionsRoutes = require('./routes/permissions');\r\n+const adminRoutes = require('./routes/admin');\r\n+const contactRoutes = require('./routes/contact');\r\n+\r\n+// 3. Inicializa o servidor express\r\n+const app = express();\r\n+\r\n+// 4. Middlewares essenciais\r\n+app.use(cors());\r\n+app.use(express.json());\r\n+\r\n+// 5. Conexão com o Banco de Dados MongoDB\r\n+const dbURI = process.env.MONGODB_URI;\r\n+mongoose.connect(dbURI)\r\n+    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n+    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n+\r\n+// --- ROTAS DA API ---\r\n+\r\n+// 6. Rota principal de \"saúde\" da API\r\n+app.get('/', (req, res) => {\r\n+    res.send('API do Organizador de Boletos está no ar!');\r\n+});\r\n+\r\n+// 7. Uso das rotas importadas\r\n+app.use('/api/auth', authRoutes);\r\n+app.use('/api/companies', companyRoutes);\r\n+app.use('/api/boletos', boletoRoutes);\r\n+app.use('/api/permissions', permissionsRoutes);\r\n+app.use('/api/admin', adminRoutes);\r\n+app.use('/api/contact', contactRoutes);\r\n+\r\n+// 8. Rota temporária para testar o envio de e-mail (se ainda quiser mantê-la)\r\n+app.get('/api/test-email', async (req, res) => {\r\n+    console.log(\"Recebida requisição para testar e-mail...\");\r\n+    try {\r\n+        const testRecipientEmail = \"lobosti@outlook.com\";\r\n+        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n+        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n+    } catch (error) {\r\n+        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n+        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n+    }\r\n+});\r\n+\r\n+// 9. Automação de envio de e-mail\r\n+cron.schedule('0 19 * * *', async () => {\r\n+    console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n+    \r\n+    try {\r\n+        const today = new Date();\r\n+        today.setHours(0, 0, 0, 0);\r\n+\r\n+        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n+        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n+\r\n+        for (const company of companies) {\r\n+            const allBoletos = await Boleto.find({ company: company._id });\r\n+            let overdueCount = 0;\r\n+\r\n+            for (const boleto of allBoletos) {\r\n+                const overdueParcels = boleto.parcels.filter(parcel => {\r\n+                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n+                    return !parcel.paid && dueDate < today;\r\n+                });\r\n+                overdueCount += overdueParcels.length;\r\n+            }\r\n+\r\n+            if (overdueCount > 0) {\r\n+                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n+                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n+            }\r\n+        }\r\n+        console.log('Verificação diária concluída.');\r\n+    } catch (error) {\r\n+        console.error('Erro durante a execução da tarefa agendada:', error);\r\n+    }\r\n+}, {\r\n+    scheduled: true,\r\n+    timezone: \"America/Sao_Paulo\"\r\n+});\r\n+\r\n+// 10. Define a porta e inicia o servidor\r\n+const PORT = process.env.PORT || 5000;\r\n+app.listen(PORT, () => {\r\n+    console.log(`Servidor rodando na porta ${PORT}`);\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752529472158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,8 +44,9 @@\n app.use('/api/boletos', boletoRoutes);\r\n app.use('/api/permissions', permissionsRoutes);\r\n app.use('/api/admin', adminRoutes);\r\n app.use('/api/contact', contactRoutes);\r\n+app.use('/api/payments', paymentRoutes);\r\n \r\n // 8. Rota temporária para testar o envio de e-mail (se ainda quiser mantê-la)\r\n app.get('/api/test-email', async (req, res) => {\r\n     console.log(\"Recebida requisição para testar e-mail...\");\r\n@@ -99,106 +100,5 @@\n // 10. Define a porta e inicia o servidor\r\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n     console.log(`Servidor rodando na porta ${PORT}`);\r\n-});\n-// 1. Carrega as variáveis de ambiente do arquivo .env\r\n-require('dotenv').config();\r\n-\r\n-// 2. Importa TODAS as dependências e modelos em um só lugar\r\n-const express = require('express');\r\n-const mongoose = require('mongoose');\r\n-const cors = require('cors');\r\n-const cron = require('node-cron');\r\n-const Company = require('./models/Company');\r\n-const Boleto = require('./models/Boleto');\r\n-const { sendOverdueReportEmail } = require('./services/emailService');\r\n-\r\n-// Importa as rotas\r\n-const authRoutes = require('./routes/auth');\r\n-const companyRoutes = require('./routes/company');\r\n-const boletoRoutes = require('./routes/boletos');\r\n-const permissionsRoutes = require('./routes/permissions');\r\n-const adminRoutes = require('./routes/admin');\r\n-\r\n-// 3. Inicializa o servidor express\r\n-const app = express();\r\n-\r\n-// 4. Middlewares essenciais\r\n-app.use(cors());\r\n-app.use(express.json());\r\n-\r\n-// 5. Conexão com o Banco de Dados MongoDB\r\n-const dbURI = process.env.MONGODB_URI;\r\n-mongoose.connect(dbURI)\r\n-    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n-    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n-\r\n-// --- ROTAS DA API ---\r\n-\r\n-// 6. Rota principal de \"saúde\" da API\r\n-app.get('/', (req, res) => {\r\n-    res.send('API do Organizador de Boletos está no ar!');\r\n-});\r\n-\r\n-// 7. Uso das rotas importadas\r\n-app.use('/api/auth', authRoutes);\r\n-app.use('/api/companies', companyRoutes);\r\n-app.use('/api/boletos', boletoRoutes);\r\n-app.use('/api/permissions', permissionsRoutes);\r\n-app.use('/api/admin', adminRoutes);\r\n-\r\n-// 8. Rota temporária para testar o envio de e-mail (se ainda quiser mantê-la)\r\n-app.get('/api/test-email', async (req, res) => {\r\n-    console.log(\"Recebida requisição para testar e-mail...\");\r\n-    try {\r\n-        const testRecipientEmail = \"lobosti@outlook.com\";\r\n-        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n-        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n-    } catch (error) {\r\n-        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n-        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n-    }\r\n-});\r\n-\r\n-// 9. Automação de envio de e-mail\r\n-cron.schedule('0 19 * * *', async () => {\r\n-    console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n-    \r\n-    try {\r\n-        const today = new Date();\r\n-        today.setHours(0, 0, 0, 0);\r\n-\r\n-        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n-        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n-\r\n-        for (const company of companies) {\r\n-            const allBoletos = await Boleto.find({ company: company._id });\r\n-            let overdueCount = 0;\r\n-\r\n-            for (const boleto of allBoletos) {\r\n-                const overdueParcels = boleto.parcels.filter(parcel => {\r\n-                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n-                    return !parcel.paid && dueDate < today;\r\n-                });\r\n-                overdueCount += overdueParcels.length;\r\n-            }\r\n-\r\n-            if (overdueCount > 0) {\r\n-                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n-                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n-            }\r\n-        }\r\n-        console.log('Verificação diária concluída.');\r\n-    } catch (error) {\r\n-        console.error('Erro durante a execução da tarefa agendada:', error);\r\n-    }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\"\r\n-});\r\n-\r\n-// 10. Define a porta e inicia o servidor\r\n-const PORT = process.env.PORT || 5000;\r\n-app.listen(PORT, () => {\r\n-    console.log(`Servidor rodando na porta ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752530210401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,8 +16,9 @@\n const boletoRoutes = require('./routes/boletos');\r\n const permissionsRoutes = require('./routes/permissions');\r\n const adminRoutes = require('./routes/admin');\r\n const contactRoutes = require('./routes/contact');\r\n+const paymentRoutes = require('./routes/payment'); \r\n \r\n // 3. Inicializa o servidor express\r\n const app = express();\r\n \r\n"
                },
                {
                    "date": 1752530293135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n const boletoRoutes = require('./routes/boletos');\r\n const permissionsRoutes = require('./routes/permissions');\r\n const adminRoutes = require('./routes/admin');\r\n const contactRoutes = require('./routes/contact');\r\n-const paymentRoutes = require('./routes/payment'); \r\n+const paymentRoutes = require('./routes/payments'); \r\n \r\n // 3. Inicializa o servidor express\r\n const app = express();\r\n \r\n"
                },
                {
                    "date": 1752532056563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n const boletoRoutes = require('./routes/boletos');\r\n const permissionsRoutes = require('./routes/permissions');\r\n const adminRoutes = require('./routes/admin');\r\n const contactRoutes = require('./routes/contact');\r\n-const paymentRoutes = require('./routes/payments'); \r\n+const paymentRoutes = require('./routes/payment'); \r\n \r\n // 3. Inicializa o servidor express\r\n const app = express();\r\n \r\n"
                },
                {
                    "date": 1752532164933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n const boletoRoutes = require('./routes/boletos');\r\n const permissionsRoutes = require('./routes/permissions');\r\n const adminRoutes = require('./routes/admin');\r\n const contactRoutes = require('./routes/contact');\r\n-const paymentRoutes = require('./routes/payment'); \r\n+const paymentRoutes = require('./routes/payments'); \r\n \r\n // 3. Inicializa o servidor express\r\n const app = express();\r\n \r\n"
                },
                {
                    "date": 1752613701537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,10 @@\n const boletoRoutes = require('./routes/boletos');\r\n const permissionsRoutes = require('./routes/permissions');\r\n const adminRoutes = require('./routes/admin');\r\n const contactRoutes = require('./routes/contact');\r\n-const paymentRoutes = require('./routes/payments'); \r\n+const paymentRoutes = require('./routes/payments');\r\n+const rateLimit = require('express-rate-limit');\r\n \r\n // 3. Inicializa o servidor express\r\n const app = express();\r\n \r\n"
                },
                {
                    "date": 1752613795108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,18 @@\n // 4. Middlewares essenciais\r\n app.use(cors());\r\n app.use(express.json());\r\n \r\n+// Middleware de Limite de Requisições para rotas de login\r\n+const loginLimiter = rateLimit({\r\n+    windowMs: 15 * 60 * 1000, // Janela de 15 minutos\r\n+    max: 10, // Permite 10 tentativas de login por IP a cada 15 minutos\r\n+    message: { message: 'Muitas tentativas de login deste IP. Por favor, tente novamente após 15 minutos.' },\r\n+    standardHeaders: true,\r\n+    legacyHeaders: false,\r\n+});\r\n+app.use('/api/auth/login', loginLimiter);\r\n+\r\n // 5. Conexão com o Banco de Dados MongoDB\r\n const dbURI = process.env.MONGODB_URI;\r\n mongoose.connect(dbURI)\r\n     .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n"
                },
                {
                    "date": 1752698088959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,32 +1,29 @@\n-// 1. Carrega as variáveis de ambiente do arquivo .env\r\n+// Carrega as variáveis de ambiente do arquivo .env\r\n require('dotenv').config();\r\n \r\n-// 2. Importa TODAS as dependências e modelos em um só lugar\r\n const express = require('express');\r\n const mongoose = require('mongoose');\r\n const cors = require('cors');\r\n const cron = require('node-cron');\r\n const Company = require('./models/Company');\r\n const Boleto = require('./models/Boleto');\r\n const { sendOverdueReportEmail } = require('./services/emailService');\r\n-\r\n-// Importa as rotas\r\n const authRoutes = require('./routes/auth');\r\n const companyRoutes = require('./routes/company');\r\n const boletoRoutes = require('./routes/boletos');\r\n const permissionsRoutes = require('./routes/permissions');\r\n const adminRoutes = require('./routes/admin');\r\n const contactRoutes = require('./routes/contact');\r\n const paymentRoutes = require('./routes/payments');\r\n const rateLimit = require('express-rate-limit');\r\n-\r\n-// 3. Inicializa o servidor express\r\n+const nfeRoutes = require('./routes/nfe');\r\n const app = express();\r\n \r\n-// 4. Middlewares essenciais\r\n+// Middlewares essenciais\r\n app.use(cors());\r\n app.use(express.json());\r\n+app.use('/api/nfe', nfeRoutes);\r\n \r\n // Middleware de Limite de Requisições para rotas de login\r\n const loginLimiter = rateLimit({\r\n     windowMs: 15 * 60 * 1000, // Janela de 15 minutos\r\n@@ -36,31 +33,31 @@\n     legacyHeaders: false,\r\n });\r\n app.use('/api/auth/login', loginLimiter);\r\n \r\n-// 5. Conexão com o Banco de Dados MongoDB\r\n+// Conexão com o Banco de Dados MongoDB\r\n const dbURI = process.env.MONGODB_URI;\r\n mongoose.connect(dbURI)\r\n     .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n     .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n \r\n // --- ROTAS DA API ---\r\n \r\n-// 6. Rota principal de \"saúde\" da API\r\n+// Rota principal de \"saúde\" da API\r\n app.get('/', (req, res) => {\r\n     res.send('API do Organizador de Boletos está no ar!');\r\n });\r\n \r\n-// 7. Uso das rotas importadas\r\n+// Uso das rotas importadas\r\n app.use('/api/auth', authRoutes);\r\n app.use('/api/companies', companyRoutes);\r\n app.use('/api/boletos', boletoRoutes);\r\n app.use('/api/permissions', permissionsRoutes);\r\n app.use('/api/admin', adminRoutes);\r\n app.use('/api/contact', contactRoutes);\r\n app.use('/api/payments', paymentRoutes);\r\n \r\n-// 8. Rota temporária para testar o envio de e-mail (se ainda quiser mantê-la)\r\n+// Rota temporária para testar o envio de e-mail (se ainda quiser mantê-la)\r\n app.get('/api/test-email', async (req, res) => {\r\n     console.log(\"Recebida requisição para testar e-mail...\");\r\n     try {\r\n         const testRecipientEmail = \"lobosti@outlook.com\";\r\n@@ -71,9 +68,9 @@\n         res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n     }\r\n });\r\n \r\n-// 9. Automação de envio de e-mail\r\n+// Automação de envio de e-mail\r\n cron.schedule('0 19 * * *', async () => {\r\n     console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n     \r\n     try {\r\n@@ -108,9 +105,9 @@\n     scheduled: true,\r\n     timezone: \"America/Sao_Paulo\"\r\n });\r\n \r\n-// 10. Define a porta e inicia o servidor\r\n+// Define a porta e inicia o servidor\r\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n     console.log(`Servidor rodando na porta ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1752782873877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,8 +17,9 @@\n const paymentRoutes = require('./routes/payments');\r\n const rateLimit = require('express-rate-limit');\r\n const nfeRoutes = require('./routes/nfe');\r\n const app = express();\r\n+const { sendOverdueReportEmail } = require('./services/emailService');\r\n \r\n // Middlewares essenciais\r\n app.use(cors());\r\n app.use(express.json());\r\n@@ -105,8 +106,23 @@\n     scheduled: true,\r\n     timezone: \"America/Sao_Paulo\"\r\n });\r\n \r\n+// ROTA DE TESTE MANUAL PARA O E-MAIL DAS 19H\r\n+app.get('/api/force-overdue-email', async (req, res) => {\r\n+    console.log(\"Recebida requisição para forçar o envio do e-mail de boletos vencidos...\");\r\n+    try {\r\n+        // Chama diretamente a função que o cron job das 19h executaria\r\n+        await sendOverdueReportEmail();\r\n+        \r\n+        // Se a função for concluída, envia uma resposta de sucesso\r\n+        res.status(200).json({ message: 'Comando para enviar e-mail de boletos vencidos executado com sucesso! Verifique o console e a caixa de entrada.' });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao forçar o envio do e-mail de teste:\", error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro ao tentar executar a tarefa de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n // Define a porta e inicia o servidor\r\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n     console.log(`Servidor rodando na porta ${PORT}`);\r\n"
                },
                {
                    "date": 1752783111173,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,8 @@\n const paymentRoutes = require('./routes/payments');\r\n const rateLimit = require('express-rate-limit');\r\n const nfeRoutes = require('./routes/nfe');\r\n const app = express();\r\n-const { sendOverdueReportEmail } = require('./services/emailService');\r\n \r\n // Middlewares essenciais\r\n app.use(cors());\r\n app.use(express.json());\r\n"
                },
                {
                    "date": 1752783245350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,17 +108,47 @@\n \r\n // ROTA DE TESTE MANUAL PARA O E-MAIL DAS 19H\r\n app.get('/api/force-overdue-email', async (req, res) => {\r\n     console.log(\"Recebida requisição para forçar o envio do e-mail de boletos vencidos...\");\r\n+    \r\n     try {\r\n-        // Chama diretamente a função que o cron job das 19h executaria\r\n-        await sendOverdueReportEmail();\r\n+        const today = new Date();\r\n+        today.setHours(0, 0, 0, 0);\r\n+\r\n+        // 1. Busca todas as empresas que têm um e-mail registado\r\n+        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n+        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n+\r\n+        let emailsSentCount = 0;\r\n+        for (const company of companies) {\r\n+            // 2. Para cada empresa, busca os seus boletos\r\n+            const allBoletos = await Boleto.find({ company: company._id });\r\n+            let overdueCount = 0;\r\n+\r\n+            for (const boleto of allBoletos) {\r\n+                // 3. Conta quantas parcelas estão vencidas\r\n+                const overdueParcels = boleto.parcels.filter(parcel => {\r\n+                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n+                    return !parcel.paid && dueDate < today;\r\n+                });\r\n+                overdueCount += overdueParcels.length;\r\n+            }\r\n+\r\n+            // 4. Se houver parcelas vencidas, chama a função de envio com os dados corretos\r\n+            if (overdueCount > 0) {\r\n+                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n+                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n+                emailsSentCount++;\r\n+            }\r\n+        }\r\n         \r\n-        // Se a função for concluída, envia uma resposta de sucesso\r\n-        res.status(200).json({ message: 'Comando para enviar e-mail de boletos vencidos executado com sucesso! Verifique o console e a caixa de entrada.' });\r\n+        const successMessage = `Verificação concluída. ${emailsSentCount} e-mails de relatório foram enviados.`;\r\n+        console.log(successMessage);\r\n+        res.status(200).json({ message: successMessage });\r\n+\r\n     } catch (error) {\r\n-        console.error(\"Erro ao forçar o envio do e-mail de teste:\", error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro ao tentar executar a tarefa de e-mail.' });\r\n+        console.error(\"Erro ao forçar o envio do e-mail:\", error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro ao executar a tarefa de e-mail.' });\r\n     }\r\n });\r\n \r\n // Define a porta e inicia o servidor\r\n"
                },
                {
                    "date": 1752783987877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,31 +71,38 @@\n \r\n // Automação de envio de e-mail\r\n cron.schedule('0 19 * * *', async () => {\r\n     console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n-    \r\n     try {\r\n         const today = new Date();\r\n         today.setHours(0, 0, 0, 0);\r\n \r\n         const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n-        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n \r\n         for (const company of companies) {\r\n             const allBoletos = await Boleto.find({ company: company._id });\r\n-            let overdueCount = 0;\r\n+            const overdueParcelsDetails = []; // Lista para guardar os detalhes\r\n \r\n             for (const boleto of allBoletos) {\r\n-                const overdueParcels = boleto.parcels.filter(parcel => {\r\n-                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n-                    return !parcel.paid && dueDate < today;\r\n+                const overdueParcels = boleto.parcels.filter(parcel =>\r\n+                    !parcel.paid && new Date(parcel.dueDate + 'T00:00:00') < today\r\n+                );\r\n+\r\n+                // Adiciona os detalhes de cada parcela vencida à nossa lista\r\n+                overdueParcels.forEach(parcel => {\r\n+                    overdueParcelsDetails.push({\r\n+                        billName: boleto.name,\r\n+                        nfeNumber: boleto.nfeNumber,\r\n+                        parcelNumber: parcel.number,\r\n+                        amount: parcel.amount,\r\n+                        dueDate: parcel.dueDate\r\n+                    });\r\n                 });\r\n-                overdueCount += overdueParcels.length;\r\n             }\r\n \r\n-            if (overdueCount > 0) {\r\n-                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n-                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n+            // Se a lista de detalhes não estiver vazia, envia o e-mail\r\n+            if (overdueParcelsDetails.length > 0) {\r\n+                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails);\r\n             }\r\n         }\r\n         console.log('Verificação diária concluída.');\r\n     } catch (error) {\r\n@@ -108,44 +115,44 @@\n \r\n // ROTA DE TESTE MANUAL PARA O E-MAIL DAS 19H\r\n app.get('/api/force-overdue-email', async (req, res) => {\r\n     console.log(\"Recebida requisição para forçar o envio do e-mail de boletos vencidos...\");\r\n-    \r\n     try {\r\n         const today = new Date();\r\n         today.setHours(0, 0, 0, 0);\r\n-\r\n-        // 1. Busca todas as empresas que têm um e-mail registado\r\n         const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n         console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n \r\n         let emailsSentCount = 0;\r\n         for (const company of companies) {\r\n-            // 2. Para cada empresa, busca os seus boletos\r\n             const allBoletos = await Boleto.find({ company: company._id });\r\n-            let overdueCount = 0;\r\n+            const overdueParcelsDetails = [];\r\n \r\n             for (const boleto of allBoletos) {\r\n-                // 3. Conta quantas parcelas estão vencidas\r\n-                const overdueParcels = boleto.parcels.filter(parcel => {\r\n-                    const dueDate = new Date(parcel.dueDate + 'T00:00:00');\r\n-                    return !parcel.paid && dueDate < today;\r\n+                const overdueParcels = boleto.parcels.filter(parcel => \r\n+                    !parcel.paid && new Date(parcel.dueDate + 'T00:00:00') < today\r\n+                );\r\n+                overdueParcels.forEach(parcel => {\r\n+                    overdueParcelsDetails.push({\r\n+                        billName: boleto.name,\r\n+                        nfeNumber: boleto.nfeNumber,\r\n+                        parcelNumber: parcel.number,\r\n+                        amount: parcel.amount,\r\n+                        dueDate: parcel.dueDate\r\n+                    });\r\n                 });\r\n-                overdueCount += overdueParcels.length;\r\n             }\r\n \r\n-            // 4. Se houver parcelas vencidas, chama a função de envio com os dados corretos\r\n-            if (overdueCount > 0) {\r\n-                console.log(`Enviando e-mail para ${company.nomeEmpresa} (${company.email}) sobre ${overdueCount} boletos vencidos.`);\r\n-                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueCount);\r\n+            if (overdueParcelsDetails.length > 0) {\r\n+                console.log(`Enviando e-mail para ${company.nomeEmpresa} com ${overdueParcelsDetails.length} parcelas vencidas.`);\r\n+                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails);\r\n                 emailsSentCount++;\r\n             }\r\n         }\r\n         \r\n         const successMessage = `Verificação concluída. ${emailsSentCount} e-mails de relatório foram enviados.`;\r\n         console.log(successMessage);\r\n         res.status(200).json({ message: successMessage });\r\n-\r\n     } catch (error) {\r\n         console.error(\"Erro ao forçar o envio do e-mail:\", error);\r\n         res.status(500).json({ message: 'Ocorreu um erro ao executar a tarefa de e-mail.' });\r\n     }\r\n"
                },
                {
                    "date": 1752784362946,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,8 +17,9 @@\n const paymentRoutes = require('./routes/payments');\r\n const rateLimit = require('express-rate-limit');\r\n const nfeRoutes = require('./routes/nfe');\r\n const app = express();\r\n+const { sendDailyReportEmail } = require('./services/emailService');\r\n \r\n // Middlewares essenciais\r\n app.use(cors());\r\n app.use(express.json());\r\n@@ -70,39 +71,37 @@\n });\r\n \r\n // Automação de envio de e-mail\r\n cron.schedule('0 19 * * *', async () => {\r\n-    console.log('Executando verificação diária de boletos vencidos às 19:00...');\r\n+    console.log('Executando verificação diária de boletos às 19:00...');\r\n     try {\r\n         const today = new Date();\r\n         today.setHours(0, 0, 0, 0);\r\n+        \r\n+        const tomorrow = new Date();\r\n+        tomorrow.setDate(today.getDate() + 1);\r\n+        tomorrow.setHours(0, 0, 0, 0);\r\n \r\n         const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n \r\n         for (const company of companies) {\r\n             const allBoletos = await Boleto.find({ company: company._id });\r\n-            const overdueParcelsDetails = []; // Lista para guardar os detalhes\r\n+            const overdueParcelsDetails = [];\r\n+            const dueTomorrowParcelsDetails = [];\r\n \r\n             for (const boleto of allBoletos) {\r\n-                const overdueParcels = boleto.parcels.filter(parcel =>\r\n-                    !parcel.paid && new Date(parcel.dueDate + 'T00:00:00') < today\r\n-                );\r\n-\r\n-                // Adiciona os detalhes de cada parcela vencida à nossa lista\r\n-                overdueParcels.forEach(parcel => {\r\n-                    overdueParcelsDetails.push({\r\n-                        billName: boleto.name,\r\n-                        nfeNumber: boleto.nfeNumber,\r\n-                        parcelNumber: parcel.number,\r\n-                        amount: parcel.amount,\r\n-                        dueDate: parcel.dueDate\r\n-                    });\r\n-                });\r\n+                // Filtra parcelas vencidas\r\n+                const overdueParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00') < today);\r\n+                overdueParcels.forEach(p => overdueParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n+                \r\n+                // Filtra parcelas que vencem amanhã\r\n+                const dueTomorrowParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === tomorrow.getTime());\r\n+                dueTomorrowParcels.forEach(p => dueTomorrowParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n             }\r\n \r\n-            // Se a lista de detalhes não estiver vazia, envia o e-mail\r\n-            if (overdueParcelsDetails.length > 0) {\r\n-                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails);\r\n+            // Envia o e-mail apenas se houver algo a relatar\r\n+            if (overdueParcelsDetails.length > 0 || dueTomorrowParcelsDetails.length > 0) {\r\n+                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTomorrowParcelsDetails);\r\n             }\r\n         }\r\n         console.log('Verificação diária concluída.');\r\n     } catch (error) {\r\n@@ -114,38 +113,37 @@\n });\r\n \r\n // ROTA DE TESTE MANUAL PARA O E-MAIL DAS 19H\r\n app.get('/api/force-overdue-email', async (req, res) => {\r\n-    console.log(\"Recebida requisição para forçar o envio do e-mail de boletos vencidos...\");\r\n+    console.log(\"Recebida requisição para forçar o envio do e-mail de relatório diário...\");\r\n     try {\r\n         const today = new Date();\r\n         today.setHours(0, 0, 0, 0);\r\n+\r\n+        const tomorrow = new Date();\r\n+        tomorrow.setDate(today.getDate() + 1);\r\n+        tomorrow.setHours(0, 0, 0, 0);\r\n+        \r\n         const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n         console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n \r\n         let emailsSentCount = 0;\r\n         for (const company of companies) {\r\n             const allBoletos = await Boleto.find({ company: company._id });\r\n             const overdueParcelsDetails = [];\r\n+            const dueTomorrowParcelsDetails = [];\r\n \r\n             for (const boleto of allBoletos) {\r\n-                const overdueParcels = boleto.parcels.filter(parcel => \r\n-                    !parcel.paid && new Date(parcel.dueDate + 'T00:00:00') < today\r\n-                );\r\n-                overdueParcels.forEach(parcel => {\r\n-                    overdueParcelsDetails.push({\r\n-                        billName: boleto.name,\r\n-                        nfeNumber: boleto.nfeNumber,\r\n-                        parcelNumber: parcel.number,\r\n-                        amount: parcel.amount,\r\n-                        dueDate: parcel.dueDate\r\n-                    });\r\n-                });\r\n+                const overdueParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00') < today);\r\n+                overdueParcels.forEach(p => overdueParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n+\r\n+                const dueTomorrowParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === tomorrow.getTime());\r\n+                dueTomorrowParcels.forEach(p => dueTomorrowParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n             }\r\n \r\n-            if (overdueParcelsDetails.length > 0) {\r\n-                console.log(`Enviando e-mail para ${company.nomeEmpresa} com ${overdueParcelsDetails.length} parcelas vencidas.`);\r\n-                await sendOverdueReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails);\r\n+            if (overdueParcelsDetails.length > 0 || dueTomorrowParcelsDetails.length > 0) {\r\n+                console.log(`Enviando e-mail para ${company.nomeEmpresa} com ${overdueParcelsDetails.length} parcelas vencidas e ${dueTomorrowParcelsDetails.length} a vencer amanhã.`);\r\n+                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTomorrowParcelsDetails);\r\n                 emailsSentCount++;\r\n             }\r\n         }\r\n         \r\n"
                },
                {
                    "date": 1752784709335,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,18 +88,16 @@\n             const overdueParcelsDetails = [];\r\n             const dueTomorrowParcelsDetails = [];\r\n \r\n             for (const boleto of allBoletos) {\r\n-                // Filtra parcelas vencidas\r\n-                const overdueParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00') < today);\r\n+                // A MUDANÇA ESTÁ AQUI: Trocamos '<' por '<='\r\n+                const overdueParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00') <= today);\r\n                 overdueParcels.forEach(p => overdueParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n                 \r\n-                // Filtra parcelas que vencem amanhã\r\n                 const dueTomorrowParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === tomorrow.getTime());\r\n                 dueTomorrowParcels.forEach(p => dueTomorrowParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n             }\r\n \r\n-            // Envia o e-mail apenas se houver algo a relatar\r\n             if (overdueParcelsDetails.length > 0 || dueTomorrowParcelsDetails.length > 0) {\r\n                 await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTomorrowParcelsDetails);\r\n             }\r\n         }\r\n@@ -132,9 +130,10 @@\n             const overdueParcelsDetails = [];\r\n             const dueTomorrowParcelsDetails = [];\r\n \r\n             for (const boleto of allBoletos) {\r\n-                const overdueParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00') < today);\r\n+                // A MUDANÇA ESTÁ AQUI: Trocamos '<' por '<='\r\n+                const overdueParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00') <= today);\r\n                 overdueParcels.forEach(p => overdueParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n \r\n                 const dueTomorrowParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === tomorrow.getTime());\r\n                 dueTomorrowParcels.forEach(p => dueTomorrowParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n"
                },
                {
                    "date": 1752787957374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,33 +73,60 @@\n // Automação de envio de e-mail\r\n cron.schedule('0 19 * * *', async () => {\r\n     console.log('Executando verificação diária de boletos às 19:00...');\r\n     try {\r\n+        // Define a data 'hoje' com o tempo zerado para comparações precisas\r\n         const today = new Date();\r\n         today.setHours(0, 0, 0, 0);\r\n         \r\n+        // Define a data 'amanhã' também com o tempo zerado\r\n         const tomorrow = new Date();\r\n         tomorrow.setDate(today.getDate() + 1);\r\n         tomorrow.setHours(0, 0, 0, 0);\r\n \r\n+        // Busca todas as empresas que têm um e-mail cadastrado\r\n         const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n \r\n         for (const company of companies) {\r\n             const allBoletos = await Boleto.find({ company: company._id });\r\n-            const overdueParcelsDetails = [];\r\n-            const dueTomorrowParcelsDetails = [];\r\n+            const overdueParcelsDetails = []; // Lista para parcelas vencidas (< hoje)\r\n+            const dueTodayParcelsDetails = [];  // Nova lista para parcelas que vencem hoje (= hoje)\r\n \r\n             for (const boleto of allBoletos) {\r\n-                // A MUDANÇA ESTÁ AQUI: Trocamos '<' por '<='\r\n-                const overdueParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00') <= today);\r\n-                overdueParcels.forEach(p => overdueParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n+                // Filtra parcelas vencidas (data de vencimento é anterior a hoje)\r\n+                const overdueParcels = boleto.parcels.filter(p => \r\n+                    !p.paid && new Date(p.dueDate + 'T00:00:00') < today\r\n+                );\r\n+                // Adiciona os detalhes de cada parcela vencida à lista\r\n+                overdueParcels.forEach(p => {\r\n+                    overdueParcelsDetails.push({\r\n+                        billName: boleto.name,\r\n+                        nfeNumber: boleto.nfeNumber,\r\n+                        parcelNumber: p.number,\r\n+                        amount: p.amount,\r\n+                        dueDate: p.dueDate\r\n+                    });\r\n+                });\r\n                 \r\n-                const dueTomorrowParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === tomorrow.getTime());\r\n-                dueTomorrowParcels.forEach(p => dueTomorrowParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n+                // Filtra parcelas que vencem hoje\r\n+                const dueTodayParcels = boleto.parcels.filter(p => \r\n+                    !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === today.getTime()\r\n+                );\r\n+                // Adiciona os detalhes de cada parcela que vence hoje à lista\r\n+                dueTodayParcels.forEach(p => {\r\n+                    dueTodayParcelsDetails.push({\r\n+                        billName: boleto.name,\r\n+                        nfeNumber: boleto.nfeNumber,\r\n+                        parcelNumber: p.number,\r\n+                        amount: p.amount,\r\n+                        dueDate: p.dueDate\r\n+                    });\r\n+                });\r\n             }\r\n \r\n-            if (overdueParcelsDetails.length > 0 || dueTomorrowParcelsDetails.length > 0) {\r\n-                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTomorrowParcelsDetails);\r\n+            // Envia o e-mail apenas se houver algo a relatar (vencido ou a vencer hoje)\r\n+            if (overdueParcelsDetails.length > 0 || dueTodayParcelsDetails.length > 0) {\r\n+                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTodayParcelsDetails);\r\n             }\r\n         }\r\n         console.log('Verificação diária concluída.');\r\n     } catch (error) {\r\n"
                },
                {
                    "date": 1752788028935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,43 +140,66 @@\n // ROTA DE TESTE MANUAL PARA O E-MAIL DAS 19H\r\n app.get('/api/force-overdue-email', async (req, res) => {\r\n     console.log(\"Recebida requisição para forçar o envio do e-mail de relatório diário...\");\r\n     try {\r\n+        // Define a data 'hoje' com o tempo zerado para comparações precisas\r\n         const today = new Date();\r\n         today.setHours(0, 0, 0, 0);\r\n \r\n-        const tomorrow = new Date();\r\n-        tomorrow.setDate(today.getDate() + 1);\r\n-        tomorrow.setHours(0, 0, 0, 0);\r\n-        \r\n+        // Busca todas as empresas que têm um e-mail cadastrado\r\n         const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n         console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n \r\n         let emailsSentCount = 0;\r\n         for (const company of companies) {\r\n             const allBoletos = await Boleto.find({ company: company._id });\r\n-            const overdueParcelsDetails = [];\r\n-            const dueTomorrowParcelsDetails = [];\r\n+            const overdueParcelsDetails = []; // Lista para parcelas vencidas (< hoje)\r\n+            const dueTodayParcelsDetails = [];  // Lista para parcelas que vencem hoje (= hoje)\r\n \r\n             for (const boleto of allBoletos) {\r\n-                // A MUDANÇA ESTÁ AQUI: Trocamos '<' por '<='\r\n-                const overdueParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00') <= today);\r\n-                overdueParcels.forEach(p => overdueParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n-\r\n-                const dueTomorrowParcels = boleto.parcels.filter(p => !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === tomorrow.getTime());\r\n-                dueTomorrowParcels.forEach(p => dueTomorrowParcelsDetails.push({ billName: boleto.name, nfeNumber: boleto.nfeNumber, parcelNumber: p.number, amount: p.amount, dueDate: p.dueDate }));\r\n+                // Filtra parcelas vencidas (data de vencimento é anterior a hoje)\r\n+                const overdueParcels = boleto.parcels.filter(p => \r\n+                    !p.paid && new Date(p.dueDate + 'T00:00:00') < today\r\n+                );\r\n+                // Adiciona os detalhes de cada parcela vencida à lista\r\n+                overdueParcels.forEach(p => {\r\n+                    overdueParcelsDetails.push({\r\n+                        billName: boleto.name,\r\n+                        nfeNumber: boleto.nfeNumber,\r\n+                        parcelNumber: p.number,\r\n+                        amount: p.amount,\r\n+                        dueDate: p.dueDate\r\n+                    });\r\n+                });\r\n+                \r\n+                // Filtra parcelas que vencem hoje\r\n+                const dueTodayParcels = boleto.parcels.filter(p => \r\n+                    !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === today.getTime()\r\n+                );\r\n+                // Adiciona os detalhes de cada parcela que vence hoje à lista\r\n+                dueTodayParcels.forEach(p => {\r\n+                    dueTodayParcelsDetails.push({\r\n+                        billName: boleto.name,\r\n+                        nfeNumber: boleto.nfeNumber,\r\n+                        parcelNumber: p.number,\r\n+                        amount: p.amount,\r\n+                        dueDate: p.dueDate\r\n+                    });\r\n+                });\r\n             }\r\n \r\n-            if (overdueParcelsDetails.length > 0 || dueTomorrowParcelsDetails.length > 0) {\r\n-                console.log(`Enviando e-mail para ${company.nomeEmpresa} com ${overdueParcelsDetails.length} parcelas vencidas e ${dueTomorrowParcelsDetails.length} a vencer amanhã.`);\r\n-                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTomorrowParcelsDetails);\r\n+            // Envia o e-mail apenas se houver algo a relatar (vencido ou a vencer hoje)\r\n+            if (overdueParcelsDetails.length > 0 || dueTodayParcelsDetails.length > 0) {\r\n+                console.log(`Enviando e-mail para ${company.nomeEmpresa} com ${overdueParcelsDetails.length} parcelas vencidas e ${dueTodayParcelsDetails.length} a vencer hoje.`);\r\n+                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTodayParcelsDetails);\r\n                 emailsSentCount++;\r\n             }\r\n         }\r\n         \r\n         const successMessage = `Verificação concluída. ${emailsSentCount} e-mails de relatório foram enviados.`;\r\n         console.log(successMessage);\r\n         res.status(200).json({ message: successMessage });\r\n+\r\n     } catch (error) {\r\n         console.error(\"Erro ao forçar o envio do e-mail:\", error);\r\n         res.status(500).json({ message: 'Ocorreu um erro ao executar a tarefa de e-mail.' });\r\n     }\r\n"
                },
                {
                    "date": 1752942232603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,13 +18,17 @@\n const rateLimit = require('express-rate-limit');\r\n const nfeRoutes = require('./routes/nfe');\r\n const app = express();\r\n const { sendDailyReportEmail } = require('./services/emailService');\r\n+const companyRoutes = require('./routes/company');\r\n+const categoryRoutes = require('./routes/categories');\r\n \r\n // Middlewares essenciais\r\n app.use(cors());\r\n app.use(express.json());\r\n app.use('/api/nfe', nfeRoutes);\r\n+app.use('/api/companies', companyRoutes);\r\n+app.use('/api/categories', categoryRoutes);\r\n \r\n // Middleware de Limite de Requisições para rotas de login\r\n const loginLimiter = rateLimit({\r\n     windowMs: 15 * 60 * 1000, // Janela de 15 minutos\r\n"
                },
                {
                    "date": 1752943160870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,8 @@\n const rateLimit = require('express-rate-limit');\r\n const nfeRoutes = require('./routes/nfe');\r\n const app = express();\r\n const { sendDailyReportEmail } = require('./services/emailService');\r\n-const companyRoutes = require('./routes/company');\r\n const categoryRoutes = require('./routes/categories');\r\n \r\n // Middlewares essenciais\r\n app.use(cors());\r\n"
                },
                {
                    "date": 1753280842562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,15 +19,17 @@\n const nfeRoutes = require('./routes/nfe');\r\n const app = express();\r\n const { sendDailyReportEmail } = require('./services/emailService');\r\n const categoryRoutes = require('./routes/categories');\r\n+const reportRoutes = require('./routes/reports');\r\n \r\n // Middlewares essenciais\r\n app.use(cors());\r\n app.use(express.json());\r\n app.use('/api/nfe', nfeRoutes);\r\n app.use('/api/companies', companyRoutes);\r\n app.use('/api/categories', categoryRoutes);\r\n+app.use('/api/reports', reportRoutes);\r\n \r\n // Middleware de Limite de Requisições para rotas de login\r\n const loginLimiter = rateLimit({\r\n     windowMs: 15 * 60 * 1000, // Janela de 15 minutos\r\n"
                },
                {
                    "date": 1753363503746,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,219 @@\n+// Carrega as variáveis de ambiente do arquivo .env\r\n+require('dotenv').config();\r\n+\r\n+const express = require('express');\r\n+const mongoose = require('mongoose');\r\n+const cors = require('cors');\r\n+const cron = require('node-cron');\r\n+const Company = require('./models/Company');\r\n+const Boleto = require('./models/Boleto');\r\n+const { sendOverdueReportEmail } = require('./services/emailService');\r\n+const authRoutes = require('./routes/auth');\r\n+const companyRoutes = require('./routes/company');\r\n+const boletoRoutes = require('./routes/boletos');\r\n+const permissionsRoutes = require('./routes/permissions');\r\n+const adminRoutes = require('./routes/admin');\r\n+const contactRoutes = require('./routes/contact');\r\n+const paymentRoutes = require('./routes/payments');\r\n+const rateLimit = require('express-rate-limit');\r\n+const nfeRoutes = require('./routes/nfe');\r\n+const app = express();\r\n+const { sendDailyReportEmail } = require('./services/emailService');\r\n+const categoryRoutes = require('./routes/categories');\r\n+const reportRoutes = require('./routes/reports');\r\n+const exportRoutes = require('./routes/export');\r\n+\r\n+// Middlewares essenciais\r\n+app.use(cors());\r\n+app.use(express.json());\r\n+app.use('/api/nfe', nfeRoutes);\r\n+app.use('/api/companies', companyRoutes);\r\n+app.use('/api/categories', categoryRoutes);\r\n+app.use('/api/reports', reportRoutes);\r\n+app.use('/api/export', exportRoutes);\r\n+\r\n+// Middleware de Limite de Requisições para rotas de login\r\n+const loginLimiter = rateLimit({\r\n+    windowMs: 15 * 60 * 1000, // Janela de 15 minutos\r\n+    max: 10, // Permite 10 tentativas de login por IP a cada 15 minutos\r\n+    message: { message: 'Muitas tentativas de login deste IP. Por favor, tente novamente após 15 minutos.' },\r\n+    standardHeaders: true,\r\n+    legacyHeaders: false,\r\n+});\r\n+app.use('/api/auth/login', loginLimiter);\r\n+\r\n+// Conexão com o Banco de Dados MongoDB\r\n+const dbURI = process.env.MONGODB_URI;\r\n+mongoose.connect(dbURI)\r\n+    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n+    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n+\r\n+// --- ROTAS DA API ---\r\n+\r\n+// Rota principal de \"saúde\" da API\r\n+app.get('/', (req, res) => {\r\n+    res.send('API do Organizador de Boletos está no ar!');\r\n+});\r\n+\r\n+// Uso das rotas importadas\r\n+app.use('/api/auth', authRoutes);\r\n+app.use('/api/companies', companyRoutes);\r\n+app.use('/api/boletos', boletoRoutes);\r\n+app.use('/api/permissions', permissionsRoutes);\r\n+app.use('/api/admin', adminRoutes);\r\n+app.use('/api/contact', contactRoutes);\r\n+app.use('/api/payments', paymentRoutes);\r\n+\r\n+// Rota temporária para testar o envio de e-mail (se ainda quiser mantê-la)\r\n+app.get('/api/test-email', async (req, res) => {\r\n+    console.log(\"Recebida requisição para testar e-mail...\");\r\n+    try {\r\n+        const testRecipientEmail = \"lobosti@outlook.com\";\r\n+        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n+        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n+    } catch (error) {\r\n+        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n+        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n+    }\r\n+});\r\n+\r\n+// Automação de envio de e-mail\r\n+cron.schedule('0 19 * * *', async () => {\r\n+    console.log('Executando verificação diária de boletos às 19:00...');\r\n+    try {\r\n+        // Define a data 'hoje' com o tempo zerado para comparações precisas\r\n+        const today = new Date();\r\n+        today.setHours(0, 0, 0, 0);\r\n+        \r\n+        // Define a data 'amanhã' também com o tempo zerado\r\n+        const tomorrow = new Date();\r\n+        tomorrow.setDate(today.getDate() + 1);\r\n+        tomorrow.setHours(0, 0, 0, 0);\r\n+\r\n+        // Busca todas as empresas que têm um e-mail cadastrado\r\n+        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n+\r\n+        for (const company of companies) {\r\n+            const allBoletos = await Boleto.find({ company: company._id });\r\n+            const overdueParcelsDetails = []; // Lista para parcelas vencidas (< hoje)\r\n+            const dueTodayParcelsDetails = [];  // Nova lista para parcelas que vencem hoje (= hoje)\r\n+\r\n+            for (const boleto of allBoletos) {\r\n+                // Filtra parcelas vencidas (data de vencimento é anterior a hoje)\r\n+                const overdueParcels = boleto.parcels.filter(p => \r\n+                    !p.paid && new Date(p.dueDate + 'T00:00:00') < today\r\n+                );\r\n+                // Adiciona os detalhes de cada parcela vencida à lista\r\n+                overdueParcels.forEach(p => {\r\n+                    overdueParcelsDetails.push({\r\n+                        billName: boleto.name,\r\n+                        nfeNumber: boleto.nfeNumber,\r\n+                        parcelNumber: p.number,\r\n+                        amount: p.amount,\r\n+                        dueDate: p.dueDate\r\n+                    });\r\n+                });\r\n+                \r\n+                // Filtra parcelas que vencem hoje\r\n+                const dueTodayParcels = boleto.parcels.filter(p => \r\n+                    !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === today.getTime()\r\n+                );\r\n+                // Adiciona os detalhes de cada parcela que vence hoje à lista\r\n+                dueTodayParcels.forEach(p => {\r\n+                    dueTodayParcelsDetails.push({\r\n+                        billName: boleto.name,\r\n+                        nfeNumber: boleto.nfeNumber,\r\n+                        parcelNumber: p.number,\r\n+                        amount: p.amount,\r\n+                        dueDate: p.dueDate\r\n+                    });\r\n+                });\r\n+            }\r\n+\r\n+            // Envia o e-mail apenas se houver algo a relatar (vencido ou a vencer hoje)\r\n+            if (overdueParcelsDetails.length > 0 || dueTodayParcelsDetails.length > 0) {\r\n+                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTodayParcelsDetails);\r\n+            }\r\n+        }\r\n+        console.log('Verificação diária concluída.');\r\n+    } catch (error) {\r\n+        console.error('Erro durante a execução da tarefa agendada:', error);\r\n+    }\r\n+}, {\r\n+    scheduled: true,\r\n+    timezone: \"America/Sao_Paulo\"\r\n+});\r\n+\r\n+// ROTA DE TESTE MANUAL PARA O E-MAIL DAS 19H\r\n+app.get('/api/force-overdue-email', async (req, res) => {\r\n+    console.log(\"Recebida requisição para forçar o envio do e-mail de relatório diário...\");\r\n+    try {\r\n+        // Define a data 'hoje' com o tempo zerado para comparações precisas\r\n+        const today = new Date();\r\n+        today.setHours(0, 0, 0, 0);\r\n+\r\n+        // Busca todas as empresas que têm um e-mail cadastrado\r\n+        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n+        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n+\r\n+        let emailsSentCount = 0;\r\n+        for (const company of companies) {\r\n+            const allBoletos = await Boleto.find({ company: company._id });\r\n+            const overdueParcelsDetails = []; // Lista para parcelas vencidas (< hoje)\r\n+            const dueTodayParcelsDetails = [];  // Lista para parcelas que vencem hoje (= hoje)\r\n+\r\n+            for (const boleto of allBoletos) {\r\n+                // Filtra parcelas vencidas (data de vencimento é anterior a hoje)\r\n+                const overdueParcels = boleto.parcels.filter(p => \r\n+                    !p.paid && new Date(p.dueDate + 'T00:00:00') < today\r\n+                );\r\n+                // Adiciona os detalhes de cada parcela vencida à lista\r\n+                overdueParcels.forEach(p => {\r\n+                    overdueParcelsDetails.push({\r\n+                        billName: boleto.name,\r\n+                        nfeNumber: boleto.nfeNumber,\r\n+                        parcelNumber: p.number,\r\n+                        amount: p.amount,\r\n+                        dueDate: p.dueDate\r\n+                    });\r\n+                });\r\n+                \r\n+                // Filtra parcelas que vencem hoje\r\n+                const dueTodayParcels = boleto.parcels.filter(p => \r\n+                    !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === today.getTime()\r\n+                );\r\n+                // Adiciona os detalhes de cada parcela que vence hoje à lista\r\n+                dueTodayParcels.forEach(p => {\r\n+                    dueTodayParcelsDetails.push({\r\n+                        billName: boleto.name,\r\n+                        nfeNumber: boleto.nfeNumber,\r\n+                        parcelNumber: p.number,\r\n+                        amount: p.amount,\r\n+                        dueDate: p.dueDate\r\n+                    });\r\n+                });\r\n+            }\r\n+\r\n+            // Envia o e-mail apenas se houver algo a relatar (vencido ou a vencer hoje)\r\n+            if (overdueParcelsDetails.length > 0 || dueTodayParcelsDetails.length > 0) {\r\n+                console.log(`Enviando e-mail para ${company.nomeEmpresa} com ${overdueParcelsDetails.length} parcelas vencidas e ${dueTodayParcelsDetails.length} a vencer hoje.`);\r\n+                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTodayParcelsDetails);\r\n+                emailsSentCount++;\r\n+            }\r\n+        }\r\n+        \r\n+        const successMessage = `Verificação concluída. ${emailsSentCount} e-mails de relatório foram enviados.`;\r\n+        console.log(successMessage);\r\n+        res.status(200).json({ message: successMessage });\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao forçar o envio do e-mail:\", error);\r\n+        res.status(500).json({ message: 'Ocorreu um erro ao executar a tarefa de e-mail.' });\r\n+    }\r\n+});\r\n+\r\n+// Define a porta e inicia o servidor\r\n+const PORT = process.env.PORT || 5000;\r\n+app.listen(PORT, () => {\r\n+    console.log(`Servidor rodando na porta ${PORT}`);\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753474576872,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,10 @@\n const exportRoutes = require('./routes/export');\r\n \r\n // Middlewares essenciais\r\n app.use(cors());\r\n-app.use(express.json());\r\n+app.use(express.json({ limit: '50mb' }));\r\n+app.use(express.urlencoded({ limit: '50mb', extended: true }));\r\n app.use('/api/nfe', nfeRoutes);\r\n app.use('/api/companies', companyRoutes);\r\n app.use('/api/categories', categoryRoutes);\r\n app.use('/api/reports', reportRoutes);\r\n@@ -215,222 +216,5 @@\n // Define a porta e inicia o servidor\r\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n     console.log(`Servidor rodando na porta ${PORT}`);\r\n-});\n-// Carrega as variáveis de ambiente do arquivo .env\r\n-require('dotenv').config();\r\n-\r\n-const express = require('express');\r\n-const mongoose = require('mongoose');\r\n-const cors = require('cors');\r\n-const cron = require('node-cron');\r\n-const Company = require('./models/Company');\r\n-const Boleto = require('./models/Boleto');\r\n-const { sendOverdueReportEmail } = require('./services/emailService');\r\n-const authRoutes = require('./routes/auth');\r\n-const companyRoutes = require('./routes/company');\r\n-const boletoRoutes = require('./routes/boletos');\r\n-const permissionsRoutes = require('./routes/permissions');\r\n-const adminRoutes = require('./routes/admin');\r\n-const contactRoutes = require('./routes/contact');\r\n-const paymentRoutes = require('./routes/payments');\r\n-const rateLimit = require('express-rate-limit');\r\n-const nfeRoutes = require('./routes/nfe');\r\n-const app = express();\r\n-const { sendDailyReportEmail } = require('./services/emailService');\r\n-const categoryRoutes = require('./routes/categories');\r\n-const reportRoutes = require('./routes/reports');\r\n-\r\n-// Middlewares essenciais\r\n-app.use(cors());\r\n-app.use(express.json());\r\n-app.use('/api/nfe', nfeRoutes);\r\n-app.use('/api/companies', companyRoutes);\r\n-app.use('/api/categories', categoryRoutes);\r\n-app.use('/api/reports', reportRoutes);\r\n-\r\n-// Middleware de Limite de Requisições para rotas de login\r\n-const loginLimiter = rateLimit({\r\n-    windowMs: 15 * 60 * 1000, // Janela de 15 minutos\r\n-    max: 10, // Permite 10 tentativas de login por IP a cada 15 minutos\r\n-    message: { message: 'Muitas tentativas de login deste IP. Por favor, tente novamente após 15 minutos.' },\r\n-    standardHeaders: true,\r\n-    legacyHeaders: false,\r\n-});\r\n-app.use('/api/auth/login', loginLimiter);\r\n-\r\n-// Conexão com o Banco de Dados MongoDB\r\n-const dbURI = process.env.MONGODB_URI;\r\n-mongoose.connect(dbURI)\r\n-    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n-    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n-\r\n-// --- ROTAS DA API ---\r\n-\r\n-// Rota principal de \"saúde\" da API\r\n-app.get('/', (req, res) => {\r\n-    res.send('API do Organizador de Boletos está no ar!');\r\n-});\r\n-\r\n-// Uso das rotas importadas\r\n-app.use('/api/auth', authRoutes);\r\n-app.use('/api/companies', companyRoutes);\r\n-app.use('/api/boletos', boletoRoutes);\r\n-app.use('/api/permissions', permissionsRoutes);\r\n-app.use('/api/admin', adminRoutes);\r\n-app.use('/api/contact', contactRoutes);\r\n-app.use('/api/payments', paymentRoutes);\r\n-\r\n-// Rota temporária para testar o envio de e-mail (se ainda quiser mantê-la)\r\n-app.get('/api/test-email', async (req, res) => {\r\n-    console.log(\"Recebida requisição para testar e-mail...\");\r\n-    try {\r\n-        const testRecipientEmail = \"lobosti@outlook.com\";\r\n-        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n-        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n-    } catch (error) {\r\n-        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n-        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n-    }\r\n-});\r\n-\r\n-// Automação de envio de e-mail\r\n-cron.schedule('0 19 * * *', async () => {\r\n-    console.log('Executando verificação diária de boletos às 19:00...');\r\n-    try {\r\n-        // Define a data 'hoje' com o tempo zerado para comparações precisas\r\n-        const today = new Date();\r\n-        today.setHours(0, 0, 0, 0);\r\n-        \r\n-        // Define a data 'amanhã' também com o tempo zerado\r\n-        const tomorrow = new Date();\r\n-        tomorrow.setDate(today.getDate() + 1);\r\n-        tomorrow.setHours(0, 0, 0, 0);\r\n-\r\n-        // Busca todas as empresas que têm um e-mail cadastrado\r\n-        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n-\r\n-        for (const company of companies) {\r\n-            const allBoletos = await Boleto.find({ company: company._id });\r\n-            const overdueParcelsDetails = []; // Lista para parcelas vencidas (< hoje)\r\n-            const dueTodayParcelsDetails = [];  // Nova lista para parcelas que vencem hoje (= hoje)\r\n-\r\n-            for (const boleto of allBoletos) {\r\n-                // Filtra parcelas vencidas (data de vencimento é anterior a hoje)\r\n-                const overdueParcels = boleto.parcels.filter(p => \r\n-                    !p.paid && new Date(p.dueDate + 'T00:00:00') < today\r\n-                );\r\n-                // Adiciona os detalhes de cada parcela vencida à lista\r\n-                overdueParcels.forEach(p => {\r\n-                    overdueParcelsDetails.push({\r\n-                        billName: boleto.name,\r\n-                        nfeNumber: boleto.nfeNumber,\r\n-                        parcelNumber: p.number,\r\n-                        amount: p.amount,\r\n-                        dueDate: p.dueDate\r\n-                    });\r\n-                });\r\n-                \r\n-                // Filtra parcelas que vencem hoje\r\n-                const dueTodayParcels = boleto.parcels.filter(p => \r\n-                    !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === today.getTime()\r\n-                );\r\n-                // Adiciona os detalhes de cada parcela que vence hoje à lista\r\n-                dueTodayParcels.forEach(p => {\r\n-                    dueTodayParcelsDetails.push({\r\n-                        billName: boleto.name,\r\n-                        nfeNumber: boleto.nfeNumber,\r\n-                        parcelNumber: p.number,\r\n-                        amount: p.amount,\r\n-                        dueDate: p.dueDate\r\n-                    });\r\n-                });\r\n-            }\r\n-\r\n-            // Envia o e-mail apenas se houver algo a relatar (vencido ou a vencer hoje)\r\n-            if (overdueParcelsDetails.length > 0 || dueTodayParcelsDetails.length > 0) {\r\n-                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTodayParcelsDetails);\r\n-            }\r\n-        }\r\n-        console.log('Verificação diária concluída.');\r\n-    } catch (error) {\r\n-        console.error('Erro durante a execução da tarefa agendada:', error);\r\n-    }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\"\r\n-});\r\n-\r\n-// ROTA DE TESTE MANUAL PARA O E-MAIL DAS 19H\r\n-app.get('/api/force-overdue-email', async (req, res) => {\r\n-    console.log(\"Recebida requisição para forçar o envio do e-mail de relatório diário...\");\r\n-    try {\r\n-        // Define a data 'hoje' com o tempo zerado para comparações precisas\r\n-        const today = new Date();\r\n-        today.setHours(0, 0, 0, 0);\r\n-\r\n-        // Busca todas as empresas que têm um e-mail cadastrado\r\n-        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n-        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n-\r\n-        let emailsSentCount = 0;\r\n-        for (const company of companies) {\r\n-            const allBoletos = await Boleto.find({ company: company._id });\r\n-            const overdueParcelsDetails = []; // Lista para parcelas vencidas (< hoje)\r\n-            const dueTodayParcelsDetails = [];  // Lista para parcelas que vencem hoje (= hoje)\r\n-\r\n-            for (const boleto of allBoletos) {\r\n-                // Filtra parcelas vencidas (data de vencimento é anterior a hoje)\r\n-                const overdueParcels = boleto.parcels.filter(p => \r\n-                    !p.paid && new Date(p.dueDate + 'T00:00:00') < today\r\n-                );\r\n-                // Adiciona os detalhes de cada parcela vencida à lista\r\n-                overdueParcels.forEach(p => {\r\n-                    overdueParcelsDetails.push({\r\n-                        billName: boleto.name,\r\n-                        nfeNumber: boleto.nfeNumber,\r\n-                        parcelNumber: p.number,\r\n-                        amount: p.amount,\r\n-                        dueDate: p.dueDate\r\n-                    });\r\n-                });\r\n-                \r\n-                // Filtra parcelas que vencem hoje\r\n-                const dueTodayParcels = boleto.parcels.filter(p => \r\n-                    !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === today.getTime()\r\n-                );\r\n-                // Adiciona os detalhes de cada parcela que vence hoje à lista\r\n-                dueTodayParcels.forEach(p => {\r\n-                    dueTodayParcelsDetails.push({\r\n-                        billName: boleto.name,\r\n-                        nfeNumber: boleto.nfeNumber,\r\n-                        parcelNumber: p.number,\r\n-                        amount: p.amount,\r\n-                        dueDate: p.dueDate\r\n-                    });\r\n-                });\r\n-            }\r\n-\r\n-            // Envia o e-mail apenas se houver algo a relatar (vencido ou a vencer hoje)\r\n-            if (overdueParcelsDetails.length > 0 || dueTodayParcelsDetails.length > 0) {\r\n-                console.log(`Enviando e-mail para ${company.nomeEmpresa} com ${overdueParcelsDetails.length} parcelas vencidas e ${dueTodayParcelsDetails.length} a vencer hoje.`);\r\n-                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTodayParcelsDetails);\r\n-                emailsSentCount++;\r\n-            }\r\n-        }\r\n-        \r\n-        const successMessage = `Verificação concluída. ${emailsSentCount} e-mails de relatório foram enviados.`;\r\n-        console.log(successMessage);\r\n-        res.status(200).json({ message: successMessage });\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao forçar o envio do e-mail:\", error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro ao executar a tarefa de e-mail.' });\r\n-    }\r\n-});\r\n-\r\n-// Define a porta e inicia o servidor\r\n-const PORT = process.env.PORT || 5000;\r\n-app.listen(PORT, () => {\r\n-    console.log(`Servidor rodando na porta ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753533063084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,215 +4,155 @@\n const express = require('express');\r\n const mongoose = require('mongoose');\r\n const cors = require('cors');\r\n const cron = require('node-cron');\r\n-const Company = require('./models/Company');\r\n-const Boleto = require('./models/Boleto');\r\n-const { sendOverdueReportEmail } = require('./services/emailService');\r\n-const authRoutes = require('./routes/auth');\r\n-const companyRoutes = require('./routes/company');\r\n-const boletoRoutes = require('./routes/boletos');\r\n-const permissionsRoutes = require('./routes/permissions');\r\n-const adminRoutes = require('./routes/admin');\r\n-const contactRoutes = require('./routes/contact');\r\n-const paymentRoutes = require('./routes/payments');\r\n const rateLimit = require('express-rate-limit');\r\n-const nfeRoutes = require('./routes/nfe');\r\n+\r\n+// =================================================================================\r\n+// NOVA SEÇÃO: Gerenciamento de Conexões com o Banco de Dados\r\n+// =================================================================================\r\n+\r\n+// 1. Conexão Principal com o Banco MESTRE\r\n+const masterDbUri = process.env.MONGODB_URI; // Usaremos a URI principal para o banco Mestre\r\n+const masterConnection = mongoose.createConnection(masterDbUri);\r\n+\r\n+masterConnection.on('connected', () => {\r\n+    console.log('Conectado ao MongoDB Mestre com sucesso!');\r\n+});\r\n+masterConnection.on('error', (err) => {\r\n+    console.error('Falha ao conectar ao MongoDB Mestre:', err);\r\n+});\r\n+\r\n+// Importamos o modelo do banco Mestre\r\n+const MasterCompany = require('./models/MasterCompany')(masterConnection);\r\n+\r\n+// 2. Lógica para Conexões Dinâmicas com os Bancos das Empresas (Tenants)\r\n+const tenantConnections = {}; // Cache para guardar as conexões ativas das empresas\r\n+\r\n+async function getTenantConnection(dbName) {\r\n+    if (tenantConnections[dbName] && tenantConnections[dbName].readyState === 1) {\r\n+        // Se já temos uma conexão ativa, a reutilizamos\r\n+        return tenantConnections[dbName];\r\n+    }\r\n+\r\n+    // Se não, criamos uma nova conexão\r\n+    // Assumimos que todos os bancos de dados estão no mesmo servidor/cluster do Mestre\r\n+    const tenantDbUri = masterDbUri.replace(/\\/[^/]+$/, `/${dbName}`);\r\n+    \r\n+    const newConnection = mongoose.createConnection(tenantDbUri);\r\n+    \r\n+    newConnection.on('connected', () => {\r\n+        console.log(`Conectado ao banco de dados da empresa: ${dbName}`);\r\n+    });\r\n+    newConnection.on('error', (err) => {\r\n+        console.error(`Falha ao conectar ao banco de dados ${dbName}:`, err);\r\n+    });\r\n+\r\n+    tenantConnections[dbName] = newConnection;\r\n+    return newConnection;\r\n+}\r\n+\r\n+\r\n+// =================================================================================\r\n+// Configuração do Express (continua similar)\r\n+// =================================================================================\r\n const app = express();\r\n-const { sendDailyReportEmail } = require('./services/emailService');\r\n-const categoryRoutes = require('./routes/categories');\r\n-const reportRoutes = require('./routes/reports');\r\n-const exportRoutes = require('./routes/export');\r\n \r\n // Middlewares essenciais\r\n app.use(cors());\r\n app.use(express.json({ limit: '50mb' }));\r\n app.use(express.urlencoded({ limit: '50mb', extended: true }));\r\n-app.use('/api/nfe', nfeRoutes);\r\n-app.use('/api/companies', companyRoutes);\r\n-app.use('/api/categories', categoryRoutes);\r\n-app.use('/api/reports', reportRoutes);\r\n-app.use('/api/export', exportRoutes);\r\n \r\n-// Middleware de Limite de Requisições para rotas de login\r\n const loginLimiter = rateLimit({\r\n-    windowMs: 15 * 60 * 1000, // Janela de 15 minutos\r\n-    max: 10, // Permite 10 tentativas de login por IP a cada 15 minutos\r\n+    windowMs: 15 * 60 * 1000,\r\n+    max: 10,\r\n     message: { message: 'Muitas tentativas de login deste IP. Por favor, tente novamente após 15 minutos.' },\r\n     standardHeaders: true,\r\n     legacyHeaders: false,\r\n });\r\n-app.use('/api/auth/login', loginLimiter);\r\n \r\n-// Conexão com o Banco de Dados MongoDB\r\n-const dbURI = process.env.MONGODB_URI;\r\n-mongoose.connect(dbURI)\r\n-    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n-    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n+// Importação das rotas (sem mudanças aqui)\r\n+const authRoutes = require('./routes/auth');\r\n+const companyRoutes = require('./routes/company');\r\n+const boletoRoutes = require('./routes/boletos');\r\n+const permissionsRoutes = require('./routes/permissions');\r\n+const adminRoutes = require('./routes/admin');\r\n+const contactRoutes = require('./routes/contact');\r\n+const paymentRoutes = require('./routes/payments');\r\n+const nfeRoutes = require('./routes/nfe');\r\n+const categoryRoutes = require('./routes/categories');\r\n+const reportRoutes = require('./routes/reports');\r\n+const exportRoutes = require('./routes/export');\r\n \r\n-// --- ROTAS DA API ---\r\n \r\n-// Rota principal de \"saúde\" da API\r\n-app.get('/', (req, res) => {\r\n-    res.send('API do Organizador de Boletos está no ar!');\r\n-});\r\n+// =================================================================================\r\n+// NOVA LÓGICA DE MIDDLEWARES E ROTAS\r\n+// =================================================================================\r\n \r\n-// Uso das rotas importadas\r\n-app.use('/api/auth', authRoutes);\r\n-app.use('/api/companies', companyRoutes);\r\n-app.use('/api/boletos', boletoRoutes);\r\n-app.use('/api/permissions', permissionsRoutes);\r\n-app.use('/api/admin', adminRoutes);\r\n-app.use('/api/contact', contactRoutes);\r\n-app.use('/api/payments', paymentRoutes);\r\n-\r\n-// Rota temporária para testar o envio de e-mail (se ainda quiser mantê-la)\r\n-app.get('/api/test-email', async (req, res) => {\r\n-    console.log(\"Recebida requisição para testar e-mail...\");\r\n+// 3. NOVO MIDDLEWARE: Para identificar e conectar ao banco da empresa\r\n+const tenantMiddleware = async (req, res, next) => {\r\n     try {\r\n-        const testRecipientEmail = \"lobosti@outlook.com\";\r\n-        await sendOverdueReportEmail(testRecipientEmail, \"Empresa de Teste\", 7);\r\n-        res.status(200).send(\"Tentativa de envio de e-mail de teste realizada. Verifique sua caixa de entrada e o console do servidor.\");\r\n-    } catch (error) {\r\n-        console.error(\"Erro na rota de teste de e-mail:\", error);\r\n-        res.status(500).send(\"Erro ao tentar enviar e-mail de teste.\");\r\n-    }\r\n-});\r\n+        if (!req.user || !req.user.companyId) {\r\n+            return res.status(401).json({ message: 'Informações de usuário ou empresa ausentes.' });\r\n+        }\r\n+        \r\n+        // Busca a empresa no banco MESTRE para descobrir o nome do seu banco de dados\r\n+        const company = await MasterCompany.findById(req.user.companyId);\r\n+        if (!company || !company.dbName) {\r\n+            return res.status(404).json({ message: 'Empresa não encontrada no registro mestre.' });\r\n+        }\r\n \r\n-// Automação de envio de e-mail\r\n-cron.schedule('0 19 * * *', async () => {\r\n-    console.log('Executando verificação diária de boletos às 19:00...');\r\n-    try {\r\n-        // Define a data 'hoje' com o tempo zerado para comparações precisas\r\n-        const today = new Date();\r\n-        today.setHours(0, 0, 0, 0);\r\n+        // Obtém a conexão para o banco da empresa\r\n+        const tenantDb = await getTenantConnection(company.dbName);\r\n         \r\n-        // Define a data 'amanhã' também com o tempo zerado\r\n-        const tomorrow = new Date();\r\n-        tomorrow.setDate(today.getDate() + 1);\r\n-        tomorrow.setHours(0, 0, 0, 0);\r\n+        // Anexa a conexão ao objeto 'req' para que as rotas possam usá-la\r\n+        req.tenantDb = tenantDb;\r\n+        next();\r\n \r\n-        // Busca todas as empresas que têm um e-mail cadastrado\r\n-        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n-\r\n-        for (const company of companies) {\r\n-            const allBoletos = await Boleto.find({ company: company._id });\r\n-            const overdueParcelsDetails = []; // Lista para parcelas vencidas (< hoje)\r\n-            const dueTodayParcelsDetails = [];  // Nova lista para parcelas que vencem hoje (= hoje)\r\n-\r\n-            for (const boleto of allBoletos) {\r\n-                // Filtra parcelas vencidas (data de vencimento é anterior a hoje)\r\n-                const overdueParcels = boleto.parcels.filter(p => \r\n-                    !p.paid && new Date(p.dueDate + 'T00:00:00') < today\r\n-                );\r\n-                // Adiciona os detalhes de cada parcela vencida à lista\r\n-                overdueParcels.forEach(p => {\r\n-                    overdueParcelsDetails.push({\r\n-                        billName: boleto.name,\r\n-                        nfeNumber: boleto.nfeNumber,\r\n-                        parcelNumber: p.number,\r\n-                        amount: p.amount,\r\n-                        dueDate: p.dueDate\r\n-                    });\r\n-                });\r\n-                \r\n-                // Filtra parcelas que vencem hoje\r\n-                const dueTodayParcels = boleto.parcels.filter(p => \r\n-                    !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === today.getTime()\r\n-                );\r\n-                // Adiciona os detalhes de cada parcela que vence hoje à lista\r\n-                dueTodayParcels.forEach(p => {\r\n-                    dueTodayParcelsDetails.push({\r\n-                        billName: boleto.name,\r\n-                        nfeNumber: boleto.nfeNumber,\r\n-                        parcelNumber: p.number,\r\n-                        amount: p.amount,\r\n-                        dueDate: p.dueDate\r\n-                    });\r\n-                });\r\n-            }\r\n-\r\n-            // Envia o e-mail apenas se houver algo a relatar (vencido ou a vencer hoje)\r\n-            if (overdueParcelsDetails.length > 0 || dueTodayParcelsDetails.length > 0) {\r\n-                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTodayParcelsDetails);\r\n-            }\r\n-        }\r\n-        console.log('Verificação diária concluída.');\r\n     } catch (error) {\r\n-        console.error('Erro durante a execução da tarefa agendada:', error);\r\n+        console.error(\"Erro no middleware de tenant:\", error);\r\n+        return res.status(500).json({ message: 'Erro ao processar a requisição da empresa.' });\r\n     }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\"\r\n+};\r\n+\r\n+// Rota de \"saúde\" da API\r\n+app.get('/', (req, res) => {\r\n+    res.send('API do Organizador de Boletos está no ar!');\r\n });\r\n \r\n-// ROTA DE TESTE MANUAL PARA O E-MAIL DAS 19H\r\n-app.get('/api/force-overdue-email', async (req, res) => {\r\n-    console.log(\"Recebida requisição para forçar o envio do e-mail de relatório diário...\");\r\n-    try {\r\n-        // Define a data 'hoje' com o tempo zerado para comparações precisas\r\n-        const today = new Date();\r\n-        today.setHours(0, 0, 0, 0);\r\n+// Middleware para passar a conexão MESTRE para as rotas que precisam dela\r\n+const masterDbMiddleware = (req, res, next) => {\r\n+    req.masterDb = masterConnection;\r\n+    next();\r\n+};\r\n \r\n-        // Busca todas as empresas que têm um e-mail cadastrado\r\n-        const companies = await Company.find({ email: { $exists: true, $ne: '' } });\r\n-        console.log(`Encontradas ${companies.length} empresas com e-mail para verificar.`);\r\n+// 4. APLICAÇÃO DOS MIDDLEWARES E ROTAS\r\n+const { protect } = require('./middleware/authMiddleware'); // O 'protect' continua o mesmo\r\n \r\n-        let emailsSentCount = 0;\r\n-        for (const company of companies) {\r\n-            const allBoletos = await Boleto.find({ company: company._id });\r\n-            const overdueParcelsDetails = []; // Lista para parcelas vencidas (< hoje)\r\n-            const dueTodayParcelsDetails = [];  // Lista para parcelas que vencem hoje (= hoje)\r\n+// Rotas que usam o banco MESTRE\r\n+app.use('/api/auth', masterDbMiddleware, authRoutes);\r\n+app.use('/api/admin', masterDbMiddleware, adminRoutes);\r\n+app.use('/api/companies', protect, masterDbMiddleware, companyRoutes); // Gerenciamento de empresas pelo admin\r\n+app.use('/api/payments', protect, masterDbMiddleware, paymentRoutes); // Pagamentos também usam o mestre\r\n \r\n-            for (const boleto of allBoletos) {\r\n-                // Filtra parcelas vencidas (data de vencimento é anterior a hoje)\r\n-                const overdueParcels = boleto.parcels.filter(p => \r\n-                    !p.paid && new Date(p.dueDate + 'T00:00:00') < today\r\n-                );\r\n-                // Adiciona os detalhes de cada parcela vencida à lista\r\n-                overdueParcels.forEach(p => {\r\n-                    overdueParcelsDetails.push({\r\n-                        billName: boleto.name,\r\n-                        nfeNumber: boleto.nfeNumber,\r\n-                        parcelNumber: p.number,\r\n-                        amount: p.amount,\r\n-                        dueDate: p.dueDate\r\n-                    });\r\n-                });\r\n-                \r\n-                // Filtra parcelas que vencem hoje\r\n-                const dueTodayParcels = boleto.parcels.filter(p => \r\n-                    !p.paid && new Date(p.dueDate + 'T00:00:00').getTime() === today.getTime()\r\n-                );\r\n-                // Adiciona os detalhes de cada parcela que vence hoje à lista\r\n-                dueTodayParcels.forEach(p => {\r\n-                    dueTodayParcelsDetails.push({\r\n-                        billName: boleto.name,\r\n-                        nfeNumber: boleto.nfeNumber,\r\n-                        parcelNumber: p.number,\r\n-                        amount: p.amount,\r\n-                        dueDate: p.dueDate\r\n-                    });\r\n-                });\r\n-            }\r\n+// Rotas que usam o banco de dados da EMPRESA (passam pelo 'tenantMiddleware')\r\n+app.use('/api/boletos', protect, tenantMiddleware, boletoRoutes);\r\n+app.use('/api/categories', protect, tenantMiddleware, categoryRoutes);\r\n+app.use('/api/reports', protect, tenantMiddleware, reportRoutes);\r\n+app.use('/api/export', protect, tenantMiddleware, exportRoutes);\r\n+app.use('/api/permissions', protect, tenantMiddleware, permissionsRoutes);\r\n+app.use('/api/nfe', protect, nfeRoutes); // NFe não usa o banco, então não precisa do middleware\r\n \r\n-            // Envia o e-mail apenas se houver algo a relatar (vencido ou a vencer hoje)\r\n-            if (overdueParcelsDetails.length > 0 || dueTodayParcelsDetails.length > 0) {\r\n-                console.log(`Enviando e-mail para ${company.nomeEmpresa} com ${overdueParcelsDetails.length} parcelas vencidas e ${dueTodayParcelsDetails.length} a vencer hoje.`);\r\n-                await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcelsDetails, dueTodayParcelsDetails);\r\n-                emailsSentCount++;\r\n-            }\r\n-        }\r\n-        \r\n-        const successMessage = `Verificação concluída. ${emailsSentCount} e-mails de relatório foram enviados.`;\r\n-        console.log(successMessage);\r\n-        res.status(200).json({ message: successMessage });\r\n+// Rotas públicas que não usam banco de dados\r\n+app.use('/api/contact', contactRoutes);\r\n \r\n-    } catch (error) {\r\n-        console.error(\"Erro ao forçar o envio do e-mail:\", error);\r\n-        res.status(500).json({ message: 'Ocorreu um erro ao executar a tarefa de e-mail.' });\r\n-    }\r\n+// Tarefas agendadas (CRON) - A lógica precisará ser adaptada no futuro para rodar para todas as empresas. Por enquanto, deixamos comentado.\r\n+/*\r\n+cron.schedule('0 19 * * *', async () => {\r\n+    // ... a lógica do cron precisará ser reescrita para buscar todas as empresas no banco mestre\r\n+    // e então se conectar a cada banco de empresa para verificar os boletos.\r\n });\r\n+*/\r\n \r\n // Define a porta e inicia o servidor\r\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n"
                },
                {
                    "date": 1753533387799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -152,9 +152,12 @@\n     // e então se conectar a cada banco de empresa para verificar os boletos.\r\n });\r\n */\r\n \r\n+module.exports = { getTenantConnection };\r\n+\r\n // Define a porta e inicia o servidor\r\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n\\ No newline at end of file\n     console.log(`Servidor rodando na porta ${PORT}`);\r\n-});\n+});\r\n+\r\n"
                },
                {
                    "date": 1753533636353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,10 +130,11 @@\n \r\n // Rotas que usam o banco MESTRE\r\n app.use('/api/auth', masterDbMiddleware, authRoutes);\r\n app.use('/api/admin', masterDbMiddleware, adminRoutes);\r\n-app.use('/api/companies', protect, masterDbMiddleware, companyRoutes); // Gerenciamento de empresas pelo admin\r\n-app.use('/api/payments', protect, masterDbMiddleware, paymentRoutes); // Pagamentos também usam o mestre\r\n+app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n+app.use('/api/payments', protect, masterDbMiddleware, paymentRoutes); \r\n+app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n \r\n // Rotas que usam o banco de dados da EMPRESA (passam pelo 'tenantMiddleware')\r\n app.use('/api/boletos', protect, tenantMiddleware, boletoRoutes);\r\n app.use('/api/categories', protect, tenantMiddleware, categoryRoutes);\r\n@@ -159,4 +160,5 @@\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n     console.log(`Servidor rodando na porta ${PORT}`);\r\n });\r\n+\r\n"
                },
                {
                    "date": 1753535743786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,64 +1,20 @@\n+// D:\\SCripts\\SiteLobos\\Servidor\\server.js\r\n+\r\n // Carrega as variáveis de ambiente do arquivo .env\r\n require('dotenv').config();\r\n \r\n const express = require('express');\r\n-const mongoose = require('mongoose');\r\n const cors = require('cors');\r\n-const cron = require('node-cron');\r\n const rateLimit = require('express-rate-limit');\r\n \r\n-// =================================================================================\r\n-// NOVA SEÇÃO: Gerenciamento de Conexões com o Banco de Dados\r\n-// =================================================================================\r\n+// 1. IMPORTA A LÓGICA DE CONEXÃO DO NOVO ARQUIVO\r\n+const { masterConnection, getTenantConnection } = require('./config/db');\r\n+const MasterCompany = require('./models/MasterCompany');\r\n \r\n-// 1. Conexão Principal com o Banco MESTRE\r\n-const masterDbUri = process.env.MONGODB_URI; // Usaremos a URI principal para o banco Mestre\r\n-const masterConnection = mongoose.createConnection(masterDbUri);\r\n-\r\n-masterConnection.on('connected', () => {\r\n-    console.log('Conectado ao MongoDB Mestre com sucesso!');\r\n-});\r\n-masterConnection.on('error', (err) => {\r\n-    console.error('Falha ao conectar ao MongoDB Mestre:', err);\r\n-});\r\n-\r\n-// Importamos o modelo do banco Mestre\r\n-const MasterCompany = require('./models/MasterCompany')(masterConnection);\r\n-\r\n-// 2. Lógica para Conexões Dinâmicas com os Bancos das Empresas (Tenants)\r\n-const tenantConnections = {}; // Cache para guardar as conexões ativas das empresas\r\n-\r\n-async function getTenantConnection(dbName) {\r\n-    if (tenantConnections[dbName] && tenantConnections[dbName].readyState === 1) {\r\n-        // Se já temos uma conexão ativa, a reutilizamos\r\n-        return tenantConnections[dbName];\r\n-    }\r\n-\r\n-    // Se não, criamos uma nova conexão\r\n-    // Assumimos que todos os bancos de dados estão no mesmo servidor/cluster do Mestre\r\n-    const tenantDbUri = masterDbUri.replace(/\\/[^/]+$/, `/${dbName}`);\r\n-    \r\n-    const newConnection = mongoose.createConnection(tenantDbUri);\r\n-    \r\n-    newConnection.on('connected', () => {\r\n-        console.log(`Conectado ao banco de dados da empresa: ${dbName}`);\r\n-    });\r\n-    newConnection.on('error', (err) => {\r\n-        console.error(`Falha ao conectar ao banco de dados ${dbName}:`, err);\r\n-    });\r\n-\r\n-    tenantConnections[dbName] = newConnection;\r\n-    return newConnection;\r\n-}\r\n-\r\n-\r\n-// =================================================================================\r\n-// Configuração do Express (continua similar)\r\n-// =================================================================================\r\n const app = express();\r\n \r\n-// Middlewares essenciais\r\n+// 2. MIDDLEWARES GERAIS\r\n app.use(cors());\r\n app.use(express.json({ limit: '50mb' }));\r\n app.use(express.urlencoded({ limit: '50mb', extended: true }));\r\n \r\n@@ -69,9 +25,9 @@\n     standardHeaders: true,\r\n     legacyHeaders: false,\r\n });\r\n \r\n-// Importação das rotas (sem mudanças aqui)\r\n+// 3. IMPORTAÇÃO DE TODAS AS ROTAS\r\n const authRoutes = require('./routes/auth');\r\n const companyRoutes = require('./routes/company');\r\n const boletoRoutes = require('./routes/boletos');\r\n const permissionsRoutes = require('./routes/permissions');\r\n@@ -81,84 +37,77 @@\n const nfeRoutes = require('./routes/nfe');\r\n const categoryRoutes = require('./routes/categories');\r\n const reportRoutes = require('./routes/reports');\r\n const exportRoutes = require('./routes/export');\r\n+const { protect } = require('./middleware/authMiddleware');\r\n \r\n \r\n-// =================================================================================\r\n-// NOVA LÓGICA DE MIDDLEWARES E ROTAS\r\n-// =================================================================================\r\n-\r\n-// 3. NOVO MIDDLEWARE: Para identificar e conectar ao banco da empresa\r\n+// 4. DEFINIÇÃO DOS MIDDLEWARES DE CONEXÃO\r\n+// Middleware para identificar e conectar ao banco da empresa (tenant)\r\n const tenantMiddleware = async (req, res, next) => {\r\n     try {\r\n         if (!req.user || !req.user.companyId) {\r\n             return res.status(401).json({ message: 'Informações de usuário ou empresa ausentes.' });\r\n         }\r\n         \r\n-        // Busca a empresa no banco MESTRE para descobrir o nome do seu banco de dados\r\n         const company = await MasterCompany.findById(req.user.companyId);\r\n         if (!company || !company.dbName) {\r\n             return res.status(404).json({ message: 'Empresa não encontrada no registro mestre.' });\r\n         }\r\n \r\n-        // Obtém a conexão para o banco da empresa\r\n-        const tenantDb = await getTenantConnection(company.dbName);\r\n-        \r\n-        // Anexa a conexão ao objeto 'req' para que as rotas possam usá-la\r\n-        req.tenantDb = tenantDb;\r\n+        req.tenantDb = await getTenantConnection(company.dbName);\r\n+        req.company = company; // Passa os dados da empresa (permissões, etc.) para as rotas\r\n         next();\r\n-\r\n     } catch (error) {\r\n         console.error(\"Erro no middleware de tenant:\", error);\r\n         return res.status(500).json({ message: 'Erro ao processar a requisição da empresa.' });\r\n     }\r\n };\r\n \r\n-// Rota de \"saúde\" da API\r\n-app.get('/', (req, res) => {\r\n-    res.send('API do Organizador de Boletos está no ar!');\r\n-});\r\n-\r\n // Middleware para passar a conexão MESTRE para as rotas que precisam dela\r\n const masterDbMiddleware = (req, res, next) => {\r\n     req.masterDb = masterConnection;\r\n     next();\r\n };\r\n \r\n-// 4. APLICAÇÃO DOS MIDDLEWARES E ROTAS\r\n-const { protect } = require('./middleware/authMiddleware'); // O 'protect' continua o mesmo\r\n \r\n+// 5. APLICAÇÃO DAS ROTAS E MIDDLEWARES\r\n+app.get('/', (req, res) => {\r\n+    res.send('API do Organizador de Boletos está no ar!');\r\n+});\r\n+\r\n+// Rotas públicas (não precisam de 'protect' nem de banco de dados específico)\r\n+app.use('/api/contact', contactRoutes);\r\n+\r\n // Rotas que usam o banco MESTRE\r\n+app.use('/api/auth/login', loginLimiter); // Aplica o rate limit apenas ao login\r\n app.use('/api/auth', masterDbMiddleware, authRoutes);\r\n-app.use('/api/admin', masterDbMiddleware, adminRoutes);\r\n+app.use('/api/admin', protect, masterDbMiddleware, adminRoutes);\r\n app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n-app.use('/api/payments', protect, masterDbMiddleware, paymentRoutes); \r\n+app.use('/api/payments', protect, masterDbMiddleware, paymentRoutes);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n \r\n-// Rotas que usam o banco de dados da EMPRESA (passam pelo 'tenantMiddleware')\r\n+// Rotas que usam o banco de dados da EMPRESA (precisam do 'protect' e do 'tenantMiddleware')\r\n app.use('/api/boletos', protect, tenantMiddleware, boletoRoutes);\r\n app.use('/api/categories', protect, tenantMiddleware, categoryRoutes);\r\n app.use('/api/reports', protect, tenantMiddleware, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, exportRoutes);\r\n-app.use('/api/permissions', protect, tenantMiddleware, permissionsRoutes);\r\n-app.use('/api/nfe', protect, nfeRoutes); // NFe não usa o banco, então não precisa do middleware\r\n+app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-// Rotas públicas que não usam banco de dados\r\n-app.use('/api/contact', contactRoutes);\r\n-\r\n-// Tarefas agendadas (CRON) - A lógica precisará ser adaptada no futuro para rodar para todas as empresas. Por enquanto, deixamos comentado.\r\n+// A lógica do Cron precisará ser reescrita no futuro para funcionar com a nova arquitetura.\r\n+// Por enquanto, a deixamos comentada.\r\n /*\r\n+const cron = require('node-cron');\r\n cron.schedule('0 19 * * *', async () => {\r\n-    // ... a lógica do cron precisará ser reescrita para buscar todas as empresas no banco mestre\r\n-    // e então se conectar a cada banco de empresa para verificar os boletos.\r\n+    // Nova lógica:\r\n+    // 1. Buscar todas as empresas no banco Mestre.\r\n+    // 2. Fazer um loop por cada empresa.\r\n+    // 3. Para cada empresa, obter a conexão com seu banco de dados.\r\n+    // 4. Rodar a verificação de boletos vencidos dentro daquele banco de dados.\r\n });\r\n */\r\n \r\n-module.exports = { getTenantConnection };\r\n-\r\n-// Define a porta e inicia o servidor\r\n+// 6. INICIA O SERVIDOR\r\n const PORT = process.env.PORT || 5000;\r\n app.listen(PORT, () => {\r\n     console.log(`Servidor rodando na porta ${PORT}`);\r\n-});\r\n-\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753535998118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-// D:\\SCripts\\SiteLobos\\Servidor\\server.js\r\n-\r\n // Carrega as variáveis de ambiente do arquivo .env\r\n require('dotenv').config();\r\n \r\n const express = require('express');\r\n@@ -38,8 +36,9 @@\n const categoryRoutes = require('./routes/categories');\r\n const reportRoutes = require('./routes/reports');\r\n const exportRoutes = require('./routes/export');\r\n const { protect } = require('./middleware/authMiddleware');\r\n+const { tenantMiddleware } = require('./middleware/tenantMiddleware');\r\n \r\n \r\n // 4. DEFINIÇÃO DOS MIDDLEWARES DE CONEXÃO\r\n // Middleware para identificar e conectar ao banco da empresa (tenant)\r\n"
                },
                {
                    "date": 1753536223753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,31 +38,8 @@\n const exportRoutes = require('./routes/export');\r\n const { protect } = require('./middleware/authMiddleware');\r\n const { tenantMiddleware } = require('./middleware/tenantMiddleware');\r\n \r\n-\r\n-// 4. DEFINIÇÃO DOS MIDDLEWARES DE CONEXÃO\r\n-// Middleware para identificar e conectar ao banco da empresa (tenant)\r\n-const tenantMiddleware = async (req, res, next) => {\r\n-    try {\r\n-        if (!req.user || !req.user.companyId) {\r\n-            return res.status(401).json({ message: 'Informações de usuário ou empresa ausentes.' });\r\n-        }\r\n-        \r\n-        const company = await MasterCompany.findById(req.user.companyId);\r\n-        if (!company || !company.dbName) {\r\n-            return res.status(404).json({ message: 'Empresa não encontrada no registro mestre.' });\r\n-        }\r\n-\r\n-        req.tenantDb = await getTenantConnection(company.dbName);\r\n-        req.company = company; // Passa os dados da empresa (permissões, etc.) para as rotas\r\n-        next();\r\n-    } catch (error) {\r\n-        console.error(\"Erro no middleware de tenant:\", error);\r\n-        return res.status(500).json({ message: 'Erro ao processar a requisição da empresa.' });\r\n-    }\r\n-};\r\n-\r\n // Middleware para passar a conexão MESTRE para as rotas que precisam dela\r\n const masterDbMiddleware = (req, res, next) => {\r\n     req.masterDb = masterConnection;\r\n     next();\r\n"
                },
                {
                    "date": 1753537362017,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,13 @@\n-// Carrega as variáveis de ambiente do arquivo .env\r\n+// D:\\SCripts\\SiteLobos\\Servidor\\server.js\r\n+\r\n require('dotenv').config();\r\n-\r\n const express = require('express');\r\n const cors = require('cors');\r\n const rateLimit = require('express-rate-limit');\r\n \r\n-// 1. IMPORTA A LÓGICA DE CONEXÃO DO NOVO ARQUIVO\r\n-const { masterConnection, getTenantConnection } = require('./config/db');\r\n+// 1. IMPORTA A LÓGICA DE CONEXÃO E OS MODELOS DO BANCO MESTRE\r\n+const { connectToMasterDB, getMasterConnection } = require('./config/db');\r\n const MasterCompany = require('./models/MasterCompany');\r\n \r\n const app = express();\r\n \r\n@@ -15,17 +15,12 @@\n app.use(cors());\r\n app.use(express.json({ limit: '50mb' }));\r\n app.use(express.urlencoded({ limit: '50mb', extended: true }));\r\n \r\n-const loginLimiter = rateLimit({\r\n-    windowMs: 15 * 60 * 1000,\r\n-    max: 10,\r\n-    message: { message: 'Muitas tentativas de login deste IP. Por favor, tente novamente após 15 minutos.' },\r\n-    standardHeaders: true,\r\n-    legacyHeaders: false,\r\n-});\r\n+// 3. IMPORTAÇÃO DE TODAS AS ROTAS E MIDDLEWARES DE AUTENTICAÇÃO\r\n+const { protect } = require('./middleware/authMiddleware');\r\n+const { tenantMiddleware } = require('./middleware/tenantMiddleware');\r\n \r\n-// 3. IMPORTAÇÃO DE TODAS AS ROTAS\r\n const authRoutes = require('./routes/auth');\r\n const companyRoutes = require('./routes/company');\r\n const boletoRoutes = require('./routes/boletos');\r\n const permissionsRoutes = require('./routes/permissions');\r\n@@ -35,55 +30,61 @@\n const nfeRoutes = require('./routes/nfe');\r\n const categoryRoutes = require('./routes/categories');\r\n const reportRoutes = require('./routes/reports');\r\n const exportRoutes = require('./routes/export');\r\n-const { protect } = require('./middleware/authMiddleware');\r\n-const { tenantMiddleware } = require('./middleware/tenantMiddleware');\r\n \r\n-// Middleware para passar a conexão MESTRE para as rotas que precisam dela\r\n+// 4. MIDDLEWARE PARA PASSAR A CONEXÃO MESTRE PARA AS ROTAS\r\n const masterDbMiddleware = (req, res, next) => {\r\n-    req.masterDb = masterConnection;\r\n+    req.masterDb = getMasterConnection();\r\n     next();\r\n };\r\n \r\n-\r\n-// 5. APLICAÇÃO DAS ROTAS E MIDDLEWARES\r\n+// 5. APLICAÇÃO DAS ROTAS COM SEUS RESPECTIVOS MIDDLEWARES\r\n app.get('/', (req, res) => {\r\n     res.send('API do Organizador de Boletos está no ar!');\r\n });\r\n \r\n-// Rotas públicas (não precisam de 'protect' nem de banco de dados específico)\r\n+// Rate Limiter para o login\r\n+const loginLimiter = rateLimit({\r\n+    windowMs: 15 * 60 * 1000,\r\n+    max: 10,\r\n+    message: { message: 'Muitas tentativas de login deste IP. Por favor, tente novamente após 15 minutos.' },\r\n+});\r\n+app.use('/api/auth/login', loginLimiter);\r\n+\r\n+// Rotas públicas\r\n app.use('/api/contact', contactRoutes);\r\n \r\n-// Rotas que usam o banco MESTRE\r\n-app.use('/api/auth/login', loginLimiter); // Aplica o rate limit apenas ao login\r\n+// Rotas que usam o banco de dados MESTRE\r\n app.use('/api/auth', masterDbMiddleware, authRoutes);\r\n app.use('/api/admin', protect, masterDbMiddleware, adminRoutes);\r\n app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n app.use('/api/payments', protect, masterDbMiddleware, paymentRoutes);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n \r\n-// Rotas que usam o banco de dados da EMPRESA (precisam do 'protect' e do 'tenantMiddleware')\r\n+// Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n app.use('/api/boletos', protect, tenantMiddleware, boletoRoutes);\r\n app.use('/api/categories', protect, tenantMiddleware, categoryRoutes);\r\n app.use('/api/reports', protect, tenantMiddleware, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-// A lógica do Cron precisará ser reescrita no futuro para funcionar com a nova arquitetura.\r\n-// Por enquanto, a deixamos comentada.\r\n+// A lógica do Cron precisará ser reescrita no futuro\r\n /*\r\n\\ No newline at end of file\n const cron = require('node-cron');\r\n-cron.schedule('0 19 * * *', async () => {\r\n-    // Nova lógica:\r\n-    // 1. Buscar todas as empresas no banco Mestre.\r\n-    // 2. Fazer um loop por cada empresa.\r\n-    // 3. Para cada empresa, obter a conexão com seu banco de dados.\r\n-    // 4. Rodar a verificação de boletos vencidos dentro daquele banco de dados.\r\n-});\r\n+cron.schedule('0 19 * * *', async () => { ... });\r\n */\r\n \r\n-// 6. INICIA O SERVIDOR\r\n-const PORT = process.env.PORT || 5000;\r\n-app.listen(PORT, () => {\r\n-    console.log(`Servidor rodando na porta ${PORT}`);\r\n-});\n+// 6. LÓGICA DE INICIALIZAÇÃO DO SERVIDOR\r\n+const startServer = async () => {\r\n+    // PRIMEIRO, conecta-se ao banco de dados Mestre\r\n+    await connectToMasterDB();\r\n+\r\n+    // SÓ DEPOIS, inicia o servidor Express\r\n+    const PORT = process.env.PORT || 5000;\r\n+    app.listen(PORT, () => {\r\n+        console.log(`Servidor rodando na porta ${PORT}`);\r\n+    });\r\n+};\r\n+\r\n+// Inicia todo o processo\r\n+startServer();\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753548758792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-// D:\\SCripts\\SiteLobos\\Servidor\\server.js\r\n-\r\n require('dotenv').config();\r\n const express = require('express');\r\n const cors = require('cors');\r\n const rateLimit = require('express-rate-limit');\r\n@@ -18,8 +16,9 @@\n \r\n // 3. IMPORTAÇÃO DE TODAS AS ROTAS E MIDDLEWARES DE AUTENTICAÇÃO\r\n const { protect } = require('./middleware/authMiddleware');\r\n const { tenantMiddleware } = require('./middleware/tenantMiddleware');\r\n+const { checkSubscription } = require('./middleware/subscriptionMiddleware');\r\n \r\n const authRoutes = require('./routes/auth');\r\n const companyRoutes = require('./routes/company');\r\n const boletoRoutes = require('./routes/boletos');\r\n@@ -61,12 +60,12 @@\n app.use('/api/payments', protect, masterDbMiddleware, paymentRoutes);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n \r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n-app.use('/api/boletos', protect, tenantMiddleware, boletoRoutes);\r\n-app.use('/api/categories', protect, tenantMiddleware, categoryRoutes);\r\n-app.use('/api/reports', protect, tenantMiddleware, reportRoutes);\r\n-app.use('/api/export', protect, tenantMiddleware, exportRoutes);\r\n+app.use('/api/boletos', protect, tenantMiddleware, checkSubscription, boletoRoutes);\r\n+app.use('/api/categories', protect, tenantMiddleware, checkSubscription, categoryRoutes);\r\n+app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n+app.use('/api/export', protect, tenantMiddleware, checkSubscription, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n // A lógica do Cron precisará ser reescrita no futuro\r\n /*\r\n"
                },
                {
                    "date": 1753555829364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n const boletoRoutes = require('./routes/boletos');\r\n const permissionsRoutes = require('./routes/permissions');\r\n const adminRoutes = require('./routes/admin');\r\n const contactRoutes = require('./routes/contact');\r\n-const paymentRoutes = require('./routes/payments');\r\n+const paymentsRouter = require('./routes/payments');\r\n const nfeRoutes = require('./routes/nfe');\r\n const categoryRoutes = require('./routes/categories');\r\n const reportRoutes = require('./routes/reports');\r\n const exportRoutes = require('./routes/export');\r\n@@ -56,9 +56,10 @@\n // Rotas que usam o banco de dados MESTRE\r\n app.use('/api/auth', masterDbMiddleware, authRoutes);\r\n app.use('/api/admin', protect, masterDbMiddleware, adminRoutes);\r\n app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n-app.use('/api/payments', protect, masterDbMiddleware, paymentRoutes);\r\n+app.use('/api/payments', protect, masterDbMiddleware, paymentsRouter);\r\n+app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n \r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n app.use('/api/boletos', protect, tenantMiddleware, checkSubscription, boletoRoutes);\r\n"
                },
                {
                    "date": 1753557013509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,10 +56,10 @@\n // Rotas que usam o banco de dados MESTRE\r\n app.use('/api/auth', masterDbMiddleware, authRoutes);\r\n app.use('/api/admin', protect, masterDbMiddleware, adminRoutes);\r\n app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n+app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n app.use('/api/payments', protect, masterDbMiddleware, paymentsRouter);\r\n-app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n \r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n app.use('/api/boletos', protect, tenantMiddleware, checkSubscription, boletoRoutes);\r\n"
                },
                {
                    "date": 1753557775287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,12 @@\n+// D:\\SCripts\\SiteLobos\\Servidor\\server.js\r\n+\r\n require('dotenv').config();\r\n const express = require('express');\r\n const cors = require('cors');\r\n const rateLimit = require('express-rate-limit');\r\n \r\n-// 1. IMPORTA A LÓGICA DE CONEXÃO E OS MODELOS DO BANCO MESTRE\r\n+// 1. IMPORTA A LÓGICA DE CONEXÃO E O MODELO MESTRE NECESSÁRIO\r\n const { connectToMasterDB, getMasterConnection } = require('./config/db');\r\n const MasterCompany = require('./models/MasterCompany');\r\n \r\n const app = express();\r\n@@ -44,21 +46,23 @@\n \r\n // Rate Limiter para o login\r\n const loginLimiter = rateLimit({\r\n     windowMs: 15 * 60 * 1000,\r\n-    max: 10,\r\n+    max: 100, // Aumentado para permitir mais testes\r\n     message: { message: 'Muitas tentativas de login deste IP. Por favor, tente novamente após 15 minutos.' },\r\n });\r\n app.use('/api/auth/login', loginLimiter);\r\n \r\n // Rotas públicas\r\n app.use('/api/contact', contactRoutes);\r\n \r\n+// Rota PÚBLICA do Webhook: Registrada primeiro, sem 'protect'.\r\n+app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n+\r\n // Rotas que usam o banco de dados MESTRE\r\n app.use('/api/auth', masterDbMiddleware, authRoutes);\r\n app.use('/api/admin', protect, masterDbMiddleware, adminRoutes);\r\n app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n-app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n app.use('/api/payments', protect, masterDbMiddleware, paymentsRouter);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n \r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n"
                },
                {
                    "date": 1753559137581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,21 +51,28 @@\n     message: { message: 'Muitas tentativas de login deste IP. Por favor, tente novamente após 15 minutos.' },\r\n });\r\n app.use('/api/auth/login', loginLimiter);\r\n \r\n-// Rotas públicas\r\n-app.use('/api/contact', contactRoutes);\r\n+// --- IMPORTANTE: GARANTA QUE O WEBHOOK VENHA ANTES DA ROTA /api/payments PROTEGIDA ---\r\n \r\n // Rota PÚBLICA do Webhook: Registrada primeiro, sem 'protect'.\r\n app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n \r\n-// Rotas que usam o banco de dados MESTRE\r\n-app.use('/api/auth', masterDbMiddleware, authRoutes);\r\n+// Rotas públicas (ex: contato)\r\n+app.use('/api/contact', contactRoutes);\r\n+\r\n+// Rotas que usam o banco de dados MESTRE E SÃO PROTEGIDAS\r\n+app.use('/api/auth', masterDbMiddleware, authRoutes); // Auth tem rotas públicas e protegidas\r\n app.use('/api/admin', protect, masterDbMiddleware, adminRoutes);\r\n app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n-app.use('/api/payments', protect, masterDbMiddleware, paymentsRouter);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n \r\n+// As demais rotas de /api/payments que DEVEM ser protegidas virão DEPOIS\r\n+// e serão tratadas pelo paymentsRouter dentro do seu escopo de proteção.\r\n+// Por exemplo, as rotas 'create-subscription' dentro de paymentsRouter serão protegidas aqui.\r\n+app.use('/api/payments', protect, masterDbMiddleware, paymentsRouter);\r\n+\r\n+\r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n app.use('/api/boletos', protect, tenantMiddleware, checkSubscription, boletoRoutes);\r\n app.use('/api/categories', protect, tenantMiddleware, checkSubscription, categoryRoutes);\r\n app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n"
                },
                {
                    "date": 1753559230424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,8 +54,9 @@\n \r\n // --- IMPORTANTE: GARANTA QUE O WEBHOOK VENHA ANTES DA ROTA /api/payments PROTEGIDA ---\r\n \r\n // Rota PÚBLICA do Webhook: Registrada primeiro, sem 'protect'.\r\n+// O paymentsRouter contém a rota '/webhook' que será agora acessível publicamente através deste prefixo.\r\n app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n \r\n // Rotas públicas (ex: contato)\r\n app.use('/api/contact', contactRoutes);\r\n@@ -67,9 +68,9 @@\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n \r\n // As demais rotas de /api/payments que DEVEM ser protegidas virão DEPOIS\r\n // e serão tratadas pelo paymentsRouter dentro do seu escopo de proteção.\r\n-// Por exemplo, as rotas 'create-subscription' dentro de paymentsRouter serão protegidas aqui.\r\n+// Por exemplo, a rota 'create-subscription' dentro de paymentsRouter será protegida aqui.\r\n app.use('/api/payments', protect, masterDbMiddleware, paymentsRouter);\r\n \r\n \r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n"
                },
                {
                    "date": 1753559353471,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,8 +13,12 @@\n \r\n // 2. MIDDLEWARES GERAIS\r\n app.use(cors());\r\n app.use(express.json({ limit: '50mb' }));\r\n+app.use((req, res, next) => {\r\n+    console.log(`[DEBUG] Recebida requisição: ${req.method} ${req.originalUrl}`);\r\n+    next();\r\n+});\r\n app.use(express.urlencoded({ limit: '50mb', extended: true }));\r\n \r\n // 3. IMPORTAÇÃO DE TODAS AS ROTAS E MIDDLEWARES DE AUTENTICAÇÃO\r\n const { protect } = require('./middleware/authMiddleware');\r\n"
                },
                {
                    "date": 1753559377631,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,8 +60,14 @@\n \r\n // Rota PÚBLICA do Webhook: Registrada primeiro, sem 'protect'.\r\n // O paymentsRouter contém a rota '/webhook' que será agora acessível publicamente através deste prefixo.\r\n app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n+app.use((req, res, next) => {\r\n+    if (req.originalUrl.startsWith('/api/payments/webhook')) {\r\n+        console.log('[DEBUG] Requisição de Webhook passou pelo middleware masterDbMiddleware.');\r\n+    }\r\n+    next();\r\n+});\r\n \r\n // Rotas públicas (ex: contato)\r\n app.use('/api/contact', contactRoutes);\r\n \r\n"
                },
                {
                    "date": 1753559387116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,8 +80,14 @@\n // As demais rotas de /api/payments que DEVEM ser protegidas virão DEPOIS\r\n // e serão tratadas pelo paymentsRouter dentro do seu escopo de proteção.\r\n // Por exemplo, a rota 'create-subscription' dentro de paymentsRouter será protegida aqui.\r\n app.use('/api/payments', protect, masterDbMiddleware, paymentsRouter);\r\n+app.use((req, res, next) => {\r\n+    if (req.originalUrl.startsWith('/api/payments/') && !req.originalUrl.startsWith('/api/payments/webhook')) {\r\n+        console.log('[DEBUG] Requisição de Pagamento PROTEGIDA passou pelo middleware protect.');\r\n+    }\r\n+    next();\r\n+});\r\n \r\n \r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n app.use('/api/boletos', protect, tenantMiddleware, checkSubscription, boletoRoutes);\r\n"
                },
                {
                    "date": 1753560937857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,12 +13,8 @@\n \r\n // 2. MIDDLEWARES GERAIS\r\n app.use(cors());\r\n app.use(express.json({ limit: '50mb' }));\r\n-app.use((req, res, next) => {\r\n-    console.log(`[DEBUG] Recebida requisição: ${req.method} ${req.originalUrl}`);\r\n-    next();\r\n-});\r\n app.use(express.urlencoded({ limit: '50mb', extended: true }));\r\n \r\n // 3. IMPORTAÇÃO DE TODAS AS ROTAS E MIDDLEWARES DE AUTENTICAÇÃO\r\n const { protect } = require('./middleware/authMiddleware');\r\n@@ -60,14 +56,8 @@\n \r\n // Rota PÚBLICA do Webhook: Registrada primeiro, sem 'protect'.\r\n // O paymentsRouter contém a rota '/webhook' que será agora acessível publicamente através deste prefixo.\r\n app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n-app.use((req, res, next) => {\r\n-    if (req.originalUrl.startsWith('/api/payments/webhook')) {\r\n-        console.log('[DEBUG] Requisição de Webhook passou pelo middleware masterDbMiddleware.');\r\n-    }\r\n-    next();\r\n-});\r\n \r\n // Rotas públicas (ex: contato)\r\n app.use('/api/contact', contactRoutes);\r\n \r\n@@ -75,19 +65,9 @@\n app.use('/api/auth', masterDbMiddleware, authRoutes); // Auth tem rotas públicas e protegidas\r\n app.use('/api/admin', protect, masterDbMiddleware, adminRoutes);\r\n app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n-\r\n-// As demais rotas de /api/payments que DEVEM ser protegidas virão DEPOIS\r\n-// e serão tratadas pelo paymentsRouter dentro do seu escopo de proteção.\r\n-// Por exemplo, a rota 'create-subscription' dentro de paymentsRouter será protegida aqui.\r\n app.use('/api/payments', protect, masterDbMiddleware, paymentsRouter);\r\n-app.use((req, res, next) => {\r\n-    if (req.originalUrl.startsWith('/api/payments/') && !req.originalUrl.startsWith('/api/payments/webhook')) {\r\n-        console.log('[DEBUG] Requisição de Pagamento PROTEGIDA passou pelo middleware protect.');\r\n-    }\r\n-    next();\r\n-});\r\n \r\n \r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n app.use('/api/boletos', protect, tenantMiddleware, checkSubscription, boletoRoutes);\r\n"
                },
                {
                    "date": 1753561623110,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,9 +65,9 @@\n app.use('/api/auth', masterDbMiddleware, authRoutes); // Auth tem rotas públicas e protegidas\r\n app.use('/api/admin', protect, masterDbMiddleware, adminRoutes);\r\n app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n-app.use('/api/payments', protect, masterDbMiddleware, paymentsRouter);\r\n+app.use('/api/payments', masterDbMiddleware, paymentsRouter);\r\n \r\n \r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n app.use('/api/boletos', protect, tenantMiddleware, checkSubscription, boletoRoutes);\r\n"
                },
                {
                    "date": 1753561879024,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,8 +56,9 @@\n \r\n // Rota PÚBLICA do Webhook: Registrada primeiro, sem 'protect'.\r\n // O paymentsRouter contém a rota '/webhook' que será agora acessível publicamente através deste prefixo.\r\n app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n+app.use('/api/payments', masterDbMiddleware, paymentsRouter);\r\n \r\n // Rotas públicas (ex: contato)\r\n app.use('/api/contact', contactRoutes);\r\n \r\n@@ -65,9 +66,8 @@\n app.use('/api/auth', masterDbMiddleware, authRoutes); // Auth tem rotas públicas e protegidas\r\n app.use('/api/admin', protect, masterDbMiddleware, adminRoutes);\r\n app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n-app.use('/api/payments', masterDbMiddleware, paymentsRouter);\r\n \r\n \r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n app.use('/api/boletos', protect, tenantMiddleware, checkSubscription, boletoRoutes);\r\n"
                },
                {
                    "date": 1753562168799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,8 @@\n // --- IMPORTANTE: GARANTA QUE O WEBHOOK VENHA ANTES DA ROTA /api/payments PROTEGIDA ---\r\n \r\n // Rota PÚBLICA do Webhook: Registrada primeiro, sem 'protect'.\r\n // O paymentsRouter contém a rota '/webhook' que será agora acessível publicamente através deste prefixo.\r\n-app.use('/api/payments/webhook', masterDbMiddleware, paymentsRouter);\r\n app.use('/api/payments', masterDbMiddleware, paymentsRouter);\r\n \r\n // Rotas públicas (ex: contato)\r\n app.use('/api/contact', contactRoutes);\r\n"
                },
                {
                    "date": 1753706664970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-// D:\\SCripts\\SiteLobos\\Servidor\\server.js\r\n-\r\n require('dotenv').config();\r\n const express = require('express');\r\n const cors = require('cors');\r\n const rateLimit = require('express-rate-limit');\r\n@@ -10,8 +8,13 @@\n const MasterCompany = require('./models/MasterCompany');\r\n \r\n const app = express();\r\n \r\n+const cron = require('node-cron');\r\n+const { getTenantConnection } = require('./config/db'); // Já deve ter esta\r\n+const { sendDailyReportEmail } = require('./services/emailService');\r\n+const BoletoSchema = require('./models/Boleto').schema;\r\n+\r\n // 2. MIDDLEWARES GERAIS\r\n app.use(cors());\r\n app.use(express.json({ limit: '50mb' }));\r\n app.use(express.urlencoded({ limit: '50mb', extended: true }));\r\n@@ -74,14 +77,68 @@\n app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, checkSubscription, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-// A lógica do Cron precisará ser reescrita no futuro\r\n-/*\r\n-const cron = require('node-cron');\r\n-cron.schedule('0 19 * * *', async () => { ... });\r\n-*/\r\n+cron.schedule('0 19 * * *', async () => {\r\n+    console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n+    \r\n+    // Usamos a conexão Mestre que já foi estabelecida\r\n+    const masterDb = getMasterConnection();\r\n+    const MasterCompany = masterDb.model('MasterCompany', require('./models/MasterCompany').schema);\r\n \r\n+    const today = new Date();\r\n+    today.setUTCHours(0, 0, 0, 0); // Define a hora para o início do dia em UTC para comparações\r\n+    const todayStr = today.toISOString().split('T')[0]; // Formato 'YYYY-MM-DD'\r\n+\r\n+    try {\r\n+        // 3. Busca todas as empresas com assinatura ativa\r\n+        const activeCompanies = await MasterCompany.find({\r\n+            'subscription.status': 'active',\r\n+            'subscription.endDate': { $gt: today }\r\n+        });\r\n+\r\n+        console.log(`[CRON] Encontradas ${activeCompanies.length} empresas ativas para notificar.`);\r\n+\r\n+        // 4. Itera sobre cada empresa ativa\r\n+        for (const company of activeCompanies) {\r\n+            try {\r\n+                const tenantDb = await getTenantConnection(company.dbName);\r\n+                const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+\r\n+                // 5. Busca as parcelas vencidas e a vencer hoje para esta empresa\r\n+                const overdueParcels = await Boleto.aggregate([\r\n+                    { $unwind: '$parcels' },\r\n+                    { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+                    { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+                ]);\r\n+\r\n+                const dueTodayParcels = await Boleto.aggregate([\r\n+                    { $unwind: '$parcels' },\r\n+                    { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+                    { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+                ]);\r\n+\r\n+                // 6. Se houver parcelas, envia o e-mail\r\n+                if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+                    console.log(`[CRON] A enviar e-mail para ${company.nomeEmpresa} (${company.email})...`);\r\n+                    await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+                }\r\n+\r\n+            } catch (tenantError) {\r\n+                console.error(`[CRON] Erro ao processar a empresa ${company.nomeEmpresa}:`, tenantError);\r\n+                // Continua para a próxima empresa mesmo se uma falhar\r\n+            }\r\n+        }\r\n+        console.log('[CRON] Verificação diária concluída.');\r\n+\r\n+    } catch (masterError) {\r\n+        console.error('[CRON] Erro crítico ao buscar empresas ativas:', masterError);\r\n+    }\r\n+}, {\r\n+    scheduled: true,\r\n+    timezone: \"America/Sao_Paulo\" // Garante que as 19:00 são no fuso horário de São Paulo/Brasil\r\n+});\r\n+\r\n // 6. LÓGICA DE INICIALIZAÇÃO DO SERVIDOR\r\n const startServer = async () => {\r\n     // PRIMEIRO, conecta-se ao banco de dados Mestre\r\n     await connectToMasterDB();\r\n"
                },
                {
                    "date": 1753706784300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, checkSubscription, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-cron.schedule('0 19 * * *', async () => {\r\n+cron.schedule('* * * * *', async () => {\r\n     console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n     \r\n     // Usamos a conexão Mestre que já foi estabelecida\r\n     const masterDb = getMasterConnection();\r\n"
                },
                {
                    "date": 1753706982010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, checkSubscription, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-cron.schedule('* * * * *', async () => {\r\n+cron.schedule('0 19 * * *', async () => {\r\n     console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n     \r\n     // Usamos a conexão Mestre que já foi estabelecida\r\n     const masterDb = getMasterConnection();\r\n"
                },
                {
                    "date": 1753739194328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -149,6 +149,60 @@\n         console.log(`Servidor rodando na porta ${PORT}`);\r\n     });\r\n };\r\n \r\n+// Tarefa agendada para limpar empresas não verificadas (executa todos os dias às 2 da manhã)\r\n+cron.schedule('0 2 * * *', async () => {\r\n+    console.log('[CRON LIMPEZA] A iniciar a verificação de empresas não verificadas...');\r\n+\r\n+    try {\r\n+        const masterDb = getMasterConnection();\r\n+        const MasterCompany = masterDb.model('MasterCompany', require('./models/MasterCompany').schema);\r\n+        const MasterUser = masterDb.model('MasterUser', require('./models/MasterUser').schema);\r\n+\r\n+        // Calcula a data de 10 dias atrás\r\n+        const tenDaysAgo = new Date();\r\n+        tenDaysAgo.setDate(tenDaysAgo.getDate() - 10);\r\n+\r\n+        // Encontra empresas não verificadas e criadas há mais de 10 dias\r\n+        const companiesToDelete = await MasterCompany.find({\r\n+            isVerified: false,\r\n+            createdAt: { $lt: tenDaysAgo }\r\n+        });\r\n+\r\n+        if (companiesToDelete.length === 0) {\r\n+            console.log('[CRON LIMPEZA] Nenhuma empresa para limpar.');\r\n+            return;\r\n+        }\r\n+\r\n+        console.log(`[CRON LIMPEZA] Encontradas ${companiesToDelete.length} empresas para apagar.`);\r\n+\r\n+        for (const company of companiesToDelete) {\r\n+            try {\r\n+                console.log(`[CRON LIMPEZA] A apagar a empresa: ${company.nomeEmpresa} (CNPJ: ${company.cnpj})`);\r\n+\r\n+                // Apaga a base de dados da empresa (tenant)\r\n+                const tenantDb = await getTenantConnection(company.dbName);\r\n+                await tenantDb.dropDatabase();\r\n+\r\n+                // Apaga os utilizadores associados no banco mestre\r\n+                await MasterUser.deleteMany({ company: company._id });\r\n+\r\n+                // Apaga o registo da empresa no banco mestre\r\n+                await MasterCompany.findByIdAndDelete(company._id);\r\n+\r\n+                console.log(`[CRON LIMPEZA] Empresa ${company.nomeEmpresa} apagada com sucesso.`);\r\n+            } catch (deleteError) {\r\n+                console.error(`[CRON LIMPEZA] Erro ao apagar a empresa ${company.nomeEmpresa}:`, deleteError);\r\n+            }\r\n+        }\r\n+\r\n+    } catch (error) {\r\n+        console.error('[CRON LIMPEZA] Erro crítico durante a tarefa de limpeza:', error);\r\n+    }\r\n+}, {\r\n+    scheduled: true,\r\n+    timezone: \"America/Sao_Paulo\"\r\n+});\r\n+\r\n // Inicia todo o processo\r\n startServer();\n\\ No newline at end of file\n"
                },
                {
                    "date": 1753806523098,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, checkSubscription, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-cron.schedule('0 19 * * *', async () => {\r\n+cron.schedule('* * * * *', async () => {\r\n     console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n     \r\n     // Usamos a conexão Mestre que já foi estabelecida\r\n     const masterDb = getMasterConnection();\r\n"
                },
                {
                    "date": 1753807006783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, checkSubscription, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-cron.schedule('* * * * *', async () => {\r\n+cron.schedule('0 19 * * *', async () => {\r\n     console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n     \r\n     // Usamos a conexão Mestre que já foi estabelecida\r\n     const masterDb = getMasterConnection();\r\n"
                },
                {
                    "date": 1753807296855,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,9 @@\n const cron = require('node-cron');\r\n const { getTenantConnection } = require('./config/db'); // Já deve ter esta\r\n const { sendDailyReportEmail } = require('./services/emailService');\r\n const BoletoSchema = require('./models/Boleto').schema;\r\n+const announcementRoutes = require('./routes/announcements');\r\n \r\n // 2. MIDDLEWARES GERAIS\r\n app.use(cors());\r\n app.use(express.json({ limit: '50mb' }));\r\n"
                },
                {
                    "date": 1753807319116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,8 +69,9 @@\n app.use('/api/auth', masterDbMiddleware, authRoutes); // Auth tem rotas públicas e protegidas\r\n app.use('/api/admin', protect, masterDbMiddleware, adminRoutes);\r\n app.use('/api/companies', protect, masterDbMiddleware, companyRoutes);\r\n app.use('/api/permissions', protect, masterDbMiddleware, permissionsRoutes);\r\n+app.use('/api/announcements', protect, masterDbMiddleware, announcementRoutes);\r\n \r\n \r\n // Rotas que usam o banco de dados da EMPRESA (TENANT)\r\n app.use('/api/boletos', protect, tenantMiddleware, checkSubscription, boletoRoutes);\r\n"
                },
                {
                    "date": 1754318986123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, checkSubscription, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-cron.schedule('0 19 * * *', async () => {\r\n+cron.schedule('* * * * *', async () => {\r\n     console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n     \r\n     // Usamos a conexão Mestre que já foi estabelecida\r\n     const masterDb = getMasterConnection();\r\n"
                },
                {
                    "date": 1754319688787,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,9 +121,9 @@\n \r\n                 // 6. Se houver parcelas, envia o e-mail\r\n                 if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n                     console.log(`[CRON] A enviar e-mail para ${company.nomeEmpresa} (${company.email})...`);\r\n-                    await sendDailyReportEmail(company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+                    await sendDailyReportEmail(masterDb, company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n                 }\r\n \r\n             } catch (tenantError) {\r\n                 console.error(`[CRON] Erro ao processar a empresa ${company.nomeEmpresa}:`, tenantError);\r\n"
                },
                {
                    "date": 1754319939187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,9 +79,9 @@\n app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, checkSubscription, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-cron.schedule('* * * * *', async () => {\r\n+cron.schedule('0 19 * * *', async () => {\r\n     console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n     \r\n     // Usamos a conexão Mestre que já foi estabelecida\r\n     const masterDb = getMasterConnection();\r\n"
                },
                {
                    "date": 1754501745311,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,8 +23,9 @@\n // 3. IMPORTAÇÃO DE TODAS AS ROTAS E MIDDLEWARES DE AUTENTICAÇÃO\r\n const { protect } = require('./middleware/authMiddleware');\r\n const { tenantMiddleware } = require('./middleware/tenantMiddleware');\r\n const { checkSubscription } = require('./middleware/subscriptionMiddleware');\r\n+const { initCronJobs } = require('./services/cronJobs'); \r\n \r\n const authRoutes = require('./routes/auth');\r\n const companyRoutes = require('./routes/company');\r\n const boletoRoutes = require('./routes/boletos');\r\n@@ -79,68 +80,10 @@\n app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, checkSubscription, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-cron.schedule('0 19 * * *', async () => {\r\n-    console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n-    \r\n-    // Usamos a conexão Mestre que já foi estabelecida\r\n-    const masterDb = getMasterConnection();\r\n-    const MasterCompany = masterDb.model('MasterCompany', require('./models/MasterCompany').schema);\r\n \r\n-    const today = new Date();\r\n-    today.setUTCHours(0, 0, 0, 0); // Define a hora para o início do dia em UTC para comparações\r\n-    const todayStr = today.toISOString().split('T')[0]; // Formato 'YYYY-MM-DD'\r\n \r\n-    try {\r\n-        // 3. Busca todas as empresas com assinatura ativa\r\n-        const activeCompanies = await MasterCompany.find({\r\n-            'subscription.status': 'active',\r\n-            'subscription.endDate': { $gt: today }\r\n-        });\r\n-\r\n-        console.log(`[CRON] Encontradas ${activeCompanies.length} empresas ativas para notificar.`);\r\n-\r\n-        // 4. Itera sobre cada empresa ativa\r\n-        for (const company of activeCompanies) {\r\n-            try {\r\n-                const tenantDb = await getTenantConnection(company.dbName);\r\n-                const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n-\r\n-                // 5. Busca as parcelas vencidas e a vencer hoje para esta empresa\r\n-                const overdueParcels = await Boleto.aggregate([\r\n-                    { $unwind: '$parcels' },\r\n-                    { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n-                    { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-                ]);\r\n-\r\n-                const dueTodayParcels = await Boleto.aggregate([\r\n-                    { $unwind: '$parcels' },\r\n-                    { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n-                    { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-                ]);\r\n-\r\n-                // 6. Se houver parcelas, envia o e-mail\r\n-                if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-                    console.log(`[CRON] A enviar e-mail para ${company.nomeEmpresa} (${company.email})...`);\r\n-                    await sendDailyReportEmail(masterDb, company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n-                }\r\n-\r\n-            } catch (tenantError) {\r\n-                console.error(`[CRON] Erro ao processar a empresa ${company.nomeEmpresa}:`, tenantError);\r\n-                // Continua para a próxima empresa mesmo se uma falhar\r\n-            }\r\n-        }\r\n-        console.log('[CRON] Verificação diária concluída.');\r\n-\r\n-    } catch (masterError) {\r\n-        console.error('[CRON] Erro crítico ao buscar empresas ativas:', masterError);\r\n-    }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\" // Garante que as 19:00 são no fuso horário de São Paulo/Brasil\r\n-});\r\n-\r\n // 6. LÓGICA DE INICIALIZAÇÃO DO SERVIDOR\r\n const startServer = async () => {\r\n     // PRIMEIRO, conecta-se ao banco de dados Mestre\r\n     await connectToMasterDB();\r\n@@ -151,60 +94,8 @@\n         console.log(`Servidor rodando na porta ${PORT}`);\r\n     });\r\n };\r\n \r\n-// Tarefa agendada para limpar empresas não verificadas (executa todos os dias às 2 da manhã)\r\n-cron.schedule('0 2 * * *', async () => {\r\n-    console.log('[CRON LIMPEZA] A iniciar a verificação de empresas não verificadas...');\r\n \r\n-    try {\r\n-        const masterDb = getMasterConnection();\r\n-        const MasterCompany = masterDb.model('MasterCompany', require('./models/MasterCompany').schema);\r\n-        const MasterUser = masterDb.model('MasterUser', require('./models/MasterUser').schema);\r\n \r\n-        // Calcula a data de 10 dias atrás\r\n-        const tenDaysAgo = new Date();\r\n-        tenDaysAgo.setDate(tenDaysAgo.getDate() - 10);\r\n-\r\n-        // Encontra empresas não verificadas e criadas há mais de 10 dias\r\n-        const companiesToDelete = await MasterCompany.find({\r\n-            isVerified: false,\r\n-            createdAt: { $lt: tenDaysAgo }\r\n-        });\r\n-\r\n-        if (companiesToDelete.length === 0) {\r\n-            console.log('[CRON LIMPEZA] Nenhuma empresa para limpar.');\r\n-            return;\r\n-        }\r\n-\r\n-        console.log(`[CRON LIMPEZA] Encontradas ${companiesToDelete.length} empresas para apagar.`);\r\n-\r\n-        for (const company of companiesToDelete) {\r\n-            try {\r\n-                console.log(`[CRON LIMPEZA] A apagar a empresa: ${company.nomeEmpresa} (CNPJ: ${company.cnpj})`);\r\n-\r\n-                // Apaga a base de dados da empresa (tenant)\r\n-                const tenantDb = await getTenantConnection(company.dbName);\r\n-                await tenantDb.dropDatabase();\r\n-\r\n-                // Apaga os utilizadores associados no banco mestre\r\n-                await MasterUser.deleteMany({ company: company._id });\r\n-\r\n-                // Apaga o registo da empresa no banco mestre\r\n-                await MasterCompany.findByIdAndDelete(company._id);\r\n-\r\n-                console.log(`[CRON LIMPEZA] Empresa ${company.nomeEmpresa} apagada com sucesso.`);\r\n-            } catch (deleteError) {\r\n-                console.error(`[CRON LIMPEZA] Erro ao apagar a empresa ${company.nomeEmpresa}:`, deleteError);\r\n-            }\r\n-        }\r\n-\r\n-    } catch (error) {\r\n-        console.error('[CRON LIMPEZA] Erro crítico durante a tarefa de limpeza:', error);\r\n-    }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\"\r\n-});\r\n-\r\n // Inicia todo o processo\r\n startServer();\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754501788409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,8 @@\n // 3. IMPORTAÇÃO DE TODAS AS ROTAS E MIDDLEWARES DE AUTENTICAÇÃO\r\n const { protect } = require('./middleware/authMiddleware');\r\n const { tenantMiddleware } = require('./middleware/tenantMiddleware');\r\n const { checkSubscription } = require('./middleware/subscriptionMiddleware');\r\n-const { initCronJobs } = require('./services/cronJobs'); \r\n \r\n const authRoutes = require('./routes/auth');\r\n const companyRoutes = require('./routes/company');\r\n const boletoRoutes = require('./routes/boletos');\r\n@@ -37,8 +36,10 @@\n const categoryRoutes = require('./routes/categories');\r\n const reportRoutes = require('./routes/reports');\r\n const exportRoutes = require('./routes/export');\r\n \r\n+const { initCronJobs } = require('./services/cronJobs'); \r\n+\r\n // 4. MIDDLEWARE PARA PASSAR A CONEXÃO MESTRE PARA AS ROTAS\r\n const masterDbMiddleware = (req, res, next) => {\r\n     req.masterDb = getMasterConnection();\r\n     next();\r\n@@ -87,12 +88,15 @@\n const startServer = async () => {\r\n     // PRIMEIRO, conecta-se ao banco de dados Mestre\r\n     await connectToMasterDB();\r\n \r\n-    // SÓ DEPOIS, inicia o servidor Express\r\n+    // DEPOIS, inicializa as tarefas agendadas\r\n+    initCronJobs();\r\n+\r\n+    // FINALMENTE, inicia o servidor Express\r\n     const PORT = process.env.PORT || 5000;\r\n     app.listen(PORT, () => {\r\n-        console.log(`Servidor rodando na porta ${PORT}`);\r\n+        console.log(`Servidor a rodar na porta ${PORT}`);\r\n     });\r\n };\r\n \r\n \r\n"
                },
                {
                    "date": 1754502194827,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n const cors = require('cors');\r\n const rateLimit = require('express-rate-limit');\r\n \r\n // 1. IMPORTA A LÓGICA DE CONEXÃO E O MODELO MESTRE NECESSÁRIO\r\n-const { connectToMasterDB, getMasterConnection } = require('./config/db');\r\n+const { connectToMasterDB, getMasterConnection, closeAllConnections } = require('./config/db');\r\n const MasterCompany = require('./models/MasterCompany');\r\n \r\n const app = express();\r\n \r\n"
                },
                {
                    "date": 1754502228158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,8 +98,20 @@\n         console.log(`Servidor a rodar na porta ${PORT}`);\r\n     });\r\n };\r\n \r\n+// --- NOVO BLOCO: LÓGICA DE DESLIGAMENTO GRACIOSO ---\r\n+const cleanup = (signal) => {\r\n+    console.log(`\\nSinal ${signal} recebido. A fechar as conexões com o banco de dados...`);\r\n+    closeAllConnections().then(() => {\r\n+        console.log('Todas as conexões foram fechadas. O servidor será desligado.');\r\n+        process.exit(0);\r\n+    });\r\n+};\r\n \r\n+// Ouve os sinais de interrupção (como Ctrl+C) e terminação\r\n+process.on('SIGINT', () => cleanup('SIGINT'));\r\n+process.on('SIGTERM', () => cleanup('SIGTERM'));\r\n \r\n+\r\n // Inicia todo o processo\r\n startServer();\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754502310491,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,20 +98,8 @@\n         console.log(`Servidor a rodar na porta ${PORT}`);\r\n     });\r\n };\r\n \r\n-// --- NOVO BLOCO: LÓGICA DE DESLIGAMENTO GRACIOSO ---\r\n-const cleanup = (signal) => {\r\n-    console.log(`\\nSinal ${signal} recebido. A fechar as conexões com o banco de dados...`);\r\n-    closeAllConnections().then(() => {\r\n-        console.log('Todas as conexões foram fechadas. O servidor será desligado.');\r\n-        process.exit(0);\r\n-    });\r\n-};\r\n \r\n-// Ouve os sinais de interrupção (como Ctrl+C) e terminação\r\n-process.on('SIGINT', () => cleanup('SIGINT'));\r\n-process.on('SIGTERM', () => cleanup('SIGTERM'));\r\n \r\n-\r\n // Inicia todo o processo\r\n startServer();\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754502345327,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n const cors = require('cors');\r\n const rateLimit = require('express-rate-limit');\r\n \r\n // 1. IMPORTA A LÓGICA DE CONEXÃO E O MODELO MESTRE NECESSÁRIO\r\n-const { connectToMasterDB, getMasterConnection, closeAllConnections } = require('./config/db');\r\n+const { connectToMasterDB, getMasterConnection} = require('./config/db');\r\n const MasterCompany = require('./models/MasterCompany');\r\n \r\n const app = express();\r\n \r\n"
                },
                {
                    "date": 1754502446119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n const cors = require('cors');\r\n const rateLimit = require('express-rate-limit');\r\n \r\n // 1. IMPORTA A LÓGICA DE CONEXÃO E O MODELO MESTRE NECESSÁRIO\r\n-const { connectToMasterDB, getMasterConnection} = require('./config/db');\r\n+const { connectToMasterDB, getMasterConnection, closeAllConnections } = require('./config/db');\r\n const MasterCompany = require('./models/MasterCompany');\r\n \r\n const app = express();\r\n \r\n@@ -98,8 +98,20 @@\n         console.log(`Servidor a rodar na porta ${PORT}`);\r\n     });\r\n };\r\n \r\n+// --- NOVO BLOCO: LÓGICA DE DESLIGAMENTO GRACIOSO ---\r\n+const cleanup = (signal) => {\r\n+    console.log(`\\nSinal ${signal} recebido. A fechar as conexões com o banco de dados...`);\r\n+    closeAllConnections().then(() => {\r\n+        console.log('Todas as conexões foram fechadas. O servidor será desligado.');\r\n+        process.exit(0);\r\n+    });\r\n+};\r\n \r\n+// Ouve os sinais de interrupção (como Ctrl+C) e terminação\r\n+process.on('SIGINT', () => cleanup('SIGINT'));\r\n+process.on('SIGTERM', () => cleanup('SIGTERM'));\r\n \r\n+\r\n // Inicia todo o processo\r\n startServer();\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754506975940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,25 +81,8 @@\n app.use('/api/reports', protect, tenantMiddleware, checkSubscription, reportRoutes);\r\n app.use('/api/export', protect, tenantMiddleware, checkSubscription, exportRoutes);\r\n app.use('/api/nfe', protect, nfeRoutes); // NFe não usa nosso banco, só precisa de proteção\r\n \r\n-\r\n-\r\n-// 6. LÓGICA DE INICIALIZAÇÃO DO SERVIDOR\r\n-const startServer = async () => {\r\n-    // PRIMEIRO, conecta-se ao banco de dados Mestre\r\n-    await connectToMasterDB();\r\n-\r\n-    // DEPOIS, inicializa as tarefas agendadas\r\n-    initCronJobs();\r\n-\r\n-    // FINALMENTE, inicia o servidor Express\r\n-    const PORT = process.env.PORT || 5000;\r\n-    app.listen(PORT, () => {\r\n-        console.log(`Servidor a rodar na porta ${PORT}`);\r\n-    });\r\n-};\r\n-\r\n // --- NOVO BLOCO: LÓGICA DE DESLIGAMENTO GRACIOSO ---\r\n const cleanup = (signal) => {\r\n     console.log(`\\nSinal ${signal} recebido. A fechar as conexões com o banco de dados...`);\r\n     closeAllConnections().then(() => {\r\n@@ -111,7 +94,19 @@\n // Ouve os sinais de interrupção (como Ctrl+C) e terminação\r\n process.on('SIGINT', () => cleanup('SIGINT'));\r\n process.on('SIGTERM', () => cleanup('SIGTERM'));\r\n \r\n+const startServer = async () => {\r\n+    await connectToMasterDB();\r\n+    initCronJobs();\r\n\\ No newline at end of file\n+    const PORT = process.env.PORT || 5000;\r\n+    const server = app.listen(PORT, () => {\r\n+        console.log(`Servidor a rodar na porta ${PORT}`);\r\n+    });\r\n+    return server;\r\n+};\r\n \r\n-// Inicia todo o processo\r\n-startServer();\n+if (require.main === module) {\r\n+    startServer();\r\n+}\r\n+\r\n+module.exports = app;\n\\ No newline at end of file\n"
                }
            ],
            "date": 1752253945740,
            "name": "Commit-0",
            "content": "// 1. Carrega as variáveis de ambiente do arquivo .env\r\nrequire('dotenv').config();\r\n\r\n// 2. Importa as dependências\r\nconst express = require('express');\r\nconst mongoose = require('mongoose');\r\nconst cors = require('cors');\r\n\r\n// 3. Inicializa o servidor express\r\nconst app = express();\r\n\r\n// 4. Middlewares essenciais\r\napp.use(cors());\r\napp.use(express.json());\r\n\r\n// 5. Conexão com o Banco de Dados MongoDB\r\nconst dbURI = process.env.MONGODB_URI;\r\nmongoose.connect(dbURI)\r\n    .then(() => console.log('Conectado ao MongoDB com sucesso!'))\r\n    .catch((err) => console.error('Falha ao conectar ao MongoDB:', err));\r\n\r\n\r\n// --- ROTAS DA API ---\r\n\r\n// 6. Rota principal de \"saúde\" da API\r\napp.get('/', (req, res) => {\r\n    res.send('API do Organizador de Boletos está no ar!');\r\n});\r\n\r\n// 7. Importar e usar as rotas de autenticação\r\nconst authRoutes = require('./routes/auth');\r\napp.use('/api/auth', authRoutes);\r\n\r\n// 8. Importar e usar as rotas de empresa\r\nconst companyRoutes = require('./routes/company');\r\napp.use('/api/companies', companyRoutes);\r\n\r\n// 9. Importar e usar as rotas de boletos\r\nconst boletoRoutes = require('./routes/boletos');\r\napp.use('/api/boletos', boletoRoutes);\r\n\r\n// 10. Importar e usar as rotas de permissões (NOVO)\r\nconst permissionsRoutes = require('./routes/permissions');\r\napp.use('/api/permissions', permissionsRoutes);\r\n\r\n// 11. Importar e usar as rotas de AdminMaster\r\nconst adminRoutes = require('./routes/admin');\r\napp.use('/api/admin', adminRoutes);\r\n\r\n// 12. Define a porta e inicia o servidor\r\nconst PORT = process.env.PORT || 5000;\r\napp.listen(PORT, () => {\r\n    console.log(`Servidor rodando na porta ${PORT}`);\r\n});\r\n"
        }
    ]
}