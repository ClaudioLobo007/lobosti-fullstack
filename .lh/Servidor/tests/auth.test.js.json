{
    "sourceFile": "Servidor/tests/auth.test.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1754507422836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1754509486482,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,14 @@\n const request = require('supertest');\r\n-const app = require('../server'); // A nossa aplicação Express\r\n+const app = require('../server');\r\n const { schema: MasterCompanySchema } = require('../models/MasterCompany');\r\n const { schema: MasterUserSchema } = require('../models/MasterUser');\r\n-const mongoose = require('mongoose');\r\n+// 1. IMPORTAMOS A FUNÇÃO PARA OBTER A CONEXÃO CORRETA\r\n+const { getMasterConnection } = require('../config/db');\r\n \r\n describe('Rotas de Autenticação (/api/auth)', () => {\r\n \r\n   it('deve registar uma nova empresa e o seu proprietário com sucesso', async () => {\r\n-    // 1. Arrange (Preparação): Preparamos os dados que vamos enviar.\r\n     const newCompanyData = {\r\n       nomeEmpresa: 'Empresa de Teste',\r\n       cnpj: '11.222.333/0001-44',\r\n       email: 'contato@testedev.com',\r\n@@ -17,32 +17,31 @@\n       ownerEmail: 'owner@testedev.com',\r\n       password: 'password123'\r\n     };\r\n \r\n-    // 2. Act (Ação): Fazemos a requisição POST para a nossa rota de registo.\r\n     const response = await request(app)\r\n       .post('/api/auth/register-company')\r\n       .send(newCompanyData);\r\n \r\n-    // 3. Assert (Verificação) - Parte 1: Verificamos a Resposta da API\r\n     expect(response.statusCode).toBe(201);\r\n     expect(response.body.message).toContain('Empresa registada!');\r\n \r\n-    // 4. Assert (Verificação) - Parte 2: Verificamos a Base de Dados\r\n-    const MasterCompany = mongoose.model('MasterCompany', MasterCompanySchema);\r\n-    const MasterUser = mongoose.model('MasterUser', MasterUserSchema);\r\n+    // --- A CORREÇÃO ESTÁ AQUI ---\r\n+    // 2. OBTÉM A CONEXÃO DE TESTE QUE ESTÁ ATIVA\r\n+    const masterDb = getMasterConnection();\r\n \r\n-    // Verificamos se a empresa foi criada\r\n+    // 3. COMPILA OS MODELOS USANDO A CONEXÃO DE TESTE\r\n+    const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+    const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+    // --- FIM DA CORREÇÃO ---\r\n+\r\n+    // Agora, estas verificações irão funcionar porque usam a conexão correta\r\n     const company = await MasterCompany.findOne({ cnpj: newCompanyData.cnpj.replace(/\\D/g, '') });\r\n     expect(company).not.toBeNull();\r\n     expect(company.nomeEmpresa).toBe(newCompanyData.nomeEmpresa);\r\n \r\n-    // Verificamos se o utilizador proprietário foi criado\r\n     const user = await MasterUser.findOne({ email: newCompanyData.ownerEmail });\r\n     expect(user).not.toBeNull();\r\n     expect(user.role).toBe('Proprietário');\r\n-    \r\n-    // Verificamos se o utilizador está corretamente associado à empresa\r\n     expect(user.company.toString()).toBe(company._id.toString());\r\n   });\r\n-\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754509844359,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,15 @@\n const request = require('supertest');\r\n const app = require('../server');\r\n const { schema: MasterCompanySchema } = require('../models/MasterCompany');\r\n const { schema: MasterUserSchema } = require('../models/MasterUser');\r\n-// 1. IMPORTAMOS A FUNÇÃO PARA OBTER A CONEXÃO CORRETA\r\n const { getMasterConnection } = require('../config/db');\r\n \r\n describe('Rotas de Autenticação (/api/auth)', () => {\r\n \r\n+  // Teste 1: Registo de Empresa (já existente)\r\n   it('deve registar uma nova empresa e o seu proprietário com sucesso', async () => {\r\n+    // ... o código deste teste continua o mesmo ...\r\n     const newCompanyData = {\r\n       nomeEmpresa: 'Empresa de Teste',\r\n       cnpj: '11.222.333/0001-44',\r\n       email: 'contato@testedev.com',\r\n@@ -16,32 +17,60 @@\n       username: 'owner_test',\r\n       ownerEmail: 'owner@testedev.com',\r\n       password: 'password123'\r\n     };\r\n-\r\n     const response = await request(app)\r\n       .post('/api/auth/register-company')\r\n       .send(newCompanyData);\r\n-\r\n     expect(response.statusCode).toBe(201);\r\n-    expect(response.body.message).toContain('Empresa registada!');\r\n-\r\n-    // --- A CORREÇÃO ESTÁ AQUI ---\r\n-    // 2. OBTÉM A CONEXÃO DE TESTE QUE ESTÁ ATIVA\r\n     const masterDb = getMasterConnection();\r\n-\r\n-    // 3. COMPILA OS MODELOS USANDO A CONEXÃO DE TESTE\r\n     const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n     const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-    // --- FIM DA CORREÇÃO ---\r\n-\r\n-    // Agora, estas verificações irão funcionar porque usam a conexão correta\r\n     const company = await MasterCompany.findOne({ cnpj: newCompanyData.cnpj.replace(/\\D/g, '') });\r\n     expect(company).not.toBeNull();\r\n-    expect(company.nomeEmpresa).toBe(newCompanyData.nomeEmpresa);\r\n-\r\n     const user = await MasterUser.findOne({ email: newCompanyData.ownerEmail });\r\n     expect(user).not.toBeNull();\r\n-    expect(user.role).toBe('Proprietário');\r\n     expect(user.company.toString()).toBe(company._id.toString());\r\n   });\r\n+\r\n+  // --- NOVO TESTE ADICIONADO ABAIXO ---\r\n+\r\n+  it('deve autenticar um utilizador, retornar um token e permitir o acesso a uma rota protegida', async () => {\r\n+    // 1. ARRANGE (Preparação): Cria um utilizador para o teste de login.\r\n+    const userData = {\r\n+        nomeEmpresa: 'Empresa Login Teste',\r\n+        cnpj: '44.555.666/0001-77',\r\n+        email: 'contato@loginteste.com',\r\n+        telefoneWhatsapp: '21987654321',\r\n+        username: 'user_login_test',\r\n+        ownerEmail: 'owner@loginteste.com',\r\n+        password: 'password123'\r\n+    };\r\n+    await request(app).post('/api/auth/register-company').send(userData);\r\n+\r\n+    // 2. ACT (Ação 1): Tenta fazer o login com os dados criados.\r\n+    const loginResponse = await request(app)\r\n+        .post('/api/auth/login/direct')\r\n+        .send({\r\n+            cnpj: userData.cnpj,\r\n+            username: userData.username,\r\n+            password: userData.password\r\n+        });\r\n+\r\n+    // 3. ASSERT (Verificação 1): Verifica se o login foi bem-sucedido e retornou um token.\r\n+    expect(loginResponse.statusCode).toBe(200);\r\n+    expect(loginResponse.body.token).toBeDefined();\r\n+\r\n+    const token = loginResponse.body.token;\r\n+\r\n+    // 4. ACT (Ação 2): Usa o token para aceder a uma rota protegida.\r\n+    const boletosResponse = await request(app)\r\n+        .get('/api/boletos')\r\n+        .set('Authorization', `Bearer ${token}`); // <-- O ponto mais importante!\r\n+\r\n+    // 5. ASSERT (Verificação 2): Verifica se o acesso foi concedido.\r\n+    expect(boletosResponse.statusCode).toBe(200);\r\n+    // Verificamos se a resposta é um array, como esperado da rota de boletos.\r\n+    expect(Array.isArray(boletosResponse.body)).toBe(true);\r\n+  });\r\n+  \r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754510022487,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,21 +33,34 @@\n   });\r\n \r\n   // --- NOVO TESTE ADICIONADO ABAIXO ---\r\n \r\n-  it('deve autenticar um utilizador, retornar um token e permitir o acesso a uma rota protegida', async () => {\r\n-    // 1. ARRANGE (Preparação): Cria um utilizador para o teste de login.\r\n-    const userData = {\r\n-        nomeEmpresa: 'Empresa Login Teste',\r\n-        cnpj: '44.555.666/0001-77',\r\n-        email: 'contato@loginteste.com',\r\n-        telefoneWhatsapp: '21987654321',\r\n-        username: 'user_login_test',\r\n-        ownerEmail: 'owner@loginteste.com',\r\n-        password: 'password123'\r\n-    };\r\n-    await request(app).post('/api/auth/register-company').send(userData);\r\n+    it('deve autenticar um utilizador, retornar um token e permitir o acesso a uma rota protegida', async () => {\r\n+        // 1. ARRANGE (Preparação): Cria um utilizador para o teste de login.\r\n+        const userData = {\r\n+            nomeEmpresa: 'Empresa Login Teste',\r\n+            cnpj: '44.555.666/0001-77',\r\n+            // ... resto dos dados\r\n+            password: 'password123'\r\n+        };\r\n+        await request(app).post('/api/auth/register-company').send(userData);\r\n \r\n+        // --- NOVO BLOCO DE CÓDIGO ADICIONADO AQUI ---\r\n+        // Ativamos a assinatura da empresa que acabamos de criar para o nosso teste.\r\n+        const masterDb = getMasterConnection();\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const futureDate = new Date();\r\n+        futureDate.setDate(futureDate.getDate() + 30); // Simula uma assinatura válida por mais 30 dias.\r\n+\r\n+        await MasterCompany.updateOne(\r\n+            { cnpj: userData.cnpj.replace(/\\D/g, '') },\r\n+            { $set: { \r\n+                'subscription.status': 'active',\r\n+                'subscription.endDate': futureDate,\r\n+                'isVerified': true // Aproveitamos para marcar como verificada também\r\n+            }}\r\n+        );\r\n+\r\n     // 2. ACT (Ação 1): Tenta fazer o login com os dados criados.\r\n     const loginResponse = await request(app)\r\n         .post('/api/auth/login/direct')\r\n         .send({\r\n"
                },
                {
                    "date": 1754510208457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,8 +67,9 @@\n             cnpj: userData.cnpj,\r\n             username: userData.username,\r\n             password: userData.password\r\n         });\r\n+    console.log('RESPOSTA DO LOGIN:', loginResponse.body);\r\n \r\n     // 3. ASSERT (Verificação 1): Verifica se o login foi bem-sucedido e retornou um token.\r\n     expect(loginResponse.statusCode).toBe(200);\r\n     expect(loginResponse.body.token).toBeDefined();\r\n"
                },
                {
                    "date": 1754510378107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,32 +34,32 @@\n \r\n   // --- NOVO TESTE ADICIONADO ABAIXO ---\r\n \r\n     it('deve autenticar um utilizador, retornar um token e permitir o acesso a uma rota protegida', async () => {\r\n-        // 1. ARRANGE (Preparação): Cria um utilizador para o teste de login.\r\n+        // 1. ARRANGE (Preparação)\r\n         const userData = {\r\n             nomeEmpresa: 'Empresa Login Teste',\r\n             cnpj: '44.555.666/0001-77',\r\n-            // ... resto dos dados\r\n+            email: 'contato@loginteste.com',\r\n+            telefoneWhatsapp: '21987654321',\r\n+            username: 'user_login_test', // <-- Verifique esta linha\r\n+            ownerEmail: 'owner@loginteste.com',\r\n             password: 'password123'\r\n         };\r\n         await request(app).post('/api/auth/register-company').send(userData);\r\n \r\n-        // --- NOVO BLOCO DE CÓDIGO ADICIONADO AQUI ---\r\n-        // Ativamos a assinatura da empresa que acabamos de criar para o nosso teste.\r\n         const masterDb = getMasterConnection();\r\n         const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n         const futureDate = new Date();\r\n-        futureDate.setDate(futureDate.getDate() + 30); // Simula uma assinatura válida por mais 30 dias.\r\n-\r\n+        futureDate.setDate(futureDate.getDate() + 30);\r\n         await MasterCompany.updateOne(\r\n             { cnpj: userData.cnpj.replace(/\\D/g, '') },\r\n             { $set: { \r\n                 'subscription.status': 'active',\r\n                 'subscription.endDate': futureDate,\r\n-                'isVerified': true // Aproveitamos para marcar como verificada também\r\n+                'isVerified': true\r\n             }}\r\n-        );\r\n+    );\r\n \r\n     // 2. ACT (Ação 1): Tenta fazer o login com os dados criados.\r\n     const loginResponse = await request(app)\r\n         .post('/api/auth/login/direct')\r\n"
                },
                {
                    "date": 1754510416285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,9 +67,8 @@\n             cnpj: userData.cnpj,\r\n             username: userData.username,\r\n             password: userData.password\r\n         });\r\n-    console.log('RESPOSTA DO LOGIN:', loginResponse.body);\r\n \r\n     // 3. ASSERT (Verificação 1): Verifica se o login foi bem-sucedido e retornou um token.\r\n     expect(loginResponse.statusCode).toBe(200);\r\n     expect(loginResponse.body.token).toBeDefined();\r\n"
                },
                {
                    "date": 1754510594781,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,36 +5,35 @@\n const { getMasterConnection } = require('../config/db');\r\n \r\n describe('Rotas de Autenticação (/api/auth)', () => {\r\n \r\n-  // Teste 1: Registo de Empresa (já existente)\r\n-  it('deve registar uma nova empresa e o seu proprietário com sucesso', async () => {\r\n-    // ... o código deste teste continua o mesmo ...\r\n-    const newCompanyData = {\r\n-      nomeEmpresa: 'Empresa de Teste',\r\n-      cnpj: '11.222.333/0001-44',\r\n-      email: 'contato@testedev.com',\r\n-      telefoneWhatsapp: '11987654321',\r\n-      username: 'owner_test',\r\n-      ownerEmail: 'owner@testedev.com',\r\n-      password: 'password123'\r\n-    };\r\n-    const response = await request(app)\r\n-      .post('/api/auth/register-company')\r\n-      .send(newCompanyData);\r\n-    expect(response.statusCode).toBe(201);\r\n-    const masterDb = getMasterConnection();\r\n-    const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-    const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-    const company = await MasterCompany.findOne({ cnpj: newCompanyData.cnpj.replace(/\\D/g, '') });\r\n-    expect(company).not.toBeNull();\r\n-    const user = await MasterUser.findOne({ email: newCompanyData.ownerEmail });\r\n-    expect(user).not.toBeNull();\r\n-    expect(user.company.toString()).toBe(company._id.toString());\r\n-  });\r\n+    // Teste 1: Registo de Empresa (já existente)\r\n+    it('deve registar uma nova empresa e o seu proprietário com sucesso', async () => {\r\n+        // ... o código deste teste continua o mesmo ...\r\n+        const newCompanyData = {\r\n+        nomeEmpresa: 'Empresa de Teste',\r\n+        cnpj: '11.222.333/0001-44',\r\n+        email: 'contato@testedev.com',\r\n+        telefoneWhatsapp: '11987654321',\r\n+        username: 'owner_test',\r\n+        ownerEmail: 'owner@testedev.com',\r\n+        password: 'password123'\r\n+        };\r\n+        const response = await request(app)\r\n+        .post('/api/auth/register-company')\r\n+        .send(newCompanyData);\r\n+        expect(response.statusCode).toBe(201);\r\n+        const masterDb = getMasterConnection();\r\n+        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+        const company = await MasterCompany.findOne({ cnpj: newCompanyData.cnpj.replace(/\\D/g, '') });\r\n+        expect(company).not.toBeNull();\r\n+        const user = await MasterUser.findOne({ email: newCompanyData.ownerEmail });\r\n+        expect(user).not.toBeNull();\r\n+        expect(user.company.toString()).toBe(company._id.toString());\r\n+    });\r\n \r\n-  // --- NOVO TESTE ADICIONADO ABAIXO ---\r\n-\r\n+    // Teste 2: Login e acesso protegido (já existente)\r\n     it('deve autenticar um utilizador, retornar um token e permitir o acesso a uma rota protegida', async () => {\r\n         // 1. ARRANGE (Preparação)\r\n         const userData = {\r\n             nomeEmpresa: 'Empresa Login Teste',\r\n@@ -59,8 +58,17 @@\n                 'isVerified': true\r\n             }}\r\n     );\r\n \r\n+    it('deve retornar um erro 401 ao tentar aceder a uma rota protegida sem um token', async () => {\r\n+        // 1. AÇÃO: Tentamos aceder diretamente à rota de boletos sem um token.\r\n+        const response = await request(app).get('/api/boletos');\r\n+\r\n+        // 2. VERIFICAÇÃO: Esperamos ser bloqueados com o erro 401.\r\n+        expect(response.statusCode).toBe(401);\r\n+        expect(response.body.message).toContain('Não autorizado, nenhum token encontrado.');\r\n+    });\r\n+\r\n     // 2. ACT (Ação 1): Tenta fazer o login com os dados criados.\r\n     const loginResponse = await request(app)\r\n         .post('/api/auth/login/direct')\r\n         .send({\r\n@@ -83,7 +91,7 @@\n     // 5. ASSERT (Verificação 2): Verifica se o acesso foi concedido.\r\n     expect(boletosResponse.statusCode).toBe(200);\r\n     // Verificamos se a resposta é um array, como esperado da rota de boletos.\r\n     expect(Array.isArray(boletosResponse.body)).toBe(true);\r\n-  });\r\n+});\r\n   \r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1754510746047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,93 +5,112 @@\n const { getMasterConnection } = require('../config/db');\r\n \r\n describe('Rotas de Autenticação (/api/auth)', () => {\r\n \r\n-    // Teste 1: Registo de Empresa (já existente)\r\n-    it('deve registar uma nova empresa e o seu proprietário com sucesso', async () => {\r\n-        // ... o código deste teste continua o mesmo ...\r\n-        const newCompanyData = {\r\n-        nomeEmpresa: 'Empresa de Teste',\r\n-        cnpj: '11.222.333/0001-44',\r\n-        email: 'contato@testedev.com',\r\n-        telefoneWhatsapp: '11987654321',\r\n-        username: 'owner_test',\r\n-        ownerEmail: 'owner@testedev.com',\r\n+  /**\r\n+   * Teste 1: Valida o fluxo de registo self-service.\r\n+   * Envia dados de uma nova empresa e proprietário e verifica se foram criados na base de dados.\r\n+   */\r\n+  it('deve registar uma nova empresa e o seu proprietário com sucesso', async () => {\r\n+    // 1. Arrange (Preparação): Preparamos os dados que vamos enviar.\r\n+    const newCompanyData = {\r\n+      nomeEmpresa: 'Empresa de Teste',\r\n+      cnpj: '11.222.333/0001-44',\r\n+      email: 'contato@testedev.com',\r\n+      telefoneWhatsapp: '11987654321',\r\n+      username: 'owner_test',\r\n+      ownerEmail: 'owner@testedev.com',\r\n+      password: 'password123'\r\n+    };\r\n+\r\n+    // 2. Act (Ação): Fazemos a requisição POST para a nossa rota de registo.\r\n+    const response = await request(app)\r\n+      .post('/api/auth/register-company')\r\n+      .send(newCompanyData);\r\n+\r\n+    // 3. Assert (Verificação): Verificamos a Resposta da API e a Base de Dados.\r\n+    expect(response.statusCode).toBe(201);\r\n+\r\n+    const masterDb = getMasterConnection();\r\n+    const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+    const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n+\r\n+    const company = await MasterCompany.findOne({ cnpj: newCompanyData.cnpj.replace(/\\D/g, '') });\r\n+    expect(company).not.toBeNull();\r\n+    \r\n+    const user = await MasterUser.findOne({ email: newCompanyData.ownerEmail });\r\n+    expect(user).not.toBeNull();\r\n+    expect(user.company.toString()).toBe(company._id.toString());\r\n+  });\r\n+\r\n+  /**\r\n+   * Teste 2: Valida o fluxo de login e o acesso a uma rota protegida.\r\n+   * Cria um utilizador, ativa a sua subscrição, faz o login para obter um token\r\n+   * e usa esse token para aceder a uma rota que exige autenticação.\r\n+   */\r\n+  it('deve autenticar um utilizador, retornar um token e permitir o acesso a uma rota protegida', async () => {\r\n+    // 1. Arrange (Preparação): Cria um utilizador e uma empresa para o teste.\r\n+    const userData = {\r\n+        nomeEmpresa: 'Empresa Login Teste',\r\n+        cnpj: '44.555.666/0001-77',\r\n+        email: 'contato@loginteste.com',\r\n+        telefoneWhatsapp: '21987654321',\r\n+        username: 'user_login_test',\r\n+        ownerEmail: 'owner@loginteste.com',\r\n         password: 'password123'\r\n-        };\r\n-        const response = await request(app)\r\n-        .post('/api/auth/register-company')\r\n-        .send(newCompanyData);\r\n-        expect(response.statusCode).toBe(201);\r\n-        const masterDb = getMasterConnection();\r\n-        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const MasterUser = masterDb.model('MasterUser', MasterUserSchema);\r\n-        const company = await MasterCompany.findOne({ cnpj: newCompanyData.cnpj.replace(/\\D/g, '') });\r\n-        expect(company).not.toBeNull();\r\n-        const user = await MasterUser.findOne({ email: newCompanyData.ownerEmail });\r\n-        expect(user).not.toBeNull();\r\n-        expect(user.company.toString()).toBe(company._id.toString());\r\n-    });\r\n+    };\r\n+    await request(app).post('/api/auth/register-company').send(userData);\r\n \r\n-    // Teste 2: Login e acesso protegido (já existente)\r\n-    it('deve autenticar um utilizador, retornar um token e permitir o acesso a uma rota protegida', async () => {\r\n-        // 1. ARRANGE (Preparação)\r\n-        const userData = {\r\n-            nomeEmpresa: 'Empresa Login Teste',\r\n-            cnpj: '44.555.666/0001-77',\r\n-            email: 'contato@loginteste.com',\r\n-            telefoneWhatsapp: '21987654321',\r\n-            username: 'user_login_test', // <-- Verifique esta linha\r\n-            ownerEmail: 'owner@loginteste.com',\r\n-            password: 'password123'\r\n-        };\r\n-        await request(app).post('/api/auth/register-company').send(userData);\r\n+    // Ativa a assinatura da empresa que acabamos de criar.\r\n+    const masterDb = getMasterConnection();\r\n+    const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n+    const futureDate = new Date();\r\n+    futureDate.setDate(futureDate.getDate() + 30);\r\n \r\n-        const masterDb = getMasterConnection();\r\n-        const MasterCompany = masterDb.model('MasterCompany', MasterCompanySchema);\r\n-        const futureDate = new Date();\r\n-        futureDate.setDate(futureDate.getDate() + 30);\r\n-        await MasterCompany.updateOne(\r\n-            { cnpj: userData.cnpj.replace(/\\D/g, '') },\r\n-            { $set: { \r\n-                'subscription.status': 'active',\r\n-                'subscription.endDate': futureDate,\r\n-                'isVerified': true\r\n-            }}\r\n+    await MasterCompany.updateOne(\r\n+        { cnpj: userData.cnpj.replace(/\\D/g, '') },\r\n+        { $set: { \r\n+            'subscription.status': 'active',\r\n+            'subscription.endDate': futureDate,\r\n+            'isVerified': true\r\n+        }}\r\n     );\r\n \r\n-    it('deve retornar um erro 401 ao tentar aceder a uma rota protegida sem um token', async () => {\r\n-        // 1. AÇÃO: Tentamos aceder diretamente à rota de boletos sem um token.\r\n-        const response = await request(app).get('/api/boletos');\r\n-\r\n-        // 2. VERIFICAÇÃO: Esperamos ser bloqueados com o erro 401.\r\n-        expect(response.statusCode).toBe(401);\r\n-        expect(response.body.message).toContain('Não autorizado, nenhum token encontrado.');\r\n-    });\r\n-\r\n-    // 2. ACT (Ação 1): Tenta fazer o login com os dados criados.\r\n+    // 2. Act (Ação 1): Tenta fazer o login com os dados criados.\r\n     const loginResponse = await request(app)\r\n         .post('/api/auth/login/direct')\r\n         .send({\r\n             cnpj: userData.cnpj,\r\n             username: userData.username,\r\n             password: userData.password\r\n         });\r\n \r\n-    // 3. ASSERT (Verificação 1): Verifica se o login foi bem-sucedido e retornou um token.\r\n+    // 3. Assert (Verificação 1): Verifica se o login foi bem-sucedido e retornou um token.\r\n     expect(loginResponse.statusCode).toBe(200);\r\n     expect(loginResponse.body.token).toBeDefined();\r\n \r\n     const token = loginResponse.body.token;\r\n \r\n-    // 4. ACT (Ação 2): Usa o token para aceder a uma rota protegida.\r\n+    // 4. Act (Ação 2): Usa o token para aceder a uma rota protegida.\r\n     const boletosResponse = await request(app)\r\n         .get('/api/boletos')\r\n-        .set('Authorization', `Bearer ${token}`); // <-- O ponto mais importante!\r\n+        .set('Authorization', `Bearer ${token}`);\r\n \r\n-    // 5. ASSERT (Verificação 2): Verifica se o acesso foi concedido.\r\n+    // 5. Assert (Verificação 2): Verifica se o acesso foi concedido.\r\n     expect(boletosResponse.statusCode).toBe(200);\r\n-    // Verificamos se a resposta é um array, como esperado da rota de boletos.\r\n     expect(Array.isArray(boletosResponse.body)).toBe(true);\r\n-});\r\n+  });\r\n   \r\n+  /**\r\n+   * Teste 3: Valida a falha de acesso a uma rota protegida sem autenticação.\r\n+   * Garante que o middleware 'protect' está a bloquear corretamente as requisições anónimas.\r\n+   */\r\n+  it('deve retornar um erro 401 ao tentar aceder a uma rota protegida sem um token', async () => {\r\n+    // 1. Ação: Tenta aceder diretamente à rota de boletos sem um token.\r\n+    const response = await request(app).get('/api/boletos');\r\n+\r\n+    // 2. Verificação: Esperamos ser bloqueados com o erro 401 Unauthorized.\r\n+    expect(response.statusCode).toBe(401);\r\n+    expect(response.body.message).toContain('Não autorizado, nenhum token encontrado.');\r\n+  });\r\n+\r\n });\n\\ No newline at end of file\n"
                }
            ],
            "date": 1754507422836,
            "name": "Commit-0",
            "content": "const request = require('supertest');\r\nconst app = require('../server'); // A nossa aplicação Express\r\nconst { schema: MasterCompanySchema } = require('../models/MasterCompany');\r\nconst { schema: MasterUserSchema } = require('../models/MasterUser');\r\nconst mongoose = require('mongoose');\r\n\r\ndescribe('Rotas de Autenticação (/api/auth)', () => {\r\n\r\n  it('deve registar uma nova empresa e o seu proprietário com sucesso', async () => {\r\n    // 1. Arrange (Preparação): Preparamos os dados que vamos enviar.\r\n    const newCompanyData = {\r\n      nomeEmpresa: 'Empresa de Teste',\r\n      cnpj: '11.222.333/0001-44',\r\n      email: 'contato@testedev.com',\r\n      telefoneWhatsapp: '11987654321',\r\n      username: 'owner_test',\r\n      ownerEmail: 'owner@testedev.com',\r\n      password: 'password123'\r\n    };\r\n\r\n    // 2. Act (Ação): Fazemos a requisição POST para a nossa rota de registo.\r\n    const response = await request(app)\r\n      .post('/api/auth/register-company')\r\n      .send(newCompanyData);\r\n\r\n    // 3. Assert (Verificação) - Parte 1: Verificamos a Resposta da API\r\n    expect(response.statusCode).toBe(201);\r\n    expect(response.body.message).toContain('Empresa registada!');\r\n\r\n    // 4. Assert (Verificação) - Parte 2: Verificamos a Base de Dados\r\n    const MasterCompany = mongoose.model('MasterCompany', MasterCompanySchema);\r\n    const MasterUser = mongoose.model('MasterUser', MasterUserSchema);\r\n\r\n    // Verificamos se a empresa foi criada\r\n    const company = await MasterCompany.findOne({ cnpj: newCompanyData.cnpj.replace(/\\D/g, '') });\r\n    expect(company).not.toBeNull();\r\n    expect(company.nomeEmpresa).toBe(newCompanyData.nomeEmpresa);\r\n\r\n    // Verificamos se o utilizador proprietário foi criado\r\n    const user = await MasterUser.findOne({ email: newCompanyData.ownerEmail });\r\n    expect(user).not.toBeNull();\r\n    expect(user.role).toBe('Proprietário');\r\n    \r\n    // Verificamos se o utilizador está corretamente associado à empresa\r\n    expect(user.company.toString()).toBe(company._id.toString());\r\n  });\r\n\r\n});"
        }
    ]
}