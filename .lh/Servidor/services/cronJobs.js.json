{
    "sourceFile": "Servidor/services/cronJobs.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1754501791328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1754501943405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,120 +9,126 @@\n \r\n /**\r\n  * Inicializa todas as tarefas agendadas (cron jobs) da aplicação.\r\n  */\r\n-cron.schedule('0 19 * * *', async () => {\r\n-    console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n-    \r\n-    // Usamos a conexão Mestre que já foi estabelecida\r\n-    const masterDb = getMasterConnection();\r\n-    const MasterCompany = masterDb.model('MasterCompany', require('./models/MasterCompany').schema);\r\n \r\n-    const today = new Date();\r\n-    today.setUTCHours(0, 0, 0, 0); // Define a hora para o início do dia em UTC para comparações\r\n-    const todayStr = today.toISOString().split('T')[0]; // Formato 'YYYY-MM-DD'\r\n+function initCronJobs() {\r\n+    console.log('[CRON] Tarefas agendadas estão ativas.');\r\n \r\n-    try {\r\n-        // 3. Busca todas as empresas com assinatura ativa\r\n-        const activeCompanies = await MasterCompany.find({\r\n-            'subscription.status': 'active',\r\n-            'subscription.endDate': { $gt: today }\r\n-        });\r\n+    cron.schedule('0 19 * * *', async () => {\r\n+        console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n+        \r\n+        // Usamos a conexão Mestre que já foi estabelecida\r\n+        const masterDb = getMasterConnection();\r\n+        const MasterCompany = masterDb.model('MasterCompany', require('./models/MasterCompany').schema);\r\n \r\n-        console.log(`[CRON] Encontradas ${activeCompanies.length} empresas ativas para notificar.`);\r\n+        const today = new Date();\r\n+        today.setUTCHours(0, 0, 0, 0); // Define a hora para o início do dia em UTC para comparações\r\n+        const todayStr = today.toISOString().split('T')[0]; // Formato 'YYYY-MM-DD'\r\n \r\n-        // 4. Itera sobre cada empresa ativa\r\n-        for (const company of activeCompanies) {\r\n-            try {\r\n-                const tenantDb = await getTenantConnection(company.dbName);\r\n-                const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n+        try {\r\n+            // 3. Busca todas as empresas com assinatura ativa\r\n+            const activeCompanies = await MasterCompany.find({\r\n+                'subscription.status': 'active',\r\n+                'subscription.endDate': { $gt: today }\r\n+            });\r\n \r\n-                // 5. Busca as parcelas vencidas e a vencer hoje para esta empresa\r\n-                const overdueParcels = await Boleto.aggregate([\r\n-                    { $unwind: '$parcels' },\r\n-                    { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n-                    { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-                ]);\r\n+            console.log(`[CRON] Encontradas ${activeCompanies.length} empresas ativas para notificar.`);\r\n \r\n-                const dueTodayParcels = await Boleto.aggregate([\r\n-                    { $unwind: '$parcels' },\r\n-                    { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n-                    { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n-                ]);\r\n+            // 4. Itera sobre cada empresa ativa\r\n+            for (const company of activeCompanies) {\r\n+                try {\r\n+                    const tenantDb = await getTenantConnection(company.dbName);\r\n+                    const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n \r\n-                // 6. Se houver parcelas, envia o e-mail\r\n-                if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n-                    console.log(`[CRON] A enviar e-mail para ${company.nomeEmpresa} (${company.email})...`);\r\n-                    await sendDailyReportEmail(masterDb, company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+                    // 5. Busca as parcelas vencidas e a vencer hoje para esta empresa\r\n+                    const overdueParcels = await Boleto.aggregate([\r\n+                        { $unwind: '$parcels' },\r\n+                        { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n+                        { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+                    ]);\r\n+\r\n+                    const dueTodayParcels = await Boleto.aggregate([\r\n+                        { $unwind: '$parcels' },\r\n+                        { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n+                        { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n+                    ]);\r\n+\r\n+                    // 6. Se houver parcelas, envia o e-mail\r\n+                    if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n+                        console.log(`[CRON] A enviar e-mail para ${company.nomeEmpresa} (${company.email})...`);\r\n+                        await sendDailyReportEmail(masterDb, company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n+                    }\r\n+\r\n+                } catch (tenantError) {\r\n+                    console.error(`[CRON] Erro ao processar a empresa ${company.nomeEmpresa}:`, tenantError);\r\n+                    // Continua para a próxima empresa mesmo se uma falhar\r\n                 }\r\n+            }\r\n+            console.log('[CRON] Verificação diária concluída.');\r\n \r\n-            } catch (tenantError) {\r\n-                console.error(`[CRON] Erro ao processar a empresa ${company.nomeEmpresa}:`, tenantError);\r\n-                // Continua para a próxima empresa mesmo se uma falhar\r\n-            }\r\n+        } catch (masterError) {\r\n+            console.error('[CRON] Erro crítico ao buscar empresas ativas:', masterError);\r\n         }\r\n-        console.log('[CRON] Verificação diária concluída.');\r\n+    }, {\r\n+        scheduled: true,\r\n+        timezone: \"America/Sao_Paulo\" // Garante que as 19:00 são no fuso horário de São Paulo/Brasil\r\n+    });\r\n \r\n-    } catch (masterError) {\r\n-        console.error('[CRON] Erro crítico ao buscar empresas ativas:', masterError);\r\n-    }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\" // Garante que as 19:00 são no fuso horário de São Paulo/Brasil\r\n-});\r\n+    // Tarefa agendada para limpar empresas não verificadas (executa todos os dias às 2 da manhã)\r\n+    cron.schedule('0 2 * * *', async () => {\r\n+        console.log('[CRON LIMPEZA] A iniciar a verificação de empresas não verificadas...');\r\n \r\n-// Tarefa agendada para limpar empresas não verificadas (executa todos os dias às 2 da manhã)\r\n-cron.schedule('0 2 * * *', async () => {\r\n-    console.log('[CRON LIMPEZA] A iniciar a verificação de empresas não verificadas...');\r\n+        try {\r\n+            const masterDb = getMasterConnection();\r\n+            const MasterCompany = masterDb.model('MasterCompany', require('./models/MasterCompany').schema);\r\n+            const MasterUser = masterDb.model('MasterUser', require('./models/MasterUser').schema);\r\n \r\n-    try {\r\n-        const masterDb = getMasterConnection();\r\n-        const MasterCompany = masterDb.model('MasterCompany', require('./models/MasterCompany').schema);\r\n-        const MasterUser = masterDb.model('MasterUser', require('./models/MasterUser').schema);\r\n+            // Calcula a data de 10 dias atrás\r\n+            const tenDaysAgo = new Date();\r\n+            tenDaysAgo.setDate(tenDaysAgo.getDate() - 10);\r\n \r\n-        // Calcula a data de 10 dias atrás\r\n-        const tenDaysAgo = new Date();\r\n-        tenDaysAgo.setDate(tenDaysAgo.getDate() - 10);\r\n+            // Encontra empresas não verificadas e criadas há mais de 10 dias\r\n+            const companiesToDelete = await MasterCompany.find({\r\n+                isVerified: false,\r\n+                createdAt: { $lt: tenDaysAgo }\r\n+            });\r\n \r\n-        // Encontra empresas não verificadas e criadas há mais de 10 dias\r\n-        const companiesToDelete = await MasterCompany.find({\r\n-            isVerified: false,\r\n-            createdAt: { $lt: tenDaysAgo }\r\n-        });\r\n+            if (companiesToDelete.length === 0) {\r\n+                console.log('[CRON LIMPEZA] Nenhuma empresa para limpar.');\r\n+                return;\r\n+            }\r\n \r\n-        if (companiesToDelete.length === 0) {\r\n-            console.log('[CRON LIMPEZA] Nenhuma empresa para limpar.');\r\n-            return;\r\n-        }\r\n+            console.log(`[CRON LIMPEZA] Encontradas ${companiesToDelete.length} empresas para apagar.`);\r\n \r\n-        console.log(`[CRON LIMPEZA] Encontradas ${companiesToDelete.length} empresas para apagar.`);\r\n+            for (const company of companiesToDelete) {\r\n+                try {\r\n+                    console.log(`[CRON LIMPEZA] A apagar a empresa: ${company.nomeEmpresa} (CNPJ: ${company.cnpj})`);\r\n \r\n-        for (const company of companiesToDelete) {\r\n-            try {\r\n-                console.log(`[CRON LIMPEZA] A apagar a empresa: ${company.nomeEmpresa} (CNPJ: ${company.cnpj})`);\r\n+                    // Apaga a base de dados da empresa (tenant)\r\n+                    const tenantDb = await getTenantConnection(company.dbName);\r\n+                    await tenantDb.dropDatabase();\r\n \r\n-                // Apaga a base de dados da empresa (tenant)\r\n-                const tenantDb = await getTenantConnection(company.dbName);\r\n-                await tenantDb.dropDatabase();\r\n+                    // Apaga os utilizadores associados no banco mestre\r\n+                    await MasterUser.deleteMany({ company: company._id });\r\n \r\n-                // Apaga os utilizadores associados no banco mestre\r\n-                await MasterUser.deleteMany({ company: company._id });\r\n+                    // Apaga o registo da empresa no banco mestre\r\n+                    await MasterCompany.findByIdAndDelete(company._id);\r\n \r\n-                // Apaga o registo da empresa no banco mestre\r\n-                await MasterCompany.findByIdAndDelete(company._id);\r\n+                    console.log(`[CRON LIMPEZA] Empresa ${company.nomeEmpresa} apagada com sucesso.`);\r\n+                } catch (deleteError) {\r\n+                    console.error(`[CRON LIMPEZA] Erro ao apagar a empresa ${company.nomeEmpresa}:`, deleteError);\r\n+                }\r\n+            }\r\n \r\n-                console.log(`[CRON LIMPEZA] Empresa ${company.nomeEmpresa} apagada com sucesso.`);\r\n-            } catch (deleteError) {\r\n-                console.error(`[CRON LIMPEZA] Erro ao apagar a empresa ${company.nomeEmpresa}:`, deleteError);\r\n-            }\r\n+        } catch (error) {\r\n+            console.error('[CRON LIMPEZA] Erro crítico durante a tarefa de limpeza:', error);\r\n         }\r\n+    }, {\r\n+        scheduled: true,\r\n+        timezone: \"America/Sao_Paulo\"\r\n+    });\r\n \r\n-    } catch (error) {\r\n-        console.error('[CRON LIMPEZA] Erro crítico durante a tarefa de limpeza:', error);\r\n-    }\r\n-}, {\r\n-    scheduled: true,\r\n-    timezone: \"America/Sao_Paulo\"\r\n-});\r\n+}\r\n \r\n // Exportamos a função de inicialização para ser usada no server.js\r\n module.exports = { initCronJobs };\n\\ No newline at end of file\n"
                }
            ],
            "date": 1754501791328,
            "name": "Commit-0",
            "content": "// D:\\SCripts\\SiteLobos\\Servidor\\services\\cronJobs.js\r\n\r\nconst cron = require('node-cron');\r\nconst { getMasterConnection, getTenantConnection } = require('../config/db');\r\nconst { sendDailyReportEmail } = require('./emailService');\r\nconst BoletoSchema = require('../models/Boleto').schema;\r\nconst MasterCompany = require('../models/MasterCompany');\r\nconst MasterUser = require('../models/MasterUser');\r\n\r\n/**\r\n * Inicializa todas as tarefas agendadas (cron jobs) da aplicação.\r\n */\r\ncron.schedule('0 19 * * *', async () => {\r\n    console.log('[CRON] A iniciar a verificação diária de boletos para envio de e-mails...');\r\n    \r\n    // Usamos a conexão Mestre que já foi estabelecida\r\n    const masterDb = getMasterConnection();\r\n    const MasterCompany = masterDb.model('MasterCompany', require('./models/MasterCompany').schema);\r\n\r\n    const today = new Date();\r\n    today.setUTCHours(0, 0, 0, 0); // Define a hora para o início do dia em UTC para comparações\r\n    const todayStr = today.toISOString().split('T')[0]; // Formato 'YYYY-MM-DD'\r\n\r\n    try {\r\n        // 3. Busca todas as empresas com assinatura ativa\r\n        const activeCompanies = await MasterCompany.find({\r\n            'subscription.status': 'active',\r\n            'subscription.endDate': { $gt: today }\r\n        });\r\n\r\n        console.log(`[CRON] Encontradas ${activeCompanies.length} empresas ativas para notificar.`);\r\n\r\n        // 4. Itera sobre cada empresa ativa\r\n        for (const company of activeCompanies) {\r\n            try {\r\n                const tenantDb = await getTenantConnection(company.dbName);\r\n                const Boleto = tenantDb.model('Boleto', BoletoSchema);\r\n\r\n                // 5. Busca as parcelas vencidas e a vencer hoje para esta empresa\r\n                const overdueParcels = await Boleto.aggregate([\r\n                    { $unwind: '$parcels' },\r\n                    { $match: { 'parcels.paid': false, 'parcels.dueDate': { $lt: todayStr } } },\r\n                    { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n                ]);\r\n\r\n                const dueTodayParcels = await Boleto.aggregate([\r\n                    { $unwind: '$parcels' },\r\n                    { $match: { 'parcels.paid': false, 'parcels.dueDate': todayStr } },\r\n                    { $project: { _id: 0, billName: '$name', nfeNumber: '$nfeNumber', parcelNumber: '$parcels.number', amount: '$parcels.amount', dueDate: '$parcels.dueDate' } }\r\n                ]);\r\n\r\n                // 6. Se houver parcelas, envia o e-mail\r\n                if (overdueParcels.length > 0 || dueTodayParcels.length > 0) {\r\n                    console.log(`[CRON] A enviar e-mail para ${company.nomeEmpresa} (${company.email})...`);\r\n                    await sendDailyReportEmail(masterDb, company.email, company.nomeEmpresa, overdueParcels, dueTodayParcels);\r\n                }\r\n\r\n            } catch (tenantError) {\r\n                console.error(`[CRON] Erro ao processar a empresa ${company.nomeEmpresa}:`, tenantError);\r\n                // Continua para a próxima empresa mesmo se uma falhar\r\n            }\r\n        }\r\n        console.log('[CRON] Verificação diária concluída.');\r\n\r\n    } catch (masterError) {\r\n        console.error('[CRON] Erro crítico ao buscar empresas ativas:', masterError);\r\n    }\r\n}, {\r\n    scheduled: true,\r\n    timezone: \"America/Sao_Paulo\" // Garante que as 19:00 são no fuso horário de São Paulo/Brasil\r\n});\r\n\r\n// Tarefa agendada para limpar empresas não verificadas (executa todos os dias às 2 da manhã)\r\ncron.schedule('0 2 * * *', async () => {\r\n    console.log('[CRON LIMPEZA] A iniciar a verificação de empresas não verificadas...');\r\n\r\n    try {\r\n        const masterDb = getMasterConnection();\r\n        const MasterCompany = masterDb.model('MasterCompany', require('./models/MasterCompany').schema);\r\n        const MasterUser = masterDb.model('MasterUser', require('./models/MasterUser').schema);\r\n\r\n        // Calcula a data de 10 dias atrás\r\n        const tenDaysAgo = new Date();\r\n        tenDaysAgo.setDate(tenDaysAgo.getDate() - 10);\r\n\r\n        // Encontra empresas não verificadas e criadas há mais de 10 dias\r\n        const companiesToDelete = await MasterCompany.find({\r\n            isVerified: false,\r\n            createdAt: { $lt: tenDaysAgo }\r\n        });\r\n\r\n        if (companiesToDelete.length === 0) {\r\n            console.log('[CRON LIMPEZA] Nenhuma empresa para limpar.');\r\n            return;\r\n        }\r\n\r\n        console.log(`[CRON LIMPEZA] Encontradas ${companiesToDelete.length} empresas para apagar.`);\r\n\r\n        for (const company of companiesToDelete) {\r\n            try {\r\n                console.log(`[CRON LIMPEZA] A apagar a empresa: ${company.nomeEmpresa} (CNPJ: ${company.cnpj})`);\r\n\r\n                // Apaga a base de dados da empresa (tenant)\r\n                const tenantDb = await getTenantConnection(company.dbName);\r\n                await tenantDb.dropDatabase();\r\n\r\n                // Apaga os utilizadores associados no banco mestre\r\n                await MasterUser.deleteMany({ company: company._id });\r\n\r\n                // Apaga o registo da empresa no banco mestre\r\n                await MasterCompany.findByIdAndDelete(company._id);\r\n\r\n                console.log(`[CRON LIMPEZA] Empresa ${company.nomeEmpresa} apagada com sucesso.`);\r\n            } catch (deleteError) {\r\n                console.error(`[CRON LIMPEZA] Erro ao apagar a empresa ${company.nomeEmpresa}:`, deleteError);\r\n            }\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error('[CRON LIMPEZA] Erro crítico durante a tarefa de limpeza:', error);\r\n    }\r\n}, {\r\n    scheduled: true,\r\n    timezone: \"America/Sao_Paulo\"\r\n});\r\n\r\n// Exportamos a função de inicialização para ser usada no server.js\r\nmodule.exports = { initCronJobs };"
        }
    ]
}